
CRT0 startup module specified as "crt0_standard.o"
    __resetPRI declared as undefined symbol

CRT1 startup module specified as "crt1_standard.o"
    __resetALT declared as undefined symbol

Memory regions defined in linker script:
  name = 'data', origin = 0x800, length = 0xf800 (data-type)
  name = 'program', origin = 0x100, length = 0x3ff00 (program-type)
  name = 'reset', origin = 0x0, length = 0x4 (no type specified)
  name = 'ivt', origin = 0x4, length = 0x7c (no type specified)
  name = 'aivt', origin = 0x84, length = 0x7c (no type specified)
  name = '__FOSC', origin = 0xf80000, length = 0x2 (no type specified)
  name = '__FWDT', origin = 0xf80002, length = 0x2 (no type specified)
  name = '__FBORPOR', origin = 0xf80004, length = 0x2 (no type specified)
  name = '__CONFIG4', origin = 0xf80006, length = 0x2 (no type specified)
  name = '__CONFIG5', origin = 0xf80008, length = 0x2 (no type specified)
  name = '__FGS', origin = 0xf8000a, length = 0x2 (no type specified)
  name = '__FICD', origin = 0xf8000c, length = 0x2 (no type specified)
  name = '__FUID0', origin = 0x8005c0, length = 0x2 (no type specified)
  name = '__FUID1', origin = 0x8005c2, length = 0x2 (no type specified)
  name = '__FUID2', origin = 0x8005c4, length = 0x2 (no type specified)
  name = '__FUID3', origin = 0x8005c6, length = 0x2 (no type specified)
  name = 'eedata', origin = 0x7ff000, length = 0x1000 (no type specified)
  name = '*default*', origin = 0x0, length = 0xffffffff (no type specified)

Creating ELF section '.text', initial map = 1
  sh_flags = 5599a5c6e04f, sh_addr = 6, sh_info = 0

Creating ELF section '.data', initial map = 2
  sh_flags = 5599a5c6e055, sh_addr = 3, sh_info = 0

Creating ELF section '.bss', initial map = 4
  sh_flags = 5599a5c6e05b, sh_addr = 3, sh_info = 0

Loading symbols from t1.o
  (no signature)
  undefined: symLO
  undefined: symHI

Creating ELF section '.text', initial map = 1
  sh_flags = 5599a5c7c43b, sh_addr = 6, sh_info = 0

Creating ELF section '.data', initial map = 2
  sh_flags = 5599a5c7c441, sh_addr = 3, sh_info = 0

Creating ELF section '.bss', initial map = 4
  sh_flags = 5599a5c7c447, sh_addr = 3, sh_info = 0

Loading symbols from t2.o
  (no signature)

Creating ELF section '.text', initial map = 1
  sh_flags = 5599a5c8d9eb, sh_addr = 6, sh_info = 0

Creating ELF section '.data', initial map = 2
  sh_flags = 5599a5c8d9f1, sh_addr = 3, sh_info = 0

Creating ELF section '.bss', initial map = 4
  sh_flags = 5599a5c8d9f7, sh_addr = 3, sh_info = 0

Creating ELF section '.init', initial map = 1
  sh_flags = 5599a5c8da00, sh_addr = 6, sh_info = 0

Creating ELF section '__c30_signature', initial map = 0
  sh_flags = 5599a5c8da06, sh_addr = 3, sh_info = 0

Loading contents of input section '__c30_signature'
...perfect match
...remove __resetPRI

Loading symbols from crt0_standard.o

Loading contents of input section '__c30_signature'
  signature: 0 0x0 0x0
  undefined: __user_init
  undefined: __has_user_init
  undefined: __SP_init
  undefined: __SPLIM_init
  undefined: _SPLIM
  undefined: __enable_fixed
  undefined: CORCON
  undefined: __crt_start_mode
  undefined: __dinit_tbloffset
  undefined: __dinit_tblpage
  undefined: __restart_dinit_tbloffset
  undefined: __restart_dinit_tblpage
  undefined: __data_init_standard
  undefined: _main
  undefined: _CORCON
  undefined: __const_length
  undefined: __const_psvpage
  undefined: _PSVPAG

Creating ELF section '.text', initial map = 1
  sh_flags = 5599a5c9d1ab, sh_addr = 6, sh_info = 0

Creating ELF section '.data', initial map = 2
  sh_flags = 5599a5c9d1b1, sh_addr = 3, sh_info = 0

Creating ELF section '.bss', initial map = 4
  sh_flags = 5599a5c9d1b7, sh_addr = 3, sh_info = 0

Creating ELF section '.init', initial map = 1
  sh_flags = 5599a5c9d1c0, sh_addr = 6, sh_info = 0

Creating ELF section '__c30_signature', initial map = 0
  sh_flags = 5599a5c9d1c6, sh_addr = 3, sh_info = 0

Loading contents of input section '__c30_signature'

Data init is enabled, so __resetALT defined as NULL
...No match

Creating ELF section '.text', initial map = 1
  sh_flags = 5599a5ca9e4b, sh_addr = 6, sh_info = 0

Creating ELF section '.data', initial map = 2
  sh_flags = 5599a5ca9e51, sh_addr = 3, sh_info = 0

Creating ELF section '.bss', initial map = 4
  sh_flags = 5599a5ca9e57, sh_addr = 3, sh_info = 0

Creating ELF section '.init', initial map = 1
  sh_flags = 5599a5ca9e60, sh_addr = 6, sh_info = 0

Creating ELF section '__c30_signature', initial map = 0
  sh_flags = 5599a5ca9e66, sh_addr = 3, sh_info = 0

Loading contents of input section '__c30_signature'

2) Seeking a definition for __data_init_standard (0x0 0x0)
  consider data_init_standard.o (0x0 0x0) ... OK [+0 bits, +0]
...perfect match
...remove __data_init_standard

Loading symbols from data_init_standard.o

Loading contents of input section '__c30_signature'
  signature: 0 0x0 0x0
  undefined: _TBLPAG

Creating ELF section '.text', initial map = 1
  sh_flags = 5599a5caad7f, sh_addr = 6, sh_info = 0

Creating ELF section '.data', initial map = 2
  sh_flags = 5599a5caad85, sh_addr = 3, sh_info = 0

Creating ELF section '.bss', initial map = 4
  sh_flags = 5599a5caad8b, sh_addr = 3, sh_info = 0

crt_start_modeep.o failed bfd_default_compatible
...No match

Creating ELF section '.text', initial map = 1
  sh_flags = 5599a5cb773b, sh_addr = 6, sh_info = 0

Creating ELF section '.data', initial map = 2
  sh_flags = 5599a5cb7741, sh_addr = 3, sh_info = 0

Creating ELF section '.bss', initial map = 4
  sh_flags = 5599a5cb7747, sh_addr = 3, sh_info = 0

Creating ELF section '.libpic30_crt_start_mode', initial map = 1
  sh_flags = 5599a5cb774c, sh_addr = 6, sh_info = 0
...perfect match
...remove __crt_start_mode_normal

Loading symbols from crt_start_mode_normal.Leo
  (no signature)

Creating ELF section '.text', initial map = 1
  sh_flags = 5599a5cd222b, sh_addr = 6, sh_info = 0

Creating ELF section '.data', initial map = 2
  sh_flags = 5599a5cd2231, sh_addr = 3, sh_info = 0

Creating ELF section '.bss', initial map = 4
  sh_flags = 5599a5cd2237, sh_addr = 3, sh_info = 0

Creating ELF section '.libm.frexpf', initial map = 1
  sh_flags = 5599a5cd2240, sh_addr = 6, sh_info = 0

Creating ELF section '__c30_signature', initial map = 0
  sh_flags = 5599a5cd224d, sh_addr = 3, sh_info = 0

Creating ELF section '.text', initial map = 1
  sh_flags = 5599a5ceb7cb, sh_addr = 6, sh_info = 0

Creating ELF section '.data', initial map = 2
  sh_flags = 5599a5ceb7d1, sh_addr = 3, sh_info = 0

Creating ELF section '.bss', initial map = 4
  sh_flags = 5599a5ceb7d7, sh_addr = 3, sh_info = 0

Creating ELF section '.libc.isalnum', initial map = 1
  sh_flags = 5599a5ceb7e0, sh_addr = 6, sh_info = 0

Creating ELF section '__c30_signature', initial map = 0
  sh_flags = 5599a5ceb7ee, sh_addr = 3, sh_info = 0

Looking for CodeGuard settings in object code:

CodeGuard FLASH Memory:
  boot    (none)
  secure  (none)
  general 0x100 to 0x3fffe

CodeGuard RAM Memory:
  general 0x800 to 0xffff
  secure  (none)
  boot    (none)

Merging smart-io functions:

Looping through the input bfds:
  input file t1.o, procID = 30Fxxxx
  input file t2.o, procID = 30Fxxxx
  input file crt0_standard.o, procID = GENERIC-16BIT
  input file data_init_standard.o, procID = GENERIC-16BIT
  input file crt_start_mode_normal.Leo, procID = GENERIC-16BIT

Found a user-defined startup module

Removing crt0_standard.o
  crt0_standard.o had 40 symbols

Creating __DefaultInterrupt function

Creating input section ".isr"
  Adding symbol __DefaultInterrupt

Creating ELF section '.isr', initial map = 1
  sh_flags = 5599a5cfa1db, sh_addr = 6, sh_info = 0

Loading symbols from default_isr
  (no signature)

Recording unmapped section: ".text", attr = 1
Recording unmapped section: ".data", attr = 2
Recording unmapped section: ".bss", attr = 4
Recording unmapped section: ".text", attr = 1
Recording unmapped section: ".data", attr = 2
Recording unmapped section: ".bss", attr = 4
Recording unmapped section: ".text", attr = 1
Recording unmapped section: ".data", attr = 2
Recording unmapped section: ".bss", attr = 4
Recording unmapped section: ".text", attr = 1
Recording unmapped section: ".data", attr = 2
Recording unmapped section: ".bss", attr = 4
Recording unmapped section: ".isr", attr = 1

Before allocation:
      section name    flags    VMA    LMA length
      ------------    -----    ---    --- ------
            .reset        0      0      0      0 
             .text  1000223      0      0      0 
              .icd        0      0      0      0 
   __c30_signature    10200      0      0      0 

Pre-calculating output sections

Before sequential allocation:
      section name    flags    VMA    LMA length
      ------------    -----    ---    --- ------
            .reset        0      0      0      0 
             .text  1000223      0      0      0 
              .icd        0      0      0      0 
   __c30_signature    10200      0      0      0 

Memory Regions:
        data: addr =   800, len =  f800, current =   800
     program: addr =   100, len = 3ff00, current =   100
       reset: addr =     0, len =     4, current =     0
         ivt: addr =     4, len =    7c, current =     4
        aivt: addr =    84, len =    7c, current =    84
      __FOSC: addr = f80000, len =     2, current = f80000
      __FWDT: addr = f80002, len =     2, current = f80002
   __FBORPOR: addr = f80004, len =     2, current = f80004
   __CONFIG4: addr = f80006, len =     2, current = f80006
   __CONFIG5: addr = f80008, len =     2, current = f80008
       __FGS: addr = f8000a, len =     2, current = f8000a
      __FICD: addr = f8000c, len =     2, current = f8000c
     __FUID0: addr = 8005c0, len =     2, current = 8005c0
     __FUID1: addr = 8005c2, len =     2, current = 8005c2
     __FUID2: addr = 8005c4, len =     2, current = 8005c4
     __FUID3: addr = 8005c6, len =     2, current = 8005c6
      eedata: addr = 7ff000, len =  1000, current = 7ff000
   *default*: addr =     0, len = ffffffff, current =     0
  setting SEC_CODE for section .reset

Sequential section .reset in region 'reset'
    [origin = 0, dot = 0, length = 4]

Sequential section .text in region 'program'
    [origin = 100, dot = 100, length = 40000]

Sequential section .icd in region 'data'
    [origin = 800, dot = 800, length = 10000]

Sequential section __c30_signature in region '*default*'
    [origin = 0, dot = 0, length = ffffffff]

Checking section flags:

After sequential allocation:
      section name    flags    VMA    LMA length
      ------------    -----    ---    --- ------
            .reset      223      0      0      4 (fixed)
             .text  1000223    100    100     7e 
              .icd        0    800    800      0 (fixed)
   __c30_signature    10200      0      0      6 

Memory Regions:
        data: addr =   800, len =  f800, current =   800
     program: addr =   100, len = 3ff00, current =   17e
       reset: addr =     0, len =     4, current =     4
         ivt: addr =     4, len =    7c, current =     4
        aivt: addr =    84, len =    7c, current =    84
      __FOSC: addr = f80000, len =     2, current = f80000
      __FWDT: addr = f80002, len =     2, current = f80002
   __FBORPOR: addr = f80004, len =     2, current = f80004
   __CONFIG4: addr = f80006, len =     2, current = f80006
   __CONFIG5: addr = f80008, len =     2, current = f80008
       __FGS: addr = f8000a, len =     2, current = f8000a
      __FICD: addr = f8000c, len =     2, current = f8000c
     __FUID0: addr = 8005c0, len =     2, current = 8005c0
     __FUID1: addr = 8005c2, len =     2, current = 8005c2
     __FUID2: addr = 8005c4, len =     2, current = 8005c4
     __FUID3: addr = 8005c6, len =     2, current = 8005c6
      eedata: addr = 7ff000, len =  1000, current = 7ff000
   *default*: addr =     0, len = ffffffff, current =     6

Contents of unassigned section list at 5599a5cfa620:
  name = (none), addr = 0, len = 0, attr = 0
  name = .text, addr = 0, len = 6, attr = 1
  name = .data, addr = 0, len = 0, attr = 2
  name = .bss, addr = 0, len = 0, attr = 4
  name = .text, addr = 0, len = 0, attr = 1
  name = .data, addr = 0, len = 0, attr = 2
  name = .bss, addr = 0, len = 0, attr = 4
  name = .text, addr = 0, len = 0, attr = 1
  name = .data, addr = 0, len = 0, attr = 2
  name = .bss, addr = 0, len = 0, attr = 4
  name = .text, addr = 0, len = 0, attr = 1
  name = .data, addr = 0, len = 0, attr = 2
  name = .bss, addr = 0, len = 0, attr = 4
  name = .isr, addr = 0, len = 4, attr = 1


Contents of memory region section list at 0:


Building allocation list for data type regions
  attribute has_mask = 0x18000e  hasnot_mask = 0x800021
  input section ".data", len = 0, flags = 243, attr = 2
  input section ".bss", len = 0, flags = 1, attr = 4
  input section ".data", len = 0, flags = 243, attr = 2
  input section ".bss", len = 0, flags = 1, attr = 4
  input section ".data", len = 0, flags = 243, attr = 2
  input section ".bss", len = 0, flags = 1, attr = 4
  input section ".data", len = 0, flags = 243, attr = 2
  input section ".bss", len = 0, flags = 1, attr = 4

Using 'data' as data region

Building free block list for region "data"
  origin = 800, length = f800, current = 800
  block 1, addr = 800, len = f800

Contents of allocation section list at 5599a5cfa9b0:
  name = (none), addr = 0, len = 0, attr = 0
  name = .bss, addr = 0, len = 0, attr = 4
  name = .data, addr = 0, len = 0, attr = 2
  name = .bss, addr = 0, len = 0, attr = 4
  name = .data, addr = 0, len = 0, attr = 2
  name = .bss, addr = 0, len = 0, attr = 4
  name = .data, addr = 0, len = 0, attr = 2
  name = .bss, addr = 0, len = 0, attr = 4
  name = .data, addr = 0, len = 0, attr = 2


Allocating in region 'data'

Locating sections with mask ffffffff, but not 0
  locate_options = 0, exclude_addr = 0

Allocating in region 'data'

Locating sections with mask 80, but not 0
  locate_options = 0, exclude_addr = 0

Allocating in region 'data'

Locating sections with mask 10000, but not 0
  locate_options = 0, exclude_addr = 0

Allocating in region 'data'

Locating sections with mask 100, but not 0
  locate_options = 0, exclude_addr = 0

Allocating in region 'data'

Locating sections with mask 200, but not 0
  locate_options = 0, exclude_addr = 0

Allocating in region 'data'

Locating sections with mask 400, but not 0
  locate_options = 0, exclude_addr = 0

Allocating in region 'data'

Locating sections with mask ffffffff, but not 380000
  locate_options = 0, exclude_addr = 0
  input section ".bss", len = 0, attributes = bss 
    updating section info:  vma = 0, lma = 0
    creating output section statement ".bss%z1"
    removing from allocation list
  input section ".data", len = 0, attributes = data 
    updating section info:  vma = 0, lma = 0
    creating output section statement ".data%z2"
    removing from allocation list
  input section ".bss", len = 0, attributes = bss 
    updating section info:  vma = 0, lma = 0
    creating output section statement ".bss%z3"
    removing from allocation list
  input section ".data", len = 0, attributes = data 
    updating section info:  vma = 0, lma = 0
    creating output section statement ".data%z4"
    removing from allocation list
  input section ".bss", len = 0, attributes = bss 
    updating section info:  vma = 0, lma = 0
    creating output section statement ".bss%z5"
    removing from allocation list
  input section ".data", len = 0, attributes = data 
    updating section info:  vma = 0, lma = 0
    creating output section statement ".data%z6"
    removing from allocation list
  input section ".bss", len = 0, attributes = bss 
    updating section info:  vma = 0, lma = 0
    creating output section statement ".bss%z7"
    removing from allocation list
  input section ".data", len = 0, attributes = data 
    updating section info:  vma = 0, lma = 0
    creating output section statement ".data%z8"
    removing from allocation list

Allocating in region 'data'

Locating sections with mask 80000, but not 0
  locate_options = 0, exclude_addr = 10000

Allocating in region 'data'

Locating sections with mask 100000, but not 0
  locate_options = 0, exclude_addr = 10000

Allocating in region 'data'

Locating sections with mask ffffffff, but not 180000
  locate_options = 3, exclude_addr = 10000

Allocating in region 'data'

Locating sections with mask ffffffff, but not 180000
  locate_options = 2, exclude_addr = 0

Creating unified free block list for 'data' type memory...

Allocating in region 'data'
  attaching 800 (f800 bytes) from region 'data'

Building allocation list for region "program"
  attribute has_mask = 0x1000011  hasnot_mask = 0x800000
  input section ".text", len = 6, flags = 227, attr = 1
  input section ".text", len = 0, flags = 23, attr = 1
  input section ".text", len = 0, flags = 23, attr = 1
  input section ".text", len = 0, flags = 23, attr = 1
  input section ".isr", len = 4, flags = 800223, attr = 1

Using 'program' as program region

Building free block list for region "program"
  origin = 100, length = 3ff00, current = 17e
    (section ".reset", addr = 0, len = 4, attr = 1)
    (section ".text", addr = 100, len = 7e, attr = 2000001)
  block 1, addr = 17e, len = 3fe82

Contents of allocation section list at 5599a5cfa9b0:
  name = (none), addr = 0, len = 0, attr = 0
  name = .text, addr = 0, len = 6, attr = 1
  name = .isr, addr = 0, len = 4, attr = 1
  name = .text, addr = 0, len = 0, attr = 1
  name = .text, addr = 0, len = 0, attr = 1
  name = .text, addr = 0, len = 0, attr = 1


Allocating in region 'program'

Locating sections with mask 80, but not 0
  locate_options = 0, exclude_addr = 0

Allocating in region 'program'

Locating sections with mask 10, but not 0
  locate_options = 0, exclude_addr = 0

Allocating in region 'program'

Locating sections with mask ffffffff, but not 0
  locate_options = 0, exclude_addr = 0
  input section ".text", len = 6, attributes = code 
    consider block at 17e, len = 3fe82
    option1 [advancing from 17e]
    option1 aligned at 17e
    option2 [descending from 3fffa]
    option2 aligned at 3fffa
    option1 = 17e, option2 = 3fffa
    updating section info:  vma = 17e, lma = 17e
    creating output section statement ".text%1"
    creating remainder blocks: 0, 3fe7c
    removing from allocation list
  input section ".isr", len = 4, attributes = code 
    consider block at 184, len = 3fe7c
    option1 [advancing from 184]
    option1 aligned at 184
    option2 [descending from 3fffc]
    option2 aligned at 3fffc
    option1 = 184, option2 = 3fffc
    updating section info:  vma = 184, lma = 184
    creating output section statement ".isr%2"
    creating remainder blocks: 0, 3fe78
    removing from allocation list
  input section ".text", len = 0, attributes = code 
    updating section info:  vma = 0, lma = 0
    creating output section statement ".text%z9"
    removing from allocation list
  input section ".text", len = 0, attributes = code 
    updating section info:  vma = 0, lma = 0
    creating output section statement ".text%z10"
    removing from allocation list
  input section ".text", len = 0, attributes = code 
    updating section info:  vma = 0, lma = 0
    creating output section statement ".text%z11"
    removing from allocation list

Creating unified free block list for 'program' type memory...

Allocating in region 'program'
  attaching 188 (3fe78 bytes) from region 'program'

Building allocation list for region "eedata"
  attribute has_mask = 0x20  hasnot_mask = 0x0

Building allocation list for region "auxflash"
  attribute has_mask = 0x10800000   hasnot_mask = 0x0

Scanning the output statements

After best-fit allocation:
      section name    flags    VMA    LMA length
      ------------    -----    ---    --- ------
            .reset      223      0      0      4 (fixed)
             .text  1000223    100    100     7e 
              .icd        0    800    800      0 (fixed)
   __c30_signature    10200      0      0      6 
           .bss%z1        1      0      0      0 
          .data%z2      243      0      0      0 
           .bss%z3        1      0      0      0 
          .data%z4      243      0      0      0 
           .bss%z5        1      0      0      0 
          .data%z6      243      0      0      0 
           .bss%z7        1      0      0      0 
          .data%z8      243      0      0      0 
           .text%1      223    17e    17e      0 
            .isr%2   800223    184    184      0 
          .text%z9       23      0      0      0 
         .text%z10       23      0      0      0 
         .text%z11       23      0      0      0 

Memory Regions:
        data: addr =   800, len =  f800, current =   800
     program: addr =   100, len = 3ff00, current =   17e
       reset: addr =     0, len =     4, current =     4
         ivt: addr =     4, len =    7c, current =     4
        aivt: addr =    84, len =    7c, current =    84
      __FOSC: addr = f80000, len =     2, current = f80000
      __FWDT: addr = f80002, len =     2, current = f80002
   __FBORPOR: addr = f80004, len =     2, current = f80004
   __CONFIG4: addr = f80006, len =     2, current = f80006
   __CONFIG5: addr = f80008, len =     2, current = f80008
       __FGS: addr = f8000a, len =     2, current = f8000a
      __FICD: addr = f8000c, len =     2, current = f8000c
     __FUID0: addr = 8005c0, len =     2, current = 8005c0
     __FUID1: addr = 8005c2, len =     2, current = 8005c2
     __FUID2: addr = 8005c4, len =     2, current = 8005c4
     __FUID3: addr = 8005c6, len =     2, current = 8005c6
      eedata: addr = 7ff000, len =  1000, current = 7ff000
   *default*: addr =     0, len = ffffffff, current =     6

Before finish:
      section name    flags    VMA    LMA length
      ------------    -----    ---    --- ------
            .reset      223      0      0      4 (fixed)
             .text  1000223    100    100     7e 
              .icd        0    800    800      0 (fixed)
   __c30_signature    10200      0      0      6 
           .bss%z1        1      0      0      0 (fixed)
          .data%z2      243      0      0      0 (fixed)
           .bss%z3        1      0      0      0 (fixed)
          .data%z4      243      0      0      0 (fixed)
           .bss%z5        1      0      0      0 (fixed)
          .data%z6      243      0      0      0 (fixed)
           .bss%z7        1      0      0      0 (fixed)
          .data%z8      243      0      0      0 (fixed)
           .text%1      223    17e    17e      6 (fixed)
            .isr%2   800223    184    184      4 (fixed)
          .text%z9       23      0      0      0 (fixed)
         .text%z10       23      0      0      0 (fixed)
         .text%z11       23      0      0      0 (fixed)

Looking for zero-length sections:
  Stripping section .icd
  Stripping section .bss%z1
  Stripping section .data%z2
  Stripping section .bss%z3
  Stripping section .data%z4
  Stripping section .bss%z5
  Stripping section .data%z6
  Stripping section .bss%z7
  Stripping section .data%z8
  Stripping section .text%z9
  Stripping section .text%z10
  Stripping section .text%z11

Checking PSV sections:

Looking for alignment gaps:

Creating stack from remaining data memory...
  selecting block at 800
  stack base = 800, stack limit = fff0

Creating __heap = 0
Creating __eheap = 0
Creating __SP_init = 800
Creating __SPLIM_init = fff0
Creating __MIN_STACK_SIZE = 10
Creating __STACKGUARD_SIZE = 10
Creating __const_psvpage = 0
Creating __const_length = 0
Creating __enable_fixed = 0
Creating __bootconst_psvpage = 0
Creating __secureconst_psvpage = 0

Cleaning section names:
  .text%1 --> .text
  .isr%2 --> .isr

After finish:
      section name    flags    VMA    LMA length
      ------------    -----    ---    --- ------
            .reset      223      0      0      4 (fixed)
             .text  1000223    100    100     7e 
   __c30_signature    10200      0      0      6 
             .text      223    17e    17e      6 (fixed)
              .isr   800223    184    184      4 (fixed)

Memory Regions:
        data: addr =   800, len =  f800, current =   800
     program: addr =   100, len = 3ff00, current =   17e
       reset: addr =     0, len =     4, current =     4
         ivt: addr =     4, len =    7c, current =     4
        aivt: addr =    84, len =    7c, current =    84
      __FOSC: addr = f80000, len =     2, current = f80000
      __FWDT: addr = f80002, len =     2, current = f80002
   __FBORPOR: addr = f80004, len =     2, current = f80004
   __CONFIG4: addr = f80006, len =     2, current = f80006
   __CONFIG5: addr = f80008, len =     2, current = f80008
       __FGS: addr = f8000a, len =     2, current = f8000a
      __FICD: addr = f8000c, len =     2, current = f8000c
     __FUID0: addr = 8005c0, len =     2, current = 8005c0
     __FUID1: addr = 8005c2, len =     2, current = 8005c2
     __FUID2: addr = 8005c4, len =     2, current = 8005c4
     __FUID3: addr = 8005c6, len =     2, current = 8005c6
      eedata: addr = 7ff000, len =  1000, current = 7ff000
   *default*: addr =     0, len = ffffffff, current =     6

Dynamic Memory
  heap:  2 bytes, 0 to 0
  stack: f7f2 bytes, 800 to fff0

Before generic final link:
   section flags    VMA    LMA length
   ------- ----- ------ ------ ------
    .reset   223      0      0      4
     .text 1000223    100    100     7e
  __c30_signature 10200      0      0      6
     .text   223    17e    17e      6
      .isr 800223    184    184      4
pic30_elf_backend_section_from_bfd_section: .text?

Loading contents of input section '.init'

Relocating generic symbol '_TBLPAG'
  symbol->value = 0x32
  output_base = 0x0
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0xc
  reloc_entry->addend = 0x0
  relocation = 0x32
  final relocation = 0x19 at 0xc

Relocating generic symbol 'L41'
  symbol->value = 0x42
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x1c
  reloc_entry->addend = 0x0
  relocation = 0x142
  final relocation = 0x1a at 0x18

Relocating generic symbol '_TBLPAG'
  symbol->value = 0x32
  output_base = 0x0
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x20
  reloc_entry->addend = 0x0
  relocation = 0x32
  final relocation = 0x32 at 0x20

Relocating generic symbol '_TBLPAG'
  symbol->value = 0x32
  output_base = 0x0
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x2c
  reloc_entry->addend = 0x0
  relocation = 0x32
  final relocation = 0x32 at 0x2c

Relocating generic symbol '_TBLPAG'
  symbol->value = 0x32
  output_base = 0x0
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x38
  reloc_entry->addend = 0x0
  relocation = 0x32
  final relocation = 0x32 at 0x38

Relocating generic symbol 'L21'
  symbol->value = 0x2e
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x50
  reloc_entry->addend = 0x0
  relocation = 0x12e
  final relocation = 0x3 at 0x4c

Relocating generic symbol '__long_indirect_call'
  symbol->value = 0x0
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x54
  reloc_entry->addend = 0x0
  relocation = 0x100
  final relocation = 0x7fffffffffffffeb at 0x50

Relocating generic symbol 'L41'
  symbol->value = 0x42
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x5c
  reloc_entry->addend = 0x0
  relocation = 0x142
  final relocation = 0xa at 0x58

Relocating generic symbol 'L22'
  symbol->value = 0x3a
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x64
  reloc_entry->addend = 0x0
  relocation = 0x13a
  final relocation = 0x4 at 0x60

Relocating generic symbol 'L91'
  symbol->value = 0x32
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x70
  reloc_entry->addend = 0x0
  relocation = 0x132
  final relocation = 0x7ffffffffffffffd at 0x6c

Relocating generic symbol 'L41'
  symbol->value = 0x42
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x74
  reloc_entry->addend = 0x0
  relocation = 0x142
  final relocation = 0x4 at 0x70

Relocating generic symbol 'L31'
  symbol->value = 0x40
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x7c
  reloc_entry->addend = 0x0
  relocation = 0x140
  final relocation = 0x1 at 0x78

Relocating generic symbol '__memcpypd3_std'
  symbol->value = 0x58
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x84
  reloc_entry->addend = 0x0
  relocation = 0x158
  final relocation = 0xb at 0x80

Relocating generic symbol 'L12'
  symbol->value = 0x50
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x94
  reloc_entry->addend = 0x0
  relocation = 0x150
  final relocation = 0x3 at 0x90

Relocating generic symbol 'L11'
  symbol->value = 0xe
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0x9c
  reloc_entry->addend = 0x0
  relocation = 0x10e
  final relocation = 0x7fffffffffffffe0 at 0x98

Relocating generic symbol '_TBLPAG'
  symbol->value = 0x32
  output_base = 0x0
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0xa4
  reloc_entry->addend = 0x0
  relocation = 0x32
  final relocation = 0x19 at 0xa4

Relocating generic symbol 'L41'
  symbol->value = 0x42
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0xb0
  reloc_entry->addend = 0x0
  relocation = 0x142
  final relocation = 0x7ffffffffffffff5 at 0xac

Relocating generic symbol 'L23'
  symbol->value = 0x76
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0xbc
  reloc_entry->addend = 0x0
  relocation = 0x176
  final relocation = 0xc at 0xb8

Relocating generic symbol 'L42'
  symbol->value = 0x74
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0xc8
  reloc_entry->addend = 0x0
  relocation = 0x174
  final relocation = 0x8 at 0xc4

Relocating generic symbol 'L14'
  symbol->value = 0x6e
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0xd0
  reloc_entry->addend = 0x0
  relocation = 0x16e
  final relocation = 0x3 at 0xcc

Relocating generic symbol '_TBLPAG'
  symbol->value = 0x32
  output_base = 0x0
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0xd4
  reloc_entry->addend = 0x0
  relocation = 0x32
  final relocation = 0x32 at 0xd4

Relocating generic symbol 'L13'
  symbol->value = 0x58
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0xdc
  reloc_entry->addend = 0x0
  relocation = 0x158
  final relocation = 0x7ffffffffffffff5 at 0xd8

Relocating generic symbol 'L32'
  symbol->value = 0x68
  output_base = 0x100
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0xe8
  reloc_entry->addend = 0x0
  relocation = 0x168
  final relocation = 0x7ffffffffffffffa at 0xe4

Relocating generic symbol '_TBLPAG'
  symbol->value = 0x32
  output_base = 0x0
  symbol->section->output_offset = 0x0
  reloc_entry->address = 0xf0
  reloc_entry->addend = 0x0
  relocation = 0x32
  final relocation = 0x32 at 0xf0

Loading contents of input section '.libpic30_crt_start_mode'

Loading contents of input section '__c30_signature'

Loading contents of input section '.text'
symbol->name = symLO
symbol->value = 0xffffff80
output_base = 0x0
reloc_target_output_section->lma = 0x0
symbol->section->output_offset = 0x0
offset = 0
output_base = 0
relocation = ffffff80
 --> range check R_PIC30_PBYTE, relocation = 0xffffff80
 --> result = 1
symbol->name = symHI
symbol->value = 0xff
output_base = 0x0
reloc_target_output_section->lma = 0x0
symbol->section->output_offset = 0x0
offset = 0
output_base = 0
relocation = ff
 --> range check R_PIC30_PBYTE, relocation = 0xff
 --> result = 0

Loading contents of input section '.isr'

After generic final link:
   section flags    VMA    LMA length
   ------- ----- ------ ------ ------
    .reset   223      0      0      4
     .text 1000223    100    100     7e
  __c30_signature 10200      0      0      6
     .text   223    17e    17e      6
      .isr 800223    184    184      4

After pic30 final link:
   section flags    VMA    LMA length
   ------- ----- ------ ------ ------
    .reset   223      0      0      4
     .text 1000223    100    100     7e
  __c30_signature 10200      0      0      6
     .text   223    17e    17e      6
      .isr 800223    184    184      4
