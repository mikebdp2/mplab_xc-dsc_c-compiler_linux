;;- Machine description for GNU compiler
;;- Microchip dsPIC30 version.
;;- Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 1, or (at your option)
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	This is the pattern description for the Microchip classic dsPIC.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;- instruction definitions
;;
;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
;;
;; dsPIC30 specific remarks:
;;
;; 1) BITS_PER_UNIT = 8
;;
;; 2) GCC to dsPIC30 data type mappings:
;;    E_QImode => char (8 bits or 1 reg).
;;    E_HImode => short/int (16 bits or 1 reg).
;;    E_SImode => long (32 bits or 2 regs).
;;    E_DImode => long long (64 bits or 4 regs).
;;    E_SFmode => single precision float (32 bits or 2 regs).
;;    E_DFmode => double precision float (64 bits or 4 regs).
;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Condition code settings.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; clobber - value of cc is unknown
;; unchanged - insn does not affect cc
;; set - set to agree with the results of the operation
;; change0 - insn does not affect cc but it does modify operand 0
;;	cc only changed if the item previously set into the condition code
;;	has been modified.
;; math - value of cc has incorrect C and OV flags
;; move - value of cc has incorrect C and OV flags
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
; exch
;

(define_insn "exch_16"
 [(parallel [(set (match_operand:HI 0 "pic30_register_operand" "+r")
                  (match_operand:HI 1 "pic30_register_operand" "+r"))
             (set (match_dup 1)
                  (match_dup 0))]
 )]
 "(!pic30_isa32_target())"
 "*
{
  if (REGNO(operands[1]) == REGNO(operands[0])) {
    return \"; exch %0,%1\";
  } if (pic30_errata_mask & exch_errata) {
    return \"push %0\;mov %1,%0\;pop %1\";
  } else {
    return \"exch %0,%1\";
  }
}"
 [
   (set_attr "type" "etc")
   (set_attr "op_type" "etc")
 ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;; dsp instructions
; DSP instructions
;

; ********* to support builtins

(define_insn "addac_hi_16"
  [(set (match_operand: HI          0 "pic30_accumulator_operand" "=w")
        (plus:HI (match_operand: HI 1 "pic30_accumulator_operand" "w") 
                 (match_operand: HI 2 "pic30_accumulator_operand" "w")))]
  "(!pic30_isa32_target()) && (REGNO(operands[1]) != REGNO(operands[2]))"
  "add %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addac2_hi_16"
  [(set (match_operand: HI          0 "pic30_accumulator_operand" "=w")
        (plus:HI (match_dup 0)
                 (match_operand: HI 1 "pic30_accumulator_operand" "w")))]
  "(!pic30_isa32_target()) && (REGNO(operands[1]) != REGNO(operands[0]))"
  "add %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addacr_shiftrt_hi_16"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (ashiftrt:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " rRS<>")
             (match_operand: HI 2 "immediate_operand"         " Z"))
           (match_operand:HI    3 "pic30_accumulator_operand" " 0"))
  )]
  "(!pic30_isa32_target()) && ((INTVAL(operands[2]) >= 0) && (satisfies_constraint_Z(operands[2])))"
  "add %1, #%2, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addacr_shiftrt_hi_errata_16"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w,w")
        (plus:HI 
           (ashiftrt:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
             (match_operand: HI 2 "immediate_operand"         " Z,Z"))
           (match_operand:HI    3 "pic30_accumulator_operand" " 0,0")))
   (clobber (match_scratch: HI  4                             "=X,r"))
  ]
  "(!pic30_isa32_target()) && ((INTVAL(operands[2]) >= 0) && (satisfies_constraint_Z(operands[2])))"
  "@
   add %1, #%2, %0
   mov.w %1,%4\;add %4,#%2,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addacr_shiftlt_hi_16"
  [(set (match_operand: HI               0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (ashift:HI (match_operand: HI 1 "pic30_mode3_operand"       " RS<>r")
                      (match_operand: HI 2 "immediate_operand"         " i"))
           (match_operand:HI    3 "pic30_accumulator_operand"          "0")))]
  "(!pic30_isa32_target()) && ((INTVAL(operands[2]) >= 0) && (satisfies_constraint_Z(operands[2])))"
  "add %1, #%J2, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addacr_shiftlt_hi_errata_16"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w,w")
        (plus:HI
           (ashift:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
             (match_operand: HI 2 "immediate_operand"         " i,i"))
           (match_operand:HI    3 "pic30_accumulator_operand" " 0,0")))
   (clobber (match_scratch:HI   4                             "=X,r"))
  ]
  "(!pic30_isa32_target()) && (INTVAL(operands[2]) >= 0)"
  "@
   add %1, #%J2, %0
   mov.w %1,%4\;add %4,#%J2,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addacr_noshift_hi_16"
  [(set (match_operand: HI    0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (match_operand: HI 1 "pic30_mode3_operand"       " RS<>r")
           (match_operand:HI  2 "pic30_accumulator_operand" " 0")))]
  "(!pic30_isa32_target())"
  "add %1, #0, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addacr_noshift1_hi_16"
  [(set (match_operand: HI    0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (match_operand:HI  1 "pic30_accumulator_operand" " 0")
           (match_operand: HI 2 "pic30_mode3_operand"       " RS<>r")))]
  "(!pic30_isa32_target())"
  "add %2, #0, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addacr_noshift_hi_errata_16"
  [(set (match_operand: HI    0 "pic30_accumulator_operand" "=w,w")
        (plus:HI
           (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
           (match_operand:HI  2 "pic30_accumulator_operand" " 0,0")))
   (clobber (match_scratch:HI 3                             "=X,r"))
  ]
  "(!pic30_isa32_target())"
  "@
   add %1, #0, %0
   mov.w %1,%3\;add %3,#0,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addacr_noshift1_hi_errata_16"
  [(set (match_operand: HI    0 "pic30_accumulator_operand" "=w,w")
        (plus:HI
           (match_operand:HI  1 "pic30_accumulator_operand" " 0,0")
           (match_operand: HI 2 "pic30_mode3_operand"       " r,RS<>")))
   (clobber (match_scratch:HI 3                             "=X,r"))
  ]
  "(!pic30_isa32_target())"
  "@
   add %2, #0, %0
   mov.w %2,%3\;add %3,#0,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addacr_shiftrt1_hi_16"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w")
        (plus:HI 
           (match_dup 0)
           (ashiftrt:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " RS<>r")
             (match_operand: HI 2 "immediate_operand"         " Z"))))]
  "(!pic30_isa32_target()) && ((INTVAL(operands[2]) >= 0) && !(pic30_errata_mask & psv_errata) && (satisfies_constraint_Z(operands[2])))"
  "add %1, #%2, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addacr_shiftrt1_hi_errata_16"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w,w")
        (plus:HI 
           (match_dup 0)
           (ashiftrt:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
             (match_operand: HI 2 "immediate_operand"         " Z,Z"))))
   (clobber (match_scratch:HI   3                             "=X,r"))
  ]
  "(!pic30_isa32_target()) && ((INTVAL(operands[2]) >= 0) && (pic30_errata_mask & psv_errata) && (satisfies_constraint_Z(operands[2])))"
  "@
   add %1, #%2, %0
   mov.w %1,%3\;add %3,#%2,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addacr_shiftlt1_hi_16"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (ashift:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " RS<>r")
             (match_operand: HI 2 "immediate_operand"         " i"))
           (match_dup 0)))]
  "(!pic30_isa32_target()) && ((INTVAL(operands[2]) >= 0) && !(pic30_errata_mask & psv_errata))"
  "add %1, #%J2, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addacr_shiftlt1_hi_errata_16"
  [(set (match_operand: HI      0 "pic30_accumulator_operand" "=w,w")
        (plus:HI
           (ashift:HI 
             (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
             (match_operand: HI 2 "immediate_operand"         " i,i"))
           (match_dup 0)))
   (clobber (match_scratch: HI  3                             "=X,r"))
  ]
  "(!pic30_isa32_target()) && ((INTVAL(operands[2]) >= 0) && (pic30_errata_mask & psv_errata))"
  "@
   add %1, #%J2, %0
   mov.w %1,%3\;add %3,#%J2,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "clrac_gen_hi_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w,w,w,w,w,w,w,w,w")
        (unspec:HI [
           (const_int 0)
         ] UNSPECV_SETACC))
   (set (match_operand: HI 1 "pic30_mac_input_operand"   "=za,B,B,za,za,za,za,za,B")
        (mem:HI
          (match_operand: HI 2 "pic30_xprefetch_operand" " x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 3 "pic30_xprefetch_operand"   "=2,B,B,2,B,B,2,B,B")
        (plus:HI
          (match_dup 3)
          (match_operand: HI 4 "immediate_operand"       " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 5 "pic30_mac_input_operand"   "=za,za,za,B,B,za,za,za,B")
        (mem:HI
          (match_operand: HI 6 "pic30_yprefetch_operand" " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 7 "pic30_yprefetch_operand"   "=6,6,B,B,B,B,B,6,B")
        (plus:HI
          (match_dup 7)
          (match_operand: HI 8 "immediate_operand"       " Y,Y,i,i,i,i,i,Y,i")))
  ]
  "(!pic30_isa32_target())"
  "@
   clr %0, [%2]+=%4, %1, [%6]+=%8, %5
   clr %0, [%6]+=%8, %5
   clr %0, [%6], %5
   clr %0, [%2]+=%4, %1
   clr %0, [%2], %1
   clr %0, [%2], %1, [%6], %5
   clr %0, [%2]+=%4, %1, [%6], %5
   clr %0, [%2], %1, [%6]+=%8, %5
   clr %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "clracawb_gen_hi_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w,w,w,w,w,w,w,w,w")
        (const_int 0))
   (set (match_operand: HI 1 "pic30_mac_input_operand"   "=za,B,B,za,za,za,za,za,B")
        (mem:HI
          (match_operand: HI 2 "pic30_xprefetch_operand" " x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 3 "pic30_xprefetch_operand"   "=2,B,B,2,B,B,2,B,B")
        (plus:HI
          (match_dup 3)
          (match_operand: HI 4 "immediate_operand"       " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 5 "pic30_mac_input_operand"   "=za,za,za,B,B,za,za,za,B")
        (mem:HI
          (match_operand: HI 6 "pic30_yprefetch_operand" " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 7 "pic30_yprefetch_operand"   "=6,6,B,B,B,B,B,6,B")
        (plus:HI
          (match_dup 7)
          (match_operand: HI 8 "immediate_operand"       " Y,Y,i,i,i,i,i,Y,i")))
   (set (match_operand: HI 9 "pic30_awb_operand"         "=v,v,v,v,v,v,v,v,v")
        (unspec:HI [
          (match_operand:HI 10 "pic30_accumulator_operand" " w,w,w,w,w,w,w,w,w")
          (const_int 0)
        ] UNSPECV_SAC))
  ]
  "(!pic30_isa32_target()) && (REGNO(operands[0]) != REGNO(operands[10]))"
  "@
   clr %0, [%2]+=%4, %1, [%6]+=%8, %5, %9
   clr %0, [%6]+=%8, %5, %9
   clr %0, [%6], %5, %9
   clr %0, [%2]+=%4, %1, %9
   clr %0, [%2], %1, %9
   clr %0, [%2], %1, [%6], %5, %9
   clr %0, [%2]+=%4, %1, [%6], %5, %9
   clr %0, [%2], %1, [%6]+=%8, %5, %9
   clr %0, %9"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "ed_hi_16"
 [
  (set (match_operand:HI 0 "pic30_accumulator_operand" "=w,w,w,w")
       (unspec:HI [
           (match_operand:HI 1 "pic30_mac_input_operand" "za,za,za,za")
           (match_dup 1)
         ] UNSPECV_DSPMULT))
  (set (match_operand:HI 2 "pic30_mac_input_operand" "=za,za,za,za")
       (minus: HI
         (mem: HI (match_operand:HI 3 "pic30_xprefetch_operand" "x,x,x,x"))
         (mem: HI (match_operand:HI 4 "pic30_yprefetch_operand" "y,y,y,y"))))
  (set (match_operand:HI 5 "pic30_xprefetch_operand" "=3,3,B,B")
       (plus: HI
         (match_dup 5)
         (match_operand: HI 6 "immediate_operand" "Y,Y,i,i")))
  (set (match_operand:HI 7 "pic30_yprefetch_operand" "=4,B,B,4")
       (plus: HI
         (match_dup 7)
         (match_operand: HI 8 "immediate_operand" "Y,i,i,Y")))
 ]
 "(!pic30_isa32_target())"
 "@
  ed %1*%1, %0, [%3]+=%6, [%4]+=%8, %2
  ed %1*%1, %0, [%3]+=%6, [%4], %2
  ed %1*%1, %0, [%3], [%4], %2
  ed %1*%1, %0, [%3], [%4]+=%8, %2"
 [
   (set_attr "cc" "unchanged")
   (set_attr "type" "defuse,defuse,defuse,defuse")
   (set_attr "op_type" "alu")
 ]
)

(define_insn "edac_hi_16"
 [
  (set (match_operand:HI 0 "pic30_accumulator_operand" "=w,w,w,w")
       (plus: HI
         (match_operand:HI 1 "pic30_accumulator_operand" "0,0,0,0")
         (unspec:HI [
             (match_operand:HI 2 "pic30_mac_input_operand" "za,za,za,za")
             (match_dup 2)
           ] UNSPECV_DSPMULT)))
  (set (match_operand:HI 3 "pic30_mac_input_operand" "=za,za,za,za")
       (minus: HI
         (mem: HI (match_operand:HI 4 "pic30_xprefetch_operand" "x,x,x,x"))
         (mem: HI (match_operand:HI 5 "pic30_yprefetch_operand" "y,y,y,y"))))
  (set (match_operand:HI 6 "pic30_xprefetch_operand" "=4,4,B,B")
       (plus: HI
         (match_dup 6)
         (match_operand: HI 7 "immediate_operand" "Y,Y,i,i")))
  (set (match_operand:HI 8 "pic30_yprefetch_operand" "=5,B,B,5")
       (plus: HI
         (match_dup 8)
         (match_operand: HI 9 "immediate_operand" "Y,i,i,Y")))
 ]
 "(!pic30_isa32_target())"
 "@
  edac %2*%2, %0, [%4]+=%7, [%5]+=%9, %3
  edac %2*%2, %0, [%4]+=%6, [%5], %3
  edac %2*%2, %0, [%4], [%5], %3
  edac %2*%2, %0, [%4], [%5]+=%9, %3"
 [
   (set_attr "cc" "unchanged")
   (set_attr "type" "defuse,defuse,defuse,defuse")
   (set_attr "op_type" "alu")
 ]
)

(define_insn "fbcl_hi_16"
 [ 
  (set (match_operand:HI 0 "pic30_register_operand" "=r,r")
       (unspec: HI [
                     (match_operand: HI 1 "pic30_mode2_operand" "r,R<>")
                   ] UNSPECV_FBCL))
  (clobber (reg:CC_C CC_REG))
 ]
 "(!pic30_isa32_target())"
 "fbcl %1, %0"
 [
  (set_attr "cc" "clobber")
  (set_attr "type" "etc,defuse")
  (set_attr "op_type" "alu")
 ]
)

(define_insn "lac_hi_16"
  [
  (set (match_operand:HI    0 "pic30_accumulator_operand" "=w,w")
       (unspec:HI [
         (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
         (match_operand: HI 2 "immediate_operand"         " Z,Z")
       ] UNSPECV_LAC))
  ]
  "(!(pic30_errata_mask & psv_errata) && (satisfies_constraint_Z(operands[2])))"
  "lac %1, #%2, %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "lac_si_16"
  [
  (set (match_operand:HI    0 "pic30_accumulator_operand" "=w")
       (unspec:HI [
         (match_operand: SI 1 "pic30_register_operand"    " r")
         (match_operand: HI 2 "immediate_operand"         " Z")
       ] UNSPECV_LACD))
  ]
  "(!(pic30_errata_mask & psv_errata) && (satisfies_constraint_Z(operands[2])))"
  "*
   {
     int n = INTVAL(operands[2]);
     if(n == 0) {
       return \"lac %d1, #0, %0\;mov %1,%m0L\";
     } else {
       return \"lac %d1, #0, %0\;mov %1,%m0L\;sftac %0,#%2\";
     }
   }
  "

  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "lac_error_16"
  [
  (set (match_operand:HI    0 "pic30_accumulator_operand" "=w")
       (unspec:HI [
         (match_operand: HI 1 "pic30_accumulator_operand" " w")
         (match_operand: HI 2 "immediate_operand"         " Z")
       ] UNSPECV_LAC))
  ]
  "(!pic30_isa32_target()) && satisfies_constraint_Z(operands[2])"
  "*
   {
     error(\"Argument 0 should not be an accumulator register\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "lac_hi_errata_16"
  [
  (set (match_operand:HI    0 "pic30_accumulator_operand" "=w,w")
       (unspec:HI [
         (match_operand: HI 1 "pic30_mode3_operand"       " r,RS<>")
         (match_operand: HI 2 "immediate_operand"         " Z,Z")
       ] UNSPECV_LAC))
  (clobber (match_scratch:HI 3                            "=X,r"))
  ]
  "((pic30_errata_mask & psv_errata) && satisfies_constraint_Z(operands[2]))"
  "@
   lac %1, #%2, %0
   mov %1,%3\;lac %3,#%2,%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "lac_si_errata_16"
  [
  (set (match_operand:HI    0 "pic30_accumulator_operand" "=w,w")
       (unspec:HI [
         (match_operand: SI 1 "pic30_mode3_operand"       " r,RS<>")
         (match_operand: HI 2 "immediate_operand"         " Z,Z")
       ] UNSPECV_LACD))
  (clobber (match_scratch:SI 3                            "=X,r"))
  ]
  "((pic30_errata_mask & psv_errata) && satisfies_constraint_Z(operands[2]))"
  "*
   {
     int n = INTVAL(operands[2]);
     switch(which_alternative) {
       default: gcc_assert(0);

       case 0:
         if(n == 0) {
           return \"lac %d1,#0,%0\;mov %1,%m0L\";
         } else {
           return \"lac %d1,#0,%0\;mov %1,%m0L\;sftac %0,#%2\";
         }
         break;
       case 1:
         if(n == 0) {
           return \"mov.d %1,%3\;lac %d3,#0,%0\;mov %3,%m0L\";
         } else {
             return \"mov.d %1,%3\;\"
                    \"lac %d3, #0,%0\;\"
                    \"mov %3,%m0L\;\"
                    \"sftac %0,#%2\";
         }
         break;

     }
  }"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc,use")
  ]
)

(define_insn "acclhi_16"
  [
   (set (match_operand: HI   0 "pic30_register_operand"   "=r")
        (unspec:HI [
          (match_operand: HI 1 "pic30_accumulator_operand" "w")
        ] UNSPEC_ACCL))
  ]
  "(!pic30_isa32_target())"
  "mov.w %m1L,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "acchhi_16"
  [
   (set (match_operand: HI   0 "pic30_register_operand"   "=r")
        (unspec:HI [
          (match_operand: HI 1 "pic30_accumulator_operand" "w")
        ] UNSPEC_ACCH))
  ]
  "(!pic30_isa32_target())"
  "mov.w %m1H,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "accuhi_16"
  [
   (set (match_operand: HI   0 "pic30_register_operand"   "=r")
        (unspec:HI [
          (match_operand: HI 1 "pic30_accumulator_operand" "w")
        ] UNSPEC_ACCU))
  ]
  "(!pic30_isa32_target())"
  "mov.w %m1U,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "sac_gen_hi_16"
  [
   (set (match_operand: HI   0 "pic30_mode3_operand"      "=RS<>,r")
        (unspec:HI [
          (match_operand: HI 1 "pic30_accumulator_operand" "w,   w")
          (match_operand: HI 2 "immediate_operand"         "Z,   Z")
        ] UNSPECV_SAC))
  ]
  "(!pic30_isa32_target()) && satisfies_constraint_Z(operands[2])"
  "sac %1, #%2, %0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc,def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "sac_si_16"
  [
   (set (match_operand: SI 0 "pic30_register_operand"    "=a,r")
      (unspec:SI [
        (match_operand: HI 1 "pic30_accumulator_operand" " w,w")
        (match_operand: HI 2 "immediate_operand"         " Z,Z")
      ] UNSPECV_SACD))
   (clobber
        (match_scratch: HI 3                             "=X,r"))
  ]
  "(!pic30_isa32_target()) && satisfies_constraint_Z(operands[2])"
  "*
   {
     int n = INTVAL(operands[2]);
     if(n == 0) {
       return \"mov.w %m1L,%0\;mov.w %m1H,%d0\";
     } else if(n == -1) {
       return \"sac %1,#%2,%d0\;\"
              \"sl.w %m1L,%0\";
     } else if (n < -1) {
       return \"sac %1,#%2,%d0\;\"
              \"mov.w %m1L,%0\;\"
              \"sl.w %0,#%J2,%0\";
     } else if (n == 1) {
       switch(which_alternative) {
         default: gcc_assert(0);
      
         case 0: return \"lsr.w %m1H,%0\;\"
                        \"mov.w %m1L,%0\;\"
                        \"rrc.w %0,%0\;\"
                        \"sac %1,#1,%d0\";

         case 99: return \"lsr.w %m1H,%3\;\"
                        \"mov.w %m1L,%0\;\"
                        \"rrc.w %0,%0\;\"
                        \"sac %1,#1,%d0\";

         case 1: return \"mov.w %m1H,%3\;\"
                        \"lsr.w %3,%3\;\"
                        \"mov.w %m1L,%0\;\"
                        \"rrc.w %0,%0\;\"
                        \"sac %1,#1,%d0\";
       }
     } else if (n > 1) {
       return \"mov.w %m1H, %d0\;\"
              \"sl.w %d0,#16-%2,%0\;\"
              \"mov.w %m1L, %d0\;\"
              \"lsr.w %d0,#%2,%d0\;\"
              \"ior.w %d0,%0,%0\;\"
              \"sac %1,#%2,%d0\";
     }
   }
  "
  [
    (set_attr "cc" "unchanged, change0")
    (set_attr "type" "defuse")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "sacr_gen_hi_16"
  [
   (set (match_operand: HI 0 "pic30_mode3_operand"                    "=RS<>,r")
        (unspec:HI [
                     (match_operand: HI 1 "pic30_accumulator_operand" "w,w")
		     (match_operand: HI 2 "immediate_operand"         "Z,Z")
                   ] UNSPECV_SACR))
  ]
  "(!pic30_isa32_target()) && satisfies_constraint_Z(operands[2])"
  "sac.r %1, #%2, %0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc,def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "mac_gen_hi_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand"  "=w,w,w,w,w,w,w,w,w")
        (plus:HI 
          (match_operand: HI 1 "pic30_accumulator_operand" "0,0,0,0,0,0,0,0,0")
          (mult:HI 
            (match_operand:HI 2 "pic30_mac_input_operand"  "za,za,za,za,za,za,za,za,za")
            (match_operand:HI 3 "pic30_mac_input_operand"  "za,za,za,za,za,za,za,za,za")
            )))
   (set (match_operand: HI 4 "pic30_mac_input_operand"    "=za,B,B,za,za,za,za,za,B")
        (mem:HI
          (match_operand: HI 5 "pic30_xprefetch_operand"   "x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 6 "pic30_xprefetch_operand"    "=5,B,B,5,B,B,5,B,B")
        (plus:HI
          (match_dup 6)
          (match_operand: HI 7 "immediate_operand"        " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 8 "pic30_mac_input_operand"    "=za,za,za,B,B,za,za,za,B")
        (mem:HI
          (match_operand: HI 9 "pic30_yprefetch_operand"  " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 10 "pic30_yprefetch_operand"   "=9,9,B,B,B,B,B,9,B")
        (plus:HI
          (match_dup 10)
          (match_operand: HI 11 "immediate_operand"      "  Y,Y,i,i,i,i,i,Y,i")))
  ]
  "(!pic30_isa32_target())" 
  "* 
   {
     static const char *mac_options[] = {
       \"mac %2*%3, %0, [%5]+=%7, %4, [%9]+=%11, %8\",  /* 0 */
       \"mac %2*%3, %0, [%9]+=%11, %8\",                /* 1 */
       \"mac %2*%3, %0, [%9], %8\",                     /* 2 */
       \"mac %2*%3, %0, [%5]+=%7, %4\",                 /* 3 */
       \"mac %2*%3, %0, [%5], %4\",                     /* 4 */
       \"mac %2*%3, %0, [%5], %4, [%9], %8\",           /* 5 */
       \"mac %2*%3, %0, [%5]+=%7, %4, [%9], %8\",       /* 6 */
       \"mac %2*%3, %0, [%5], %4, [%9]+=%11, %8\",      /* 7 */
       \"mac %2*%3, %0\",                               /* 8 */
       \"mac %3*%2, %0, [%5]+=%7, %4, [%9]+=%11, %8\",
       \"mac %3*%2, %0, [%9]+=%11, %8\",
       \"mac %3*%2, %0, [%9], %8\",
       \"mac %3*%2, %0, [%5]+=%7, %4\",
       \"mac %3*%2, %0, [%5], %4\",
       \"mac %3*%2, %0, [%5], %4, [%9], %8\",
       \"mac %3*%2, %0, [%5]+=%7, %4, [%9], %8\",
       \"mac %3*%2, %0, [%5], %4, [%9]+=%11, %8\",
       \"mac %3*%2, %0\" };

     if (REGNO(operands[1]) < REGNO(operands[2])) {
       return mac_options[which_alternative];
     } else {
       return mac_options[which_alternative+9];
     }
   }
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
    (set_attr "op_type" "alu")
  ]
)

;
; GCC had trouble respecting the pre-condition; for now restrict the
;   register choices so that u and t don't overlap... this can be improved.
;   also for msc_gen_hi and msc_awbgen_hi
;
(define_insn "macawb_gen_hi_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand"   "=w,w,w,w,w,w,w,w,w")
        (plus:HI
          (match_operand: HI 1 "pic30_accumulator_operand"  "0,0,0,0,0,0,0,0,0")
          (mult:HI
            (match_operand:HI 2 "pic30_mac_input_operand"  " u,u,u,u,u,u,u,u,u")
            (match_operand:HI 3 "pic30_mac_input_operand"  " t,t,t,t,t,t,t,t,t")
   )))
   (set (match_operand: HI 4 "pic30_mac_input_operand"     "=za,B,B,za,za,za,za,za,B")
        (mem:HI
          (match_operand: HI 5 "pic30_xprefetch_operand"   " x,B,B,x,x,x,x,x,B")
   ))
   (set (match_operand: HI 6 "pic30_xprefetch_operand"     "=5,B,B,5,B,B,5,B,B")
        (plus:HI
          (match_dup 6)
          (match_operand: HI 7 "immediate_operand"         " Y,i,i,Y,i,i,Y,i,i")
   ))
   (set (match_operand: HI 8 "pic30_mac_input_operand"     "=za,za,za,B,B,za,za,za,B")
        (mem:HI
          (match_operand: HI 9 "pic30_yprefetch_operand"   " y,y,y,B,B,y,y,y,B")
   ))
   (set (match_operand: HI 10 "pic30_yprefetch_operand"    "=9,9,B,B,B,B,B,9,B")
        (plus:HI
          (match_dup 10)
          (match_operand: HI 11 "immediate_operand"        " Y,Y,i,i,i,i,i,Y,i")
   ))
   (set (match_operand: HI 12 "pic30_awb_operand"         "=v,v,v,v,v,v,v,v,v")
        (unspec:HI [
          (match_operand:HI 13 "pic30_accumulator_operand" " w,w,w,w,w,w,w,w,w")
          (const_int 0)
        ] UNSPECV_SAC))
  ]
  "(!pic30_isa32_target()) && (REGNO(operands[1]) != REGNO(operands[2]))"
  "*
   {
     const char *mac_options[] = { 
       \"mac %2*%3, %0, [%5]+=%7, %4, [%8]+=%11, %8, %12\",              /* 0 */
       \"mac %2*%3, %0, [%9]+=%11, %8, %12\",                            /* 1 */
       \"mac %2*%3, %0, [%9], %8, %12\",                                 /* 2 */
       \"mac %2*%3, %0, [%5]+=%7, %4, %12\",                             /* 3 */
       \"mac %2*%3, %0, [%5], %4, %12\",                                 /* 4 */
       \"mac %2*%3, %0, [%5], %4, [%9], %8, %12\",                       /* 5 */
       \"mac %2*%3, %0, [%5]+=%7, %4, [%9], %8, %12\",                   /* 6 */
       \"mac %2*%3, %0, [%5], %4, [%9]+=%11, %8, %12\",                  /* 7 */
       \"mac %2*%3, %0, %12\",                                           /* 8 */
       \"mac %3*%2, %0, [%5]+=%7, %4, [%9]+=%11, %8, %12\",
       \"mac %3*%2, %0, [%9]+=%11, %8, %12\",
       \"mac %3*%2, %0, [%9], %8, %12\",
       \"mac %3*%2, %0, [%5]+=%7, %4, %12\",
       \"mac %3*%2, %0, [%5], %4, %12\",
       \"mac %3*%2, %0, [%5], %4, [%9], %8, %12\",
       \"mac %3*%2, %0, [%5]+=%7, %4, [%9], %8, %12\",
       \"mac %3*%2, %0, [%5], %4, [%9]+=%11, %8, %12\",
       \"mac %3*%2, %0, %12\" };

     if (REGNO(operands[1]) < REGNO(operands[2])) {
       return mac_options[which_alternative];
     } else {
       return mac_options[which_alternative+9];
     }
   }
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
    (set_attr "op_type" "alu")
  ]
)

;
;  if an AWB is not specified, then it doesn't matter which accumulator we use
;    since the accumulator portion is only there to specify which ACC is 
;    written back
;
(define_insn "movsac_gen_hi_16"
  [ (set (match_operand: HI 0 "pic30_mac_input_operand"  "=za,B,B,za,za,za,za,za,B")
        (mem:HI
          (match_operand: HI 1 "pic30_xprefetch_operand" " x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 2 "pic30_xprefetch_operand"   "=1,B,B,1,x,x,1,B,B")
        (plus:HI
          (match_dup 2)
          (match_operand: HI 3 "immediate_operand"       " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 4 "pic30_mac_input_operand"   "=za,za,za,B,B,za,za,za,B")
        (mem:HI
          (match_operand: HI 5 "pic30_yprefetch_operand" " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 6 "pic30_yprefetch_operand"   "=5,5,B,B,B,B,B,5,B")
        (plus:HI
          (match_dup 6)
          (match_operand: HI 7 "immediate_operand"       " Y,Y,i,i,i,i,i,Y,i")))
  ]
  "(!pic30_isa32_target())"
  "@
   movsac A, [%1]+=%3, %0, [%5]+=%7, %4
   movsac A, [%5]+=%7, %4
   movsac A, [%5], %4
   movsac A, [%1]+=%3, %0
   movsac A, [%1], %0
   movsac A, [%1], %0, [%5], %4
   movsac A, [%1]+=%3, %0, [%5], %4
   movsac A, [%1], %0, [%5]+=%7, %4
   movsac A" 
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
    (set_attr "op_type" "mov")
  ] 
) 

;
;  this is an odd instruction
;
(define_insn "movsacawb_gen_hi_16"
  [(set (match_operand: HI 0 "pic30_mac_input_operand"   "=za,B,B,za,za,za,za,za,B")
        (mem:HI
          (match_operand: HI 1 "pic30_xprefetch_operand" " x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 2 "pic30_xprefetch_operand"   "=1,B,B,1,B,B,1,B,B")
        (plus:HI
          (match_dup 2)
          (match_operand: HI 3 "immediate_operand"       " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 4 "pic30_mac_input_operand"   "=za,za,za,B,B,za,za,za,B")
        (mem:HI
          (match_operand: HI 5 "pic30_yprefetch_operand" " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 6 "pic30_yprefetch_operand"   "=5,5,B,B,B,B,B,5,B")
        (plus:HI
          (match_dup 6)
          (match_operand: HI 7 "immediate_operand"       " Y,Y,i,i,i,i,i,Y,i")))
   (set (match_operand: HI 8 "pic30_awb_operand"         "=v,v,v,v,v,v,v,v,v")
        (unspec:HI [
          (match_operand: HI 9 "pic30_accumulator_operand" " w,w,w,w,w,w,w,w,w")
          (const_int 0)
        ] UNSPECV_SAC))
  ]
  "(!pic30_isa32_target())"
  "@
   movsac %A9, [%1]+=%3, %0, [%5]+=%7, %4, %8
   movsac %A9, [%5]+=%7, %4, %8
   movsac %A9, [%5], %4, %8
   movsac %A9, [%1]+=%3, %0, %8
   movsac %A9, [%1], %0, %8
   movsac %A9, [%1], %0, [%5], %4, %8
   movsac %A9, [%1]+=%3, %0, [%5], %4, %8
   movsac %A9, [%1], %0, [%5]+=%7, %4, %8
   movsac %A9, %8"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
    (set_attr "op_type" "mov")
  ]
)

;      (unspec:HI [
;          (match_operand:HI 1 "pic30_mac_input_operand"  " za,za,za,za,za,za,za,za,za")
;          (match_operand:HI 2 "pic30_mac_input_operand"  " za,za,za,za,za,za,za,za,za")
;        ] UNSPECV_DSPMULT))

(define_insn "mpy_gen_hi_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w,w,w,w,w,w,w,w,w")
        (unspec:HI [
            (match_operand:HI 1 "pic30_mac_input_operand"  " za,za,za,za,za,za,za,za,za")
            (match_operand:HI 2 "pic30_mac_input_operand"  " za,za,za,za,za,za,za,za,za")
          ] UNSPECV_DSPMULT))
   (set (match_operand: HI 3 "pic30_mac_input_operand"   "=za,B,B,za,za,za,za,za,B")
        (mem:HI
          (match_operand: HI 4 "pic30_xprefetch_operand" " x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 5 "pic30_xprefetch_operand"   "=4,B,B,4,B,B,4,B,B")
        (plus:HI
          (match_dup 5)
          (match_operand: HI 6 "immediate_operand"       " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 7 "pic30_mac_input_operand"   "=za,za,za,B,B,za,za,za,B")
        (mem:HI
          (match_operand: HI 8 "pic30_yprefetch_operand" " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 9 "pic30_yprefetch_operand"   "=8,8,B,B,B,B,B,8,B")
        (plus:HI
          (match_dup 9)
          (match_operand: HI 10 "immediate_operand"      " Y,Y,i,i,i,i,i,Y,i")))
  ]
  "(!pic30_isa32_target())" 
  "* 
   {
     const char *mpy_options[] = {
       \"mpy %1*%2, %0, [%4]+=%6, %3, [%8]+=%10, %7\", /* 0 */
       \"mpy %1*%2, %0, [%8]+=%10, %7\",               /* 1 */
       \"mpy %1*%2, %0, [%8], %7\",                    /* 2 */
       \"mpy %1*%2, %0, [%4]+=%6, %3\",                /* 3 */
       \"mpy %1*%2, %0, [%4], %3\",                    /* 4 */
       \"mpy %1*%2, %0, [%4], %3, [%8], %7\",          /* 5 */
       \"mpy %1*%2, %0, [%4]+=%6, %3, [%8], %7\",      /* 6 */
       \"mpy %1*%2, %0, [%4], %3, [%8]+=%10, %7\",     /* 7 */
       \"mpy %1*%2, %0\",                              /* 8 */
       \"mpy %2*%1, %0, [%4]+=%6, %3, [%8]+=%10, %7\",
       \"mpy %2*%1, %0, [%8]+=%10, %7\",
       \"mpy %2*%1, %0, [%8], %7\",
       \"mpy %2*%1, %0, [%4]+=%6, %3\",
       \"mpy %2*%1, %0, [%4], %3\",
       \"mpy %2*%1, %0, [%4], %3, [%8], %7\",
       \"mpy %2*%1, %0, [%4]+=%6, %3, [%8], %7\",
       \"mpy %2*%1, %0, [%4], %3, [%8]+=%10, %7\",
       \"mpy %2*%1, %0\"};

     if (REGNO(operands[1]) < REGNO(operands[2])) {
       return mpy_options[which_alternative];
     } else { 
       return mpy_options[which_alternative+9];
     }
   }
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "mpyn_gen_hi_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w,w,w,w,w,w,w,w,w")
        (unspec:HI [
           (neg:HI
             (match_operand:HI 1 "pic30_mac_input_operand"" za,za,za,za,za,za,za,za,za"))
           (match_operand:HI 2 "pic30_mac_input_operand"  " za,za,za,za,za,za,za,za,za")
          ] UNSPECV_DSPMULT))
   (set (match_operand: HI 3 "pic30_mac_input_operand"   "=za,B,B,za,za,za,za,za,B")
        (mem:HI
          (match_operand: HI 4 "pic30_xprefetch_operand" " x,B,B,x,x,x,x,x,B")))
   (set (match_operand: HI 5 "pic30_xprefetch_operand"   "=4,B,B,4,B,B,4,B,B")
        (plus:HI
          (match_dup 5)
          (match_operand: HI 6 "immediate_operand"       " Y,i,i,Y,i,i,Y,i,i")))
   (set (match_operand: HI 7 "pic30_mac_input_operand"   "=za,za,za,B,B,za,za,za,B")
        (mem:HI
          (match_operand: HI 8 "pic30_yprefetch_operand" " y,y,y,B,B,y,y,y,B")))
   (set (match_operand: HI 9 "pic30_yprefetch_operand"   "=8,8,B,B,B,B,B,8,B")
        (plus:HI
          (match_dup 9)
          (match_operand: HI 10 "immediate_operand"      " Y,Y,i,i,i,i,i,Y,i")))
  ]
  "(!pic30_isa32_target()) && (REGNO(operands[1]) < REGNO(operands[2]))"
  "*
   {
     const char *mpy_options[] = {
       \"mpy.n %1*%2, %0, [%4]+=%6, %3, [%8]+=%10, %7\", /* 0 */
       \"mpy.n %1*%2, %0, [%8]+=%10, %7\",               /* 1 */
       \"mpy.n %1*%2, %0, [%8], %7\",                    /* 2 */
       \"mpy.n %1*%2, %0, [%4]+=%6, %3\",                /* 3 */
       \"mpy.n %1*%2, %0, [%4], %3\",                    /* 4 */
       \"mpy.n %1*%2, %0, [%4], %3, [%8], %7\",          /* 5 */
       \"mpy.n %1*%2, %0, [%4]+=%6, %3, [%8], %7\",      /* 6 */
       \"mpy.n %1*%2, %0, [%4], %3, [%8]+=%10, %7\",     /* 7 */
       \"mpy.n %1*%2, %0\",                              /* 8 */
       \"mpy.n %2*%1, %0, [%4]+=%6, %3, [%8]+=%10, %7\",
       \"mpy.n %2*%1, %0, [%8]+=%10, %7\",
       \"mpy.n %2*%1, %0, [%8], %7\",
       \"mpy.n %2*%1, %0, [%4]+=%6, %3\",
       \"mpy.n %2*%1, %0, [%4], %3\",
       \"mpy.n %2*%1, %0, [%4], %3, [%8], %7\",
       \"mpy.n %2*%1, %0, [%4]+=%6, %3, [%8], %7\",
       \"mpy.n %2*%1, %0, [%4], %3, [%8]+=%10, %7\",
       \"mpy.n %2*%1, %0\"};

     if (REGNO(operands[1]) < REGNO(operands[2])) {
       return mpy_options[which_alternative];
     } else {
       return mpy_options[which_alternative+9];
     }
   }
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "msc_gen_hi_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand"   "=w,w,w,w,w,w,w,w,w")
        (minus:HI 
          (match_operand: HI 1 "pic30_accumulator_operand"  "0,0,0,0,0,0,0,0,0")
          (unspec:HI [
            (match_operand:HI 2 "pic30_mac_input_operand"  " u,u,u,u,u,u,u,u,u")
            (match_operand:HI 3 "pic30_mac_input_operand"  " t,t,t,t,t,t,t,t,t")
          ] UNSPECV_DSPMULT)))
   (set (match_operand: HI 4 "pic30_mac_input_operand"     "=za,B,B,za,za,za,za,za,B")
        (mem:HI
          (match_operand: HI 5 "pic30_xprefetch_operand"   " x,B,B,x,x,x,x,x,B")
   ))
   (set (match_operand: HI 6 "pic30_xprefetch_operand"     "=5,B,B,5,B,B,5,B,B")
        (plus:HI
          (match_dup 6)
          (match_operand: HI 7 "immediate_operand"         " Y,i,i,Y,i,i,Y,i,i")
   ))
   (set (match_operand: HI 8 "pic30_mac_input_operand"     "=za,za,za,B,B,za,za,za,B")
        (mem:HI
          (match_operand: HI 9 "pic30_yprefetch_operand"   " y,y,y,B,B,y,y,y,B")
   ))
   (set (match_operand: HI 10 "pic30_yprefetch_operand"    "=9,9,B,B,B,B,B,9,B")
        (plus:HI
          (match_dup 10)
          (match_operand: HI 11 "immediate_operand"        " Y,Y,i,i,i,i,i,Y,i")
   ))
  ]
  "(!pic30_isa32_target())" 
  "* 
   {
     const char *msc_options[] = {
       \"msc %2*%3, %0, [%5]+=%7, %4, [%9]+=%11, %8\",
       \"msc %2*%3, %0, [%9]+=%11, %8\",
       \"msc %2*%3, %0, [%9], %8\",
       \"msc %2*%3, %0, [%5]+=%7, %4\",
       \"msc %2*%3, %0, [%5], %4\",
       \"msc %2*%3, %0, [%5], %4, [%9], %8\",
       \"msc %2*%3, %0, [%5]+=%7, %4, [%9], %8\",
       \"msc %2*%3, %0, [%5], %4, [%9]+=%11, %8\",
       \"msc %2*%3, %0\",
       \"msc %3*%2, %0, [%5]+=%7, %4, [%9]+=%11, %8\",
       \"msc %3*%2, %0, [%9]+=%11, %8\",
       \"msc %3*%2, %0, [%9], %8\",
       \"msc %3*%2, %0, [%5]+=%7, %4\",
       \"msc %3*%2, %0, [%5], %4\",
       \"msc %3*%2, %0, [%5], %4, [%9], %8\",
       \"msc %3*%2, %0, [%5]+=%7, %4, [%9], %8\",
       \"msc %3*%2, %0, [%5], %4, [%9]+=%11, %8\",
       \"msc %3*%2, %0\"};

     if (REGNO(operands[1]) < REGNO(operands[2])) {
       return msc_options[which_alternative];
     } else { 
       return msc_options[which_alternative+9];
     }
   }
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "mscawb_gen_hi_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand"   "=w,w,w,w,w,w,w,w,w")
        (minus:HI
          (match_operand: HI 1 "pic30_accumulator_operand"  "0,0,0,0,0,0,0,0,0")
          (unspec:HI [
            (match_operand:HI 2 "pic30_mac_input_operand"  " u,u,u,u,u,u,u,u,u")
            (match_operand:HI 3 "pic30_mac_input_operand"  " t,t,t,t,t,t,t,t,t")
          ] UNSPECV_DSPMULT)))
   (set (match_operand: HI 4 "pic30_mac_input_operand"     "=za,B,B,za,za,za,za,za,B")
        (mem:HI
          (match_operand: HI 5 "pic30_xprefetch_operand"   " x,B,B,x,x,x,x,x,B")
   ))
   (set (match_operand: HI 6 "pic30_xprefetch_operand"     "=5,B,B,5,B,B,5,B,B")
        (plus:HI
          (match_dup 6)
          (match_operand: HI 7 "immediate_operand"         " Y,i,i,Y,i,i,Y,i,i")
   ))
   (set (match_operand: HI 8 "pic30_mac_input_operand"     "=za,za,za,B,B,za,za,za,B")
        (mem:HI
          (match_operand: HI 9 "pic30_yprefetch_operand"   " y,y,y,B,B,y,y,y,B")
   ))
   (set (match_operand: HI 10 "pic30_yprefetch_operand"    "=9,9,B,B,B,B,B,9,B")
        (plus:HI
          (match_dup 10)
          (match_operand: HI 11 "immediate_operand"        " Y,Y,i,i,i,i,i,Y,i")
   ))
   (set (match_operand: HI 12 "pic30_awb_operand"         "=v,v,v,v,v,v,v,v,v")
        (unspec:HI [
          (match_operand:HI 13 "pic30_accumulator_operand" " w,w,w,w,w,w,w,w,w")
          (const_int 0)
        ] UNSPECV_SAC)
   )
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *msc_options[] = {
       \"msc %2*%3, %0, [%5]+=%7, %4, [%9]+=%11, %8, %12\",
       \"msc %2*%3, %0, [%9]+=%11, %8, %12\",
       \"msc %2*%3, %0, [%9], %8, %12\",
       \"msc %2*%3, %0, [%5]+=%7, %4, %12\",
       \"msc %2*%3, %0, [%5], %4, %12\",
       \"msc %2*%3, %0, [%5], %4, [%9], %8, %12\",
       \"msc %2*%3, %0, [%5]+=%7, %4, [%9], %8, %12\",
       \"msc %2*%3, %0, [%5], %4, [%9]+=%11, %8, %12\",
       \"msc %2*%3, %0, %12\",
       \"msc %3*%2, %0, [%5]+=%7, %4, [%9]+=%11, %8, %12\",
       \"msc %3*%2, %0, [%9]+=%11, %8, %12\",
       \"msc %3*%2, %0, [%9], %8, %12\",
       \"msc %3*%2, %0, [%5]+=%7, %4, %12\",
       \"msc %3*%2, %0, [%5], %4, %12\",
       \"msc %3*%2, %0, [%5], %4, [%9], %8, %12\",
       \"msc %3*%2, %0, [%5]+=%7, %4, [%9], %8, %12\",
       \"msc %3*%2, %0, [%5], %4, [%9]+=%11, %8, %12\",
       \"msc %3*%2, %0, %12\"};

     if (REGNO(operands[1]) < REGNO(operands[2])) {
       return msc_options[which_alternative];
     } else {
       return msc_options[which_alternative+9];
     }
   }
  " 
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "defuse,defuse,defuse,defuse,defuse,defuse,defuse,defuse,etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "sftac_gen_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w,w")
        (unspec:HI [
                     (match_operand: HI 1 "pic30_accumulator_operand" "0,0")
                     (match_operand: HI 2 "pic30_reg_or_imm_operand" "r,W")
                   ] UNSPECV_SFTAC)
   )]
  "(!pic30_isa32_target())"
  "@
   sftac %0, %2
   sftac %0, #%2"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "sftac_error_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w")
        (ashift:HI
           (match_operand: HI 1 "general_operand" "")
           (match_operand: HI 2 "general_operand" "")))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_sftac() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "subac_hi_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand"  "=w")
        (minus:HI (match_operand: HI 1 "pic30_accumulator_operand" "w")
                  (match_operand: HI 2 "pic30_accumulator_operand" "w")))]
  "(!pic30_isa32_target()) && (REGNO(operands[2]) != REGNO(operands[1]))"
  "sub %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

; ********* to support automagic generation

(define_insn "movhi_accumulator_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (match_operand:HI 1 "pic30_mode3_operand" "RS<>r"))]
  "(!pic30_isa32_target())"
  "*{
        /* lac %1, %0 */
        error(\"Automatic generation of DSP instructions not yet supported; \"
              \"use __builtin_lac() instead\");
        return \"cannot generate instruction\";
    }
  "
)  

(define_insn "movhi_accumulator_umm_16"
   [(set (match_operand:QI      0 "pic30_accumulator_operand"    "=w,w,w, w,w")
         (unspec:QI [
           (match_operand:QI    1 "pic30_mem_umm_operand"  " R<>,R<>,QS,U,T")
           (clobber 
             (match_scratch:HI  2                          "=X,  r,  X, X,X"))
          ] UNSPEC_UNIFIED_RD))
    (clobber (reg:HI PSVPAG))
   ] 
  ""
  "*{
        /* lac %1, %0 */
        error(\"Automatic generation of DSP instructions not yet supported; \"
              \"use __builtin_lac() instead\");
        return \"cannot generate instruction\";
    }
  "
)  

(define_insn "movhi_accumulator2_16"
  [(set (match_operand:HI 0 "register_operand" "")
        (match_operand:HI 1 "pic30_accumulator_operand" "w"))]
  ""
  "*
    /* sac %1, #0, %0 */
    {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_sac() instead\");
     return \"cannot generate instruction\";
    }
  "
)

(define_insn "movhi_accumulator2_umm_16"
   [(set (match_operand:HI      0 "pic30_mem_umm_operand"  "=R,QSUT")
         (unspec:HI [
           (match_operand:HI    1 "pic30_accumulator_operand" "w,w")
           (clobber              
              (match_scratch:HI 2                         "=&r,&r"))
         ] UNSPEC_UNIFIED_WT))
    (clobber (reg:HI DSWPAG))
   ]    
  ""
  "*
    /* sac %1, #0, %0 */
    {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_sac() instead\");
     return \"cannot generate instruction\";
    }
  "
)

(define_insn "movhi_accumulator3_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (match_operand:HI 1 "immediate_operand" "i"))]
  "(TARGET_CLASSIC)"
  "*
   {
     if (INTVAL(operands[1]) == 0) {
        /* clr %0 */
        error(\"Automatic generation of DSP instructions not yet supported; \"
              \"use __builtin_clr() instead\");
        return \"cannot generate instruction\";
     } else {
        /* lac ... */
        error(\"Automatic generation of DSP instructions not yet supported; \"
              \"use __builtin_lac() instead\");
        return \"cannot generate instruction\";
     }
   }
  "
)

(define_insn "addab_error_16"
  [(set (match_operand: HI          0 "pic30_accumulator_operand" "=w")
        (plus:HI (match_operand:HI 1 "pic30_mode3_operand" "RS<>r")
                 (match_operand:HI 2 "pic30_mode3_operand" "RS<>r")))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_addab() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_mac_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (plus:HI
          (match_operand:HI 1 "pic30_accumulator_operand" "0")
          (subreg:HI
            (mult:SI
              (sign_extend:SI
                (match_operand: HI 2 "pic30_mac_input_operand" "za"))
              (sign_extend:SI
                (match_operand: HI 3 "pic30_mac_input_operand" "za"))) 0)))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_mac() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_mac1_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (plus:HI
          (subreg:HI
            (mult:SI
              (sign_extend:SI
                (match_operand: HI 1 "pic30_mac_input_operand" "za"))
              (sign_extend:SI
                (match_operand: HI 2 "pic30_mac_input_operand" "za"))) 0)
          (match_operand:HI 3 "pic30_accumulator_operand" "0")))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_mac() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_mpy_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (neg: HI
          (subreg:HI
            (mult:SI
              (sign_extend:SI
                (match_operand: HI 1 "pic30_mac_input_operand" "za"))
              (sign_extend:SI
                (match_operand: HI 2 "pic30_mac_input_operand" "za"))) 0)))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_mpy() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_msc_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (minus:HI
          (match_operand:HI 1 "pic30_accumulator_operand" "0")
          (subreg:HI
            (mult:SI
              (sign_extend:SI
                (match_operand: HI 2 "pic30_mac_input_operand" "za"))
              (sign_extend:SI
                (match_operand: HI 3 "pic30_mac_input_operand" "za"))) 0)))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_msc() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_msc1_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (minus:HI
          (subreg:HI
            (mult:SI
              (sign_extend:SI
                (match_operand: HI 1 "pic30_mac_input_operand" "za"))
              (sign_extend:SI
                (match_operand: HI 2 "pic30_mac_input_operand" "za"))) 0)
          (match_operand:HI 3 "pic30_accumulator_operand" "0")))]
  ""
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_msc() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_sftacr_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (ashiftrt:HI
          (match_dup 0)
          (match_operand:HI 1 "immediate_operand"       "W")))]
  "(!pic30_isa32_target()) && (INTVAL(operands[1]) > 0)"
  "*
   {
     /* sftac %0, #%1 */
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_sftac() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "auto_sftacl_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (ashift:HI 
          (match_dup 0)
          (match_operand:HI 1 "immediate_operand"       "W")))]
  "(!pic30_isa32_target()) && (INTVAL(operands[1]) > 0)"
  "*
   {
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_sftac() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "addacr_hi_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (match_operand: HI 1 "pic30_mode3_operand" "RS<>r")
           (match_operand: HI 2 "pic30_accumulator_operand" "0")))]
  ""
  "*
   {
     /* add %1, %0 */
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_add() instead\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "addacr1_hi_16"
  [(set (match_operand: HI 0 "pic30_accumulator_operand" "=w")
        (plus:HI
           (match_operand: HI 1 "pic30_accumulator_operand" "0")
           (match_operand: HI 2 "pic30_mode3_operand" "RS<>r")))]
  ""
  "*
   {
     /* add %2, %0 */
     error(\"Automatic generation of DSP instructions not yet supported; \"
           \"use __builtin_add() instead\");
     return \"cannot generate instruction\";
   }
  "
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; __builtin_unique_id

(define_insn "unique_id_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (unspec_volatile:HI [ (match_operand 1 "immediate_operand" "i")
                              (match_operand:HI 2 "immediate_operand" "i")
                            ] UNSEPCV_GENLABEL))]
  "(!pic30_isa32_target())"
  "*
   {  static char buffer[80];
      char *label;

      label = (char *)(INTVAL(operands[1]));
      sprintf(buffer,\".global %s\n%s:\n\tmov.w #%ld,%%0\",
              label,label,INTVAL(operands[2]));
      return buffer;
   }
  "
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; __builtin_tblrdl, __builtin_tblrdh, __builtin_tblwtl, __builtin_tblwth

(define_insn "tblrdl_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=rR<>")
        (unspec_volatile:HI 
          [(match_operand:HI 1 "pic30_register_operand" "r")] UNSPECV_TBLRDL
        )
    )]
  "(!pic30_isa32_target())"
  "tblrdl.w [%1], %0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "tblrdlb_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=rR<>")
        (unspec_volatile:QI
          [(match_operand:HI 1 "pic30_register_operand" "r")] UNSPECV_TBLRDLB
        )
    )]
  "(!pic30_isa32_target())"
  "tblrdl.b [%1], %0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "tblrdh_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=rR<>") 
        (unspec_volatile:HI 
          [(match_operand:HI 1 "pic30_register_operand" "r")] UNSPECV_TBLRDH
        )
    )]
  "(!pic30_isa32_target())"
  "tblrdh.w [%1], %0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "tblrdhb_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=rR<>")
        (unspec_volatile:QI
          [(match_operand:HI 1 "pic30_register_operand" "r")] UNSPECV_TBLRDHB
        )
    )]
  "(!pic30_isa32_target())"
  "tblrdh.b [%1], %0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "tblwtl_16"
  [(unspec_volatile:HI 
     [(match_operand:HI 0 "pic30_register_operand" "r")
      (match_operand:HI 1 "pic30_mode2_operand" "rR<>")] UNSPECV_TBLWTL
   )
  ]
  "(!pic30_isa32_target())"
  "tblwtl.w %1, [%0]"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "tblwtlb_16"
  [(unspec_volatile:QI
     [(match_operand:HI 0 "pic30_register_operand" "r")
      (match_operand:QI 1 "pic30_mode2_operand" "rR<>")] UNSPECV_TBLWTLB
   )
  ]
  "(!pic30_isa32_target())"
  "tblwtl.b %1, [%0]"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "tblwth_16"
  [(unspec_volatile:HI  
     [(match_operand:HI 0 "pic30_register_operand" "r")
      (match_operand:HI 1 "pic30_mode2_operand" "rR<>")] UNSPECV_TBLWTH
   )
  ]
  "(!pic30_isa32_target())"
  "tblwth.w %1, [%0]"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "tblwthb_16"
  [(unspec_volatile:QI
     [(match_operand:HI 0 "pic30_register_operand" "r")
      (match_operand:QI 1 "pic30_mode2_operand" "rR<>")] UNSPECV_TBLWTHB
   )
  ]
  "(!pic30_isa32_target())"
  "tblwth.b %1, [%0]"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; stackpush
;; These patterns are used for passing arguments on the stack.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "pushqi_16"
  [(set (match_operand:HI 0 "push_operand"   "=>")
        (subreg:HI 
          (match_operand:QI 1 "register_operand" "r") 0))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;mov.w %1,[w15++]\";
   } else {
     return \"mov.w %1,[w15++]\";
   }
  "
  [ 
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "pushqi1_16"
  [(set (mem:HI (post_inc:HI (reg:HI SPREG)))
                (subreg:HI (match_operand:QI 0 "register_operand" "r") 0))]
  ""
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;push %0\";
   } else {
     return \"push %0\";
   }
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
  ]
)
 
(define_insn "*pushminus1hi_16"
  [(set (match_operand:HI 0 "push_operand"   "=>")
	(const_int -1))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;setm %0\";
   } else {
     return \"setm.w %0\";
   }
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "pushhi1_16"
  [(set (mem:HI (post_inc:HI (reg:HI SPREG)))
                (match_operand:HI 0 "register_operand" "r"))]
  ""
  "push %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
  ]
)

(define_insn "pushhi_16"
  [(set (match_operand:HI 0 "push_operand"   "=>,>,>,>")
        (match_operand:HI 1 "pic30_pushhi_operand" "r,R>,O,T"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     switch (which_alternative) {
       default: gcc_assert(0);
  
       case 0: return \"movpag #1,DSWPAG\;mov.w %1,%0\";
               break;
       case 1: return \"movpag #1,DSWPAG\;mov.w %1,%0\";
               break;
       case 2: return \"movpag #1,DSWPAG\;clr.w %0\";
               break;
       case 3: return \"movpag #1,DSWPAG\;push %1\";
               break;
     }
   } else {
     switch (which_alternative) {
       default: gcc_assert(0);

       case 0: return \"mov.w %1,%0\";
               break;
       case 1: return \"mov.w %1,%0\";
               break;
       case 2: return \"clr.w %0\";
               break;
       case 3: return \"push %1\";
               break;
     }
  }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def,defuse,def,def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "pushsi1_16"
  [(set (mem:SI (post_inc:HI (reg:HI SPREG)))
                (match_operand:SI 0 "register_operand" "r"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;push.d %0\";
   } else {
     return \"push.d %0\";
   }
  "
  [ 
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)
 
(define_insn "push<mode>_16"
  [(set (match_operand:MODES32 0 "push_operand"   "=>")
        (match_operand:MODES32 1 "pic30_register_operand" "r"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;mov.d %1,[w15++]\";
   } else {
     return \"mov.d %1,[w15++]\";
   }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "pushdi1_16"
  [(set (mem:DI (post_inc:HI (reg:HI SPREG)))
                (match_operand:DI 0 "register_operand" "r"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;push.d %0\;push.d %t0\";
   } else {
     return \"push.d %0\;push.d %t0\";
   }
  "
  [ 
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)
 
(define_insn "pushdi_16"
  [(set (match_operand:DI 0 "push_operand"   "=>")
        (match_operand:DI 1 "pic30_register_operand" "r"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;mov.d %1,[w15++]\;mov.d %t1,[w15++]\";
   } else { 
     return \"mov.d %1,[w15++]\;mov.d %t1,[w15++]\";
   }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "pushsf1_16"
  [(set (mem:SF (post_inc:HI (reg:HI SPREG)))
                (match_operand:SF 0 "register_operand" "r"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;push.d %0\";
   } else {
     return \"push.d %0\";
   }
  "
  [ 
    (set_attr "cc" "unchanged")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)
 
(define_insn "*pushsf_16"
  [(set (match_operand:SF 0 "push_operand"   "=>")
        (match_operand:SF 1 "pic30_register_operand" "r"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;mov.d %1,[w15++]\";
   } else {
     return \"mov.d %1,[w15++]\";
   }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "pushdf1_16"
  [(set (mem:DF (post_inc:HI (reg:HI SPREG)))
                (match_operand:DF 0 "register_operand" "r"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;mov.d %0,[w15++]\;mov.d %t0,[w15++]\";
   } else {
     return \"mov.d %0,[w15++]\;mov.d %t0,[w15++]\";
   }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "mov")
  ]
)
 
(define_insn "pushdf_16"
  [(set (match_operand:DF 0 "push_operand"   "=>")
        (match_operand:DF 1 "pic30_register_operand" "r"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSWPAG\;mov.d %1,[w15++]\;mov.d %t1,[w15++]\";
   } else {
     return \"mov.d %1,[w15++]\;mov.d %t1,[w15++]\";
   }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "pushshadow_16"
  [(unspec [(const_int 0)] UNSPEC_PUSHSHADOW)
   (use (reg:HI 0))
   (use (reg:HI 1))
   (use (reg:HI 2))
   (use (reg:HI 3))
  ]
  "(!pic30_isa32_target())"
  "push.s"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "popshadow_16"
  [(unspec [(const_int 0)] UNSPEC_POPSHADOW)
   (clobber (reg:HI 0))
   (clobber (reg:HI 1))
   (clobber (reg:HI 2))
   (clobber (reg:HI 3))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "pop.s"
  [
    (set_attr "type" "etc")
    (set_attr "cc" "clobber")
    (set_attr "op_type" "mov")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; stackpop
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "popqi_16"
  [(set (match_operand:QI 0 "pic30_register_operand" "=r")
        (match_operand:QI 1 "pop_operand"       "<"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSRPAG\;mov.w %1,%0\";
   } else {
     return \"mov.w %1,%0\";
   }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "defuse")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "pophi_16"
  [(set (match_operand:HI 0 "pic30_reg_or_mem_operand" "=r,<,T")
        (match_operand:HI 1 "pop_operand"    " <,<,<"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"movpag #1,DSRPAG\;mov.w %1,%0\";
       case 1: return \"movpag #1,DSRPAG\;mov.w %1,%0\";
       case 2: return \"movpag #1,DSRPAG\;pop %0\";
     } 
   } else {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"mov.w %1,%0\";
       case 1: return \"mov.w %1,%0\";
       case 2: return \"pop %0\";
     } 
   }
  "
  [
   (set_attr "cc" "change0, change0, change0")
   (set_attr "type" "defuse,defuse,defuse")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "pophi_unspec_16"
  [(set (unspec:HI [(match_operand:HI 0 "pic30_general_operand" "=r<,T")]
                   UNSPEC_POPHI)
        (mem:HI (pre_dec:HI (reg:HI SPREG))))
   (clobber (match_dup 0))
  ]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"movpag #1,DSRPAG\;mov.w [--w15],%0\";
       case 1: return \"movpag #1,DSRPAG\;pop %0\";
     }
   } else {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"mov [--w15],%0\";
       case 1: return \"pop %0\";
     }
   }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "defuse,defuse")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "popsi_16"
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
        (match_operand:SI 1 "pop_operand"       "<"))
  ]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSRPAG\;mov.d %1,%0\";
   } else {
     return \"mov.d %1,%0\";
   }
  "
  [
    (set_attr "cc" "change0")
    (set_attr "type" "defuse")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "popdi_16"
  [(set (match_operand:DI 0 "pic30_register_operand" "=r")
        (match_operand:DI 1 "pop_operand"       "<"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSRPAG\;mov.d %1,%t0\;mov.d %1,%0\";
   } else {
     return \"mov.d %1,%t0\;mov.d %1,%0\";
   }
  "
  [
    (set_attr "cc" "change0")
    ;(set_attr "type" "defuse")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "popsf_16"
  [(set (match_operand:SF 0 "pic30_register_operand" "=r")
        (match_operand:SF 1 "pop_operand"       "<"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSRPAG\;mov.d %1,%0\";
   } else {
     return \"mov.d %1,%0\";
   }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "defuse")
    (set_attr "op_type" "mov")
  ]
)
   
(define_insn "popdf_16"
  [(set (match_operand:DF 0 "pic30_register_operand" "=r")
        (match_operand:DF 1 "pop_operand"       "<"))]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_ecore_target()||pic30_isav4_target()) && TARGET_EDS) {
     return \"movpag #1,DSRPAG\;mov.d %1,%t0\;mov.d %1,%0\";
   } else {
     return \"mov.d %1,%t0\;mov.d %1,%0\";
   }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "defuse")
   (set_attr "op_type" "mov")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; stackcheck
;; If STACK_CHECK_BUILTIN is zero, and you define a named pattern called
;; check_stack in your 'md' file, GCC will call that pattern with one
;; argument which is the address to compare the stack value against.
;; You must arrange for this pattern to report an error if the stack
;; pointer is out of range.
;; (define_insn "check_stack_16"
;;   [(match_operand 0 "pic30_register_operand" "r")
;;    (clobber (match_scratch:HI 1 "=r"))]
;;   ""
;;   "mov .BOS,%1\;cpsge %0,%1\;reset")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Test operations.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "tstqi_DATA_16"
  [(set (reg:CC CC_REG)
        (compare
           (match_operand:QI 0 "pic30_near_mode2_operand" "U,r,R<>")
           (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
  "cp0.b %0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,etc,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "tstqi_APSV_16"
  [(set (reg:CC CC_REG)
        (compare
           (match_operand:QI 0 "pic30_near_mode2_APSV_operand" "U,r,R<>")
           (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
  "cp0.b %0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,etc,use")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "tstqi_16"
  [(set (reg:CC CC_REG)
        (compare
          (match_operand:QI 0 "pic30_near_mode2_APSV_operand" "U,r,R<>")
          (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_near_mode2_operand(operands[0],GET_MODE(operands[0])))
    emit(gen_tstqi_DATA_16(operands[0]));
  else
    emit(gen_tstqi_APSV_16(operands[0]));
  DONE;
}")


(define_insn "tsthi_DATA_16"
  [(set (reg:CC CC_REG)
        (compare
          (match_operand:HI 0 "pic30_near_mode2_operand" "U,r,R<>")
          (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
  "cp0.w %0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,etc,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "tsthi_APSV_16"
  [(set (reg:CC CC_REG)
        (compare
          (match_operand:HI 0 "pic30_near_mode2_APSV_operand" "U,r,R<>")
          (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
  "cp0.w %0"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,etc,use")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "tsthi_16"
  [(set (reg:CC CC_REG)
        (compare
          (match_operand:HI 0 "pic30_near_mode2_operand" "U,r,R<>")
          (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
"
{
  if (pic30_near_mode2_operand(operands[0],GET_MODE(operands[0])))
    emit(gen_tsthi_DATA_16(operands[0]));
  else
    emit(gen_tsthi_APSV_16(operands[0]));
  DONE;
}")

(define_insn "tstsi_16"
  [(set (reg:CC CC_REG)
        (compare
          (match_operand:SI 0 "pic30_register_operand" "r")
          (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
  "sub.w %0,#0,[w15]\;subb.w %d0,#0,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "tstdi_16"
  [(set (reg:CC CC_REG)
        (compare
          (match_operand:DI 0 "pic30_register_operand" "r")
          (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
  "sub.w %0,#0,[w15]\;subb.w %d0,#0,[w15]\;subb.w %t0,#0,[w15]\;subb.w %q0,#0,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

; With dsPIC30 floats, testing the most significant word does not suffice,
; since -0.0 == 0.0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Block moves.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Argument 0 is the destination
;; Argument 1 is the source
;; Argument 2 is the length
;; Argument 3 is the alignment
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "movstrhi_16"
  [(parallel [(set (match_operand:BLK 0 "pic30_memory_operand" "")
		   (match_operand:BLK 1 "pic30_memory_operand" ""))
	      (use (match_operand:HI 2 "const_int_operand" ""))
	      (use (match_operand:HI 3 "const_int_operand" ""))
	      (clobber (match_dup 4))
	      (clobber (match_dup 5))
   	      (clobber (reg:HI RCOUNT))
  ])]
  "(!pic30_isa32_target())"
  "{
     rtx addr0;
     rtx addr1;
     int n;
     
     if (GET_CODE (operands[2]) != CONST_INT) FAIL;
     n = INTVAL(operands[2]);
     if (n < 1) FAIL;
     switch (INTVAL(operands[3]))
     {
     case 1:
       if (n > 16383) FAIL;
       break;
     default:
       if ((n > (16383*2)) || (n & 1)) FAIL;
       break;
     }
     
     addr0 = copy_to_mode_reg(Pmode, XEXP (operands[0], 0));
     addr1 = copy_to_mode_reg(Pmode, XEXP (operands[1], 0));

     operands[4] = addr0;
     operands[5] = addr1;
     operands[0] = change_address(operands[0], VOIDmode, addr0);
     operands[1] = change_address(operands[1], VOIDmode, addr1);
   }"
)

;
;  This pattern should restore the src/ dest ptrs before finishing
;
(define_expand "movmemhi_16"
  [(set (match_operand:BLK 0 "pic30_memory_operand"  "=R,m,R,R,m,R,m")
        (match_operand:BLK 1 "pic30_memory_operand"   "R,R,m,R,R,m,m"))
   (use (match_operand:HI 2 "immediate_operand"       "J,J,J,i,i,i,i"))
   (use (match_operand:HI 3 "const_int_operand" ""))
  ]
  "((pic30_errata_mask & ecc_errata) == 0)"
  "{
     if ((pic30_errata_mask & repeat_gie_errata) ||
         (pic30_errata_mask & repeat_nstdis_errata)) {
       FAIL;
     } else {
       rtx dst = operands[0];
       rtx src = operands[1];
       if (GET_MODE(XEXP(dst,0)) == P32UMMmode) {
         if (can_create_pseudo_p()) {
           dst = gen_reg_rtx(machine_Pmode);
           emit(
             gen_p32umm_writemem_16(dst, operands[0])
           );
           dst = gen_rtx_MEM(GET_MODE(operands[0]),dst);
         } else FAIL;
       }
       if (GET_MODE(XEXP(src,0)) == P32UMMmode) {
         if (can_create_pseudo_p()) {
           src = gen_reg_rtx(machine_Pmode);
           emit(
             gen_p32umm_readmem_16(src, operands[1])
           );
           src = gen_rtx_MEM(GET_MODE(operands[1]),src);
         } else FAIL;
       }
       emit_insn(
         gen_movmemhi_helper_16(dst,src,operands[2],operands[3])
       );
       DONE;
     }
  }
  "
)
  
(define_insn "movmemhi_helper_16"
  [(set (match_operand:BLK 0 "pic30_memory_operand"  "=R,m,R,R,m,R,m")
        (match_operand:BLK 1 "pic30_memory_operand"   "R,R,m,R,R,m,m"))
   (use (match_operand:HI 2 "immediate_operand"       "J,J,J,i,i,i,i"))
   (use (match_operand:HI 3 "const_int_operand" ""))
   (clobber (reg:HI RCOUNT))
   (clobber (match_scratch:HI 4                      "=X,&r,&r,&r,&r,&r,&r"))
   (clobber (match_scratch:HI 5                      "=X,X,X,X,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(((pic30_errata_mask & ecc_errata) == 0) && (!pic30_isa32_target()))"
  "*
   { /* my calculation says maximum string size is ~120 
      * Now add for repeat errata */
     static char buffer[260];
     char *c = buffer;
     const char *op0 = \"[%r0++]\";
     const char *op1 = \"[%r1++]\";
     const char *repeat_errata_push = pic30_repeat_errata_push_init();
     const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
     const char *restore_with_sub_0=0;
     const char *restore_with_sub_1=0;
     const char *restore_w14=0;
     const char *sub_value = 0;  /* != 0 => use register */
     int repeat_repeat;
     int repeat_count;

     repeat_count = INTVAL(operands[2]);
     switch (which_alternative) {
     default: break;
     case 0:  /* both registers */
              /* literal <= 10 bits */
              restore_with_sub_0 = \"%r0\";
              restore_with_sub_1 = \"%r1\";
              break;
     case 1:  /* op0 is memory, take its address */
              /* literal <= 10 bits */
              if (pic30_T_constraint(operands[0],VOIDmode) ||
                  pic30_U_constraint(operands[0],VOIDmode)) {
                c += sprintf(c,\"mov #%%0,%%4\;\");
                op0 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[0]) ||
                         pic30_Q_constraint(operands[0])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[0],0),0);
                X = XEXP(XEXP(operands[0],0),1);
                if (REG_P(X))
                  c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                else {
                  if (satisfies_constraint_P(X)) {
                    c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                  } else if (satisfies_constraint_N(X)) {
                    c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                   REGNO(Wn),-1*INTVAL(X));
                  } else {
                    c += sprintf(c,\"mov #%ld,%%4\;\",INTVAL(X));
                    c += sprintf(c,\"add w%d,%%4,%%4\;\", REGNO(Wn));
                  }
                }
                op0 = \"[%4++]\";
              } else if ((GET_CODE(operands[0]) == MEM) &&
                         (GET_CODE(XEXP(operands[0],0)) == SYMBOL_REF)) {
                /* address of a symbol... might be in a wierd space (like prog)
                 * this is okay... iff the client code is asserting the PSVPAG
                 * themselves... assume they are because it was asked for
                 */
                char *accessor = NULL;
                rtx inner = XEXP(operands[0],0);
                if (pic30_has_space_operand_p(inner,PIC30_PROG_FLAG)) {
                  accessor = \"handle\";
                } else if (pic30_has_space_operand_p(inner,PIC30_EDS_FLAG)) {
                  accessor = \"psvoffset\";
                }
                if (accessor) {
                  c += sprintf(c,\"mov #%s(%%0),%%4\;\",accessor);
                  op0 = \"[%4++]\";
                } else gcc_assert(0);
              } else {
                gcc_assert(0);
              } 
              restore_with_sub_1 = \"%r1\";
              break;
     case 2:  /* op1 is memory, take its address */
              /* literal <= 10 bits */
              if (pic30_T_constraint(operands[1],VOIDmode) ||
                  pic30_U_constraint(operands[1],VOIDmode)) {
                c += sprintf(c,\"mov #%%1,%%4\;\");
                op1 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[1]) ||
                         pic30_Q_constraint(operands[1])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[1],0),0);
                X = XEXP(XEXP(operands[1],0),1);
                if (REG_P(X))
                  c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                else {
                  if (satisfies_constraint_P(X)) {
                    c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                  } else if (satisfies_constraint_N(X)) {
                    c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                   REGNO(Wn),-1*INTVAL(X));
                  } else {
                    c += sprintf(c,\"mov #%ld,%%4\;\",INTVAL(X));
                    c += sprintf(c,\"add w%d,%%4,%%4\;\", REGNO(Wn));
                  }
                }
                op1 = \"[%4++]\";
              } else if ((GET_CODE(operands[1]) == MEM) &&
                         (GET_CODE(XEXP(operands[1],0)) == SYMBOL_REF)) {
                /* address of a symbol... might be in a wierd space (like prog)
                 * this is okay... iff the client code is asserting the PSVPAG
                 * themselves... assume they are because it was asked for
                 */
                char *accessor = NULL;
                rtx inner = XEXP(operands[1],0);
                if (pic30_has_space_operand_p(inner,PIC30_PROG_FLAG)) {
                  accessor = \"handle\";
                } else if (pic30_has_space_operand_p(inner,PIC30_EDS_FLAG)) {
                  accessor = \"psvoffset\";
                }
                if (accessor) {
                  c += sprintf(c,\"mov #%s(%%1),%%4\;\",accessor);
                  op1 = \"[%4++]\";
                } else gcc_assert(0);
              } else {
                gcc_assert(0);
              } 
              restore_with_sub_0 = \"%r0\";
              break;
     case 6:  /* op0 and op1 are memory, take their addresses */
              if (pic30_T_constraint(operands[0],VOIDmode) || 
                  pic30_U_constraint(operands[0],VOIDmode)) {
                c += sprintf(c,\"mov #%%0,%%4\;\");
                op0 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[0]) ||
                         pic30_Q_constraint(operands[0])) {
                /* [Wn + X] */
                rtx Wn, X;
  
                Wn = XEXP(XEXP(operands[0],0),0);  
                X = XEXP(XEXP(operands[0],0),1);
                if (REG_P(X)) 
                  c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                else {
                  if (satisfies_constraint_P(X)) {
                    c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                  } else if (satisfies_constraint_N(X)) {
                    c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                   REGNO(Wn),-1*INTVAL(X));
                  } else {
                    c += sprintf(c,\"mov #%ld,%%4\;\",INTVAL(X));
                    c += sprintf(c,\"add w%d,%%4,%%4\;\", REGNO(Wn));
                  }
                }
                op0 = \"[%4++]\";
              } else if ((GET_CODE(operands[0]) == MEM) &&
                         (GET_CODE(XEXP(operands[0],0)) == SYMBOL_REF)) {
                /* address of a symbol... might be in a wierd space (like prog)
                 * this is okay... iff the client code is asserting the PSVPAG
                 * themselves... assume they are because it was asked for
                 */
                char *accessor = NULL;
                rtx inner = XEXP(operands[0],0);
                if (pic30_has_space_operand_p(inner,PIC30_PROG_FLAG)) {
                  accessor = \"handle\";
                } else if (pic30_has_space_operand_p(inner,PIC30_EDS_FLAG)) {
                  accessor = \"psvoffset\";
                }
                if (accessor) {
                  c += sprintf(c,\"mov #%s(%%0),%%4\;\",accessor);
                  op0 = \"[%4++]\";
                } else gcc_assert(0);
              } else {
                gcc_assert(0);
              }
              if (pic30_T_constraint(operands[1],VOIDmode) ||
                  pic30_U_constraint(operands[1],VOIDmode)) {
                c += sprintf(c,\"mov #%%1,%%5\;\");
                op1 = \"[%5++]\";
              }  else if (pic30_S_constraint(operands[1]) ||
                         pic30_Q_constraint(operands[1])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[1],0),0);
                X = XEXP(XEXP(operands[1],0),1);
                if (REG_P(X))
                  c += sprintf(c,\"add w%d,w%d,%%5\;\", REGNO(Wn), REGNO(X));
                else {
                  if (satisfies_constraint_P(X)) {
                    c += sprintf(c,\"add w%d,#%ld,%%5\;\",REGNO(Wn),INTVAL(X));
                  } else if (satisfies_constraint_N(X)) {
                    c += sprintf(c,\"sub w%d,#%ld,%%5\;\",
                                   REGNO(Wn),-1*INTVAL(X));
                  } else {
                    c += sprintf(c,\"mov #%ld,%%5\;\",INTVAL(X));
                    c += sprintf(c,\"add w%d,%%5,%%5\;\", REGNO(Wn));
                  }
                }
                op1 = \"[%5++]\";
              } else if ((GET_CODE(operands[1]) == MEM) &&
                         (GET_CODE(XEXP(operands[1],0)) == SYMBOL_REF)) {
                /* address of a symbol... might be in a wierd space (like prog)
                 * this is okay... iff the client code is asserting the PSVPAG
                 * themselves... assume they are because it was asked for
                 */
                char *accessor = NULL;
                rtx inner = XEXP(operands[1],0);
                if (pic30_has_space_operand_p(inner,PIC30_PROG_FLAG)) {
                  accessor = \"handle\";
                } else if (pic30_has_space_operand_p(inner,PIC30_EDS_FLAG)) {
                  accessor = \"psvoffset\";
                }
                if (accessor) {
                  c += sprintf(c,\"mov #%s(%%1),%%5\;\",accessor);
                  op1 = \"[%5++]\";
                } else gcc_assert(0);
              } else {
                gcc_assert(0);
              }
              break;
     case 3:  /* op0 and op1 are registers */
              /* literal > 10 bits, save repeat count in reg */
              restore_with_sub_0 = \"%r0\";
              restore_with_sub_1 = \"%r1\";
              c += sprintf(c,\"mov #%%2,%%4\;\");
              sub_value =\"%4\";
              break;
     case 4:  /* op0 is memory, take its address */
              /* literal > 10 bits, save repeat count in reg */
              if (pic30_T_constraint(operands[0],VOIDmode) ||
                  pic30_U_constraint(operands[0],VOIDmode)) {
                c += sprintf(c,\"mov #%%0,%%4\;\");
                op0 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[0]) ||
                         pic30_Q_constraint(operands[0])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[0],0),0);
                X = XEXP(XEXP(operands[0],0),1);
                if (REG_P(X))
                  c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                else {
                  if (satisfies_constraint_P(X)) {
                    c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                  } else if (satisfies_constraint_N(X)) {
                    c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                   REGNO(Wn),-1*INTVAL(X));
                  } else {
                    c += sprintf(c,\"mov #%ld,%%4\;\",INTVAL(X));
                    c += sprintf(c,\"add w%d,%%4,%%4\;\", REGNO(Wn));
                  }
                }
                op0 = \"[%4++]\";
              } else if ((GET_CODE(operands[0]) == MEM) &&
                         (GET_CODE(XEXP(operands[0],0)) == SYMBOL_REF)) {
                /* address of a symbol... might be in a wierd space (like prog)
                 * this is okay... iff the client code is asserting the PSVPAG
                 * themselves... assume they are because it was asked for
                 */
                char *accessor = NULL;
                rtx inner = XEXP(operands[0],0);
                if (pic30_has_space_operand_p(inner,PIC30_PROG_FLAG)) {
                  accessor = \"handle\";
                } else if (pic30_has_space_operand_p(inner,PIC30_EDS_FLAG)) {
                  accessor = \"psvoffset\";
                }
                if (accessor) {
                  c += sprintf(c,\"mov #%s(%%0),%%4\;\",accessor);
                  op0 = \"[%4++]\";
                } else gcc_assert(0);
              } else {
                gcc_assert(0);
              }
              c += sprintf(c,\"mov #%%2,%%5\;\");
              sub_value = \"%5\";
              restore_with_sub_1 = \"%r1\";
              break;
     case 5:  /* op1 is memory, take its address */
              /* literal > 10 bits, save repeat count in reg */
              if (pic30_T_constraint(operands[1],VOIDmode) ||
                  pic30_U_constraint(operands[1],VOIDmode)) {
                c += sprintf(c,\"mov #%%1,%%4\;\");
                op1 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[1]) ||
                         pic30_Q_constraint(operands[1])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[1],0),0);
                X = XEXP(XEXP(operands[1],0),1);
                if (REG_P(X))
                  c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                else {
                  if (satisfies_constraint_P(X)) {
                    c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                  } else if (satisfies_constraint_N(X)) {
                    c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                   REGNO(Wn),-1*INTVAL(X));
                  } else {
                    c += sprintf(c,\"mov #%ld,%%4\;\",INTVAL(X));
                    c += sprintf(c,\"add w%d,%%4,%%4\;\", REGNO(Wn));
                  }
                }
                op1 = \"[%4++]\";
              } else if ((GET_CODE(operands[1]) == MEM) &&
                         (GET_CODE(XEXP(operands[1],0)) == SYMBOL_REF)) {
                /* address of a symbol... might be in a wierd space (like prog)
                 * this is okay... iff the client code is asserting the PSVPAG
                 * themselves... assume they are because it was asked for
                 */
                char *accessor = NULL;
                rtx inner = XEXP(operands[1],0);
                if (pic30_has_space_operand_p(inner,PIC30_PROG_FLAG)) {
                  accessor = \"handle\";
                } else if (pic30_has_space_operand_p(inner,PIC30_EDS_FLAG)) {
                  accessor = \"psvoffset\";
                }
                if (accessor) {
                  c += sprintf(c,\"mov #%s(%%1),%%4\;\",accessor);
                  op1 = \"[%4++]\";
                } else gcc_assert(0);
              } else {
                gcc_assert(0);
              }
              restore_with_sub_0 = \"%r0\";
              c += sprintf(c,\"mov #%%2,%%5\;\");
              sub_value = \"%5\";
              break;
     }
     
     switch (INTVAL(operands[3]))
     {
       case 1:
         /* 
         ** Byte operation
         */
         repeat_repeat =  repeat_count - 16383;
         if (repeat_repeat < 0) repeat_repeat = 0;
	 if (repeat_repeat) {
           c += sprintf(c,\"%s\;repeat #16383-1\;mov.b %s,%s\;\",
                          repeat_errata_push,op1, op0);
           c += sprintf(c,\"repeat #%d-1\;mov.b %s,%s\;%s\", 
                          repeat_count,op1, op0, repeat_errata_pop);
         } else c += sprintf(c,\"%s\;repeat #%d-1\;mov.b %s,%s\;%s\", 
                             repeat_errata_push, repeat_count, op1, 
                             op0,repeat_errata_pop);
         break;
     default: {
         int repeat_remainder;
	 /* 
	 ** Word operation
	 */
         /* repeat count is expressed in bytes */
         repeat_remainder = (repeat_count & 1);
         repeat_count = repeat_count / 2;
         repeat_repeat =  repeat_count - 16383;
         if (repeat_repeat < 0) repeat_repeat = 0;
	 if (repeat_repeat) {
           c += sprintf(c,\"%s\;repeat #16383-1\;mov %s,%s\;\", 
                          repeat_errata_push, op1, op0);
           c += sprintf(c,\"repeat #%d-1\;mov %s,%s\;%s\", 
                        repeat_count, op1, op0, repeat_errata_pop);
         } else c += sprintf(c,\"%s\;repeat #%d-1\;mov %s,%s\;%s\", 
                             repeat_errata_push, repeat_count, op1, 
                             op0, repeat_errata_pop);
         if (repeat_remainder) {
           if (pic30_psrd_psrd_errata(operands[1],NULL)) {
             c += sprintf(c,\"\;nop\");
           }
           c += sprintf(c,\"\;mov.b %s,%s\", op1,op0);
         } break;
       }
     }
     if (restore_with_sub_0) {
       if (sub_value) {
         c += sprintf(c,\"\;sub %s, %s, %s\", 
                      restore_with_sub_0, sub_value, restore_with_sub_0);
       } else c += sprintf(c,\"\;sub #%%2, %s\", restore_with_sub_0);
     }
     if (restore_with_sub_1) {
       if (sub_value) {
         c += sprintf(c,\"\;sub %s, %s, %s\", 
                      restore_with_sub_1, sub_value, restore_with_sub_1);
       } else c += sprintf(c,\"\;sub #%%2, %s\", restore_with_sub_1);
     }
     if (restore_w14) {
       c += sprintf(c, \"\;mov %s,w14\", restore_w14);
     }
     return buffer;
   } "
  [
    (set_attr "type" "use")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Block clear.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; opnd 0 is the destination
;; opnd 2 is the value
;; opnd 1 is the length
;; opnd 3 is the alignment
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define_expand "setmemhi_16"
  [
   (set (match_operand:BLK 0 "pic30_memory_operand"  "=R,m,R,m,R,m,R,m,R,m,R,m")
        (match_operand     2 "pic30_reg_or_imm_operand" 
                                                     "O,O,O,O,i,i,i,i,r,r,r,r"))
   (use (match_operand:HI 1 "immediate_operand" "J,J,i,i,J,J,i,i,J,J,i,i"))
   (use (match_operand:HI 3 "const_int_operand" ""))
  ]
  ""
  "{
     {
       rtx dst = operands[0];
       if (GET_MODE(XEXP(dst,0)) == P32UMMmode) {
         if (can_create_pseudo_p()) {
           dst = gen_reg_rtx(machine_Pmode); 
           emit(
             gen_p32umm_writemem_16(dst, operands[0])
           );
           dst = gen_rtx_MEM(GET_MODE(operands[0]),dst);
         } else FAIL;
       }
       emit_insn(
         gen_setmemhi_helper_16(dst,operands[1],operands[2],operands[3])
       );
       DONE;
     }
  }
  "
)

(define_insn "setmemhi_helper_16"
  [
   (set (match_operand:BLK 0 "pic30_memory_operand"  "=R,m,R,m,R,m,R,m,R,m,R,m")
        (match_operand     2 "pic30_reg_or_imm_operand" 
                                                     "O,O,O,O,i,i,i,i,r,r,r,r"))
   (use (match_operand:HI 1 "immediate_operand" "J,J,i,i,J,J,i,i,J,J,i,i"))
   (use (match_operand:HI 3 "const_int_operand" ""))
   (clobber (reg:HI RCOUNT))
   (clobber (match_scratch:HI 4  "=X,&r,&r,&r,X,&r,&r,&r,X,&r,&r,&r"))
   (clobber (match_scratch:HI 5  "=X,X,X,&r,X,X,X,&r,X,X,X,&r"))
   (clobber (match_scratch:HI 6  "=X,X,X,X,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   { /* my calculation says maximum string size is ~120 
      * Now add for repeat errata */
     static char buffer[260];
     char *c = buffer;
     const char *op0 = \"[%r0++]\";
     const char *op1 = \"\";
     const char *repeat_errata_push = pic30_repeat_errata_push_init();
     const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
     const char *restore_with_sub_0=0;
     const char *restore_w14=0;
     const char *sub_value = 0;  /* != 0 => use register */
     unsigned char byte;
     int repeat_repeat;
     int repeat_count;
     const char *set_instr = \"mov\";
     int word_size = INTVAL(operands[3]);

     repeat_count = INTVAL(operands[1]);
     if (const_int_operand(operands[2],VOIDmode)) {
       if (INTVAL(operands[2]) == 0) {
         set_instr = \"clr\";
       } else {
         /* the middle four are the same as the bottom four, just that we don't
            need a clobber register for the value */
         gcc_assert(which_alternative > 3);
         which_alternative -= 4;
         if (INTVAL(operands[3]) != 1) {
           /* repeat bytes */
           /* first convert char to unsigned char */
           /* since we are doing bit operations */
           byte = INTVAL(operands[2]) & 0xFF;
           c += sprintf(c,\"mov #%d,%%6\;\", (byte << 8) + byte);
         } else {
           c += sprintf(c,\"mov #%ld,%%6\;\", INTVAL(operands[2]));
         }
         op1=\"%6,\";
       }
     } else {
       /* register already */
       /* the top four are the same as the bottom four, just that we don't
          need a clobber register for the value */
       gcc_assert(which_alternative > 7);
       which_alternative -= 8;
       op1 = \"%2,\";
       if (repeat_count < 4) {
         word_size = 1;
       } else {
         c += sprintf(c,\"sl %%2,#8,%%6\;ior.b %%2,%%6,%%6\;\");
         op1=\"%6,\";
     }
     }

     switch (which_alternative) {
     default: break;
     case 0:  /* op0 is register */
              /* literal <= 10 bits */
              restore_with_sub_0 = \"%r0\";
              break;
     case 1:  /* op0 is memory, take its address */
              /* literal <= 10 bits */
              if (pic30_T_constraint(operands[0],VOIDmode) ||
                  pic30_U_constraint(operands[0],VOIDmode)) {
                c += sprintf(c,\"mov #%%0,%%4\;\");
                op0 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[0]) ||
                         pic30_Q_constraint(operands[0])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[0],0),0);
                X = XEXP(XEXP(operands[0],0),1);
                {
                  if (REG_P(X))
                    c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                  else {
                    if (satisfies_constraint_P(X)) {
                      c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                    } else if (satisfies_constraint_N(X)) {
                      c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                     REGNO(Wn),-1*INTVAL(X));
                    } else {
                      c += sprintf(c,\"mov w%d,%%4\;\", REGNO(Wn));
                      if (INTVAL(X) < 0)
                        c += sprintf(c,\"sub #%ld,%%4\;\",-1*INTVAL(X));
                      else c += sprintf(c,\"add #%ld,%%4\;\",INTVAL(X));
                    }
                  }
                  op0 = \"[%4++]\";
                }
              } else if ((GET_CODE(operands[0]) == MEM) &&
                         (GET_CODE(XEXP(operands[0],0)) == SYMBOL_REF)) {
                /* address of a symbol... might be in a wierd space (like prog)
                 * this is okay... iff the client code is asserting the PSVPAG
                 * themselves... assume they are because it was asked for
                 */
                char *accessor = NULL;
                rtx inner = XEXP(operands[0],0);
                if (pic30_has_space_operand_p(inner,PIC30_PROG_FLAG)) {
                  accessor = \"handle\";
                } else if (pic30_has_space_operand_p(inner,PIC30_EDS_FLAG)) {
                  accessor = \"psvoffset\";
                }
                if (accessor) {
                  c += sprintf(c,\"mov #%s(%%0),%%4\",accessor);
                  op0 = \"[%4++]\";
                } else gcc_assert(0);
              } else {
                gcc_assert(0);
              } 
              break;
     case 2:  /* op0 is a register */
              /* literal > 10 bits, save repeat count in reg */
              restore_with_sub_0 = \"%r0\";
              c += sprintf(c,\"mov #%%1,%%4\;\");
              sub_value =\"%4\";
              break;
     case 3:  /* op0 is memory, take its address */
              /* literal > 10 bits, save repeat count in reg */
              if (pic30_T_constraint(operands[0],VOIDmode) ||
                  pic30_U_constraint(operands[0],VOIDmode)) {
                c += sprintf(c,\"mov #%%0,%%4\;\");
                op0 = \"[%4++]\";
              } else if (pic30_S_constraint(operands[0]) ||
                         pic30_Q_constraint(operands[0])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[0],0),0);
                X = XEXP(XEXP(operands[0],0),1);
                {
                  if (REG_P(X))
                    c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                  else {
                    if (satisfies_constraint_P(X)) {
                      c += sprintf(c,\"add w%d,#%ld,%%4\;\",REGNO(Wn),INTVAL(X));
                    } else if (satisfies_constraint_N(X)) {
                      c += sprintf(c,\"sub w%d,#%ld,%%4\;\",
                                     REGNO(Wn),-1*INTVAL(X));
                    } else {
                      c += sprintf(c,\"mov w%d,%%4\;\", REGNO(Wn));
                      if (INTVAL(X) < 0)
                        c += sprintf(c,\"sub #%ld,%%4\;\",-1*INTVAL(X));
                      else c += sprintf(c,\"add #%ld,%%4\;\",INTVAL(X));
                    }
                  }
                  op0 = \"[%4++]\";
                }
              } else if ((GET_CODE(operands[0]) == MEM) &&
                         (GET_CODE(XEXP(operands[0],0)) == SYMBOL_REF)) {
                /* address of a symbol... might be in a wierd space (like prog)
                 * this is okay... iff the client code is asserting the PSVPAG
                 * themselves... assume they are because it was asked for
                 */
                char *accessor = NULL;
                rtx inner = XEXP(operands[0],0);
                if (pic30_has_space_operand_p(inner,PIC30_PROG_FLAG)) {
                  accessor = \"handle\";
                } else if (pic30_has_space_operand_p(inner,PIC30_EDS_FLAG)) {
                  accessor = \"psvoffset\";
                }
                if (accessor) {
                  c += sprintf(c,\"mov #%s(%%0),%%4\",accessor);
                  op0 = \"[%4++]\";
                } else gcc_assert(0);
              } else {
                gcc_assert(0);
              }
              break;
     }
     
     switch (word_size) 
     {
       case 1:
         /* 
         ** Byte operation
         */
         repeat_repeat =  repeat_count - 16383;
         if (repeat_repeat < 0) repeat_repeat = 0;
	 if (repeat_repeat) {
           c += sprintf(c, \"%s\;repeat #16383-1\;%s.b %s%s\;\", 
                           repeat_errata_push,set_instr, op1, op0);
           c += sprintf(c,\"repeat #%d-1\;%s.b %s%s\;%s\", 
                           repeat_count, set_instr, op1, op0,repeat_errata_pop);
         } else c += sprintf(c,\"%s\;repeat #%d-1\;%s.b %s%s\;%s\", 
                             repeat_errata_push,repeat_count, set_instr, op1,
                             op0, repeat_errata_pop);
         break;
       default: {
         int repeat_remainder;
	 /* 
	 ** Word operation
	 */
         /* repeat count is expressed in bytes */
         repeat_remainder = (repeat_count & 1);
         repeat_count = repeat_count / 2;
         repeat_repeat =  repeat_count - 16383;
         if (repeat_repeat < 0) repeat_repeat = 0;
	 if (repeat_repeat) {
           c += sprintf(c,\"%s\;repeat #16383-1\;%s %s%s\;\", 
                           repeat_errata_push,set_instr, op1, op0);
           c += sprintf(c,\"repeat #%d-1\;%s %s%s\;%s\", 
                        repeat_count, set_instr, op1, op0,repeat_errata_pop);
         } else c += sprintf(c,\"%s\;repeat #%d-1\;%s %s%s\;%s\", 
                             repeat_errata_push, repeat_count, set_instr, op1, 
                             op0, repeat_errata_pop);
         if (repeat_remainder) 
           c += sprintf(c,\"\;%s.b %s%s\", set_instr, op1, op0);
         break;
       }
     }
     if (restore_with_sub_0) {
       if (sub_value) {
         c += sprintf(c,\"\;sub %s, %s, %s\", 
                      restore_with_sub_0, sub_value, restore_with_sub_0);
       } else c += sprintf(c,\"\;sub #%%1, %s\", restore_with_sub_0);
     }
     if (restore_w14) {
       c += sprintf(c, \"\;mov %s,w14\", restore_w14);
     }
     return buffer;
   } "
  [
    (set_attr "type" "use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "setmemhip32umm_helper_16"
  [
   (set (match_operand:BLK 0 "pic30_umm_memory_operand" "=R,m,R,m,R,m,R,m,R,m,R,m")
        (match_operand     2 "pic30_reg_or_imm_operand" 
                                                     "O,O,O,O,i,i,i,i,r,r,r,r"))
   (use (match_operand:HI 1 "immediate_operand" "J,J,i,i,J,J,i,i,J,J,i,i"))
   (use (match_operand:HI 3 "const_int_operand" ""))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:HI DSWPAG))
   (clobber (match_scratch:HI 4  "=&r,&r,&r,&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (match_scratch:HI 5  "=X,X,X,&r,X,X,X,&r,X,X,X,&r"))
   (clobber (match_scratch:HI 6  "=X,X,X,X,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   { /* my calculation says maximum string size is ~120 
      * Now add for repeat errata */
     static char buffer[260];
     char *c = buffer;
     const char *op0 = \"[%4++]\";
     const char *op1 = \"\";
     const char *repeat_errata_push = pic30_repeat_errata_push_init();
     const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
     unsigned char byte;
     int repeat_repeat;
     int repeat_count;
     const char *set_instr = \"mov\";
     int word_size = INTVAL(operands[3]);
     int regno;

     repeat_count = INTVAL(operands[1]);
     if (const_int_operand(operands[2],VOIDmode)) {
       if (INTVAL(operands[2]) == 0) {
         set_instr = \"clr\";
       } else {
         /* the middle four are the same as the bottom four, just that we don't
            need a clobber register for the value */
         gcc_assert(which_alternative > 3);
         which_alternative -= 4;
         if (INTVAL(operands[3]) != 1) {
           /* repeat bytes */
           /* first convert char to unsigned char */
           /* since we are doing bit operations */
           byte = INTVAL(operands[2]) & 0xFF;
           c += sprintf(c,\"mov #%d,%%6\;\", (byte << 8) + byte);
         } else {
           c += sprintf(c,\"mov #%ld,%%6\;\", INTVAL(operands[2]));
         }
         op1=\"%6,\";
       }
     } else {
       /* register already */
       /* the top four are the same as the bottom four, just that we don't
          need a clobber register for the value */
       gcc_assert(which_alternative > 7);
       which_alternative -= 8;
       op1 = \"%2,\";
       if (repeat_count < 4) {
         word_size = 1;
       } else {
         c += sprintf(c,\"sl %%2,#8,%%6\;ior.b %%2,%%6,%%6\;\");
         op1=\"%6,\";
       }
     }

     switch (which_alternative) {
     default: break;
     case 2:
     case 0:  /* op0 is register */
              /* literal <= 10 bits */
              regno = REGNO(XEXP(operands[0],0));
              if (pic30_eds_target()) {
                c += sprintf(c,\"mov w%d,DSWPAG\;\",regno+1);
              }
              c += sprintf(c,\"rrnc %%r0,%%4\;\");
              break;
     case 3:
     case 1:  /* op0 is memory, take its address */
              /* literal <= 10 bits */
              if (pic30_T_constraint(operands[0],VOIDmode) ||
                  pic30_U_constraint(operands[0],VOIDmode)) {
                if (pic30_eds_target()) {
                  c += sprintf(c,\"mov #unifed_hi(%%0),%%4\;\");
                  c += sprintf(c,\"mov %%4,DSWPAG\;\");
                }
                c += sprintf(c,\"mov #addr_lo(%%0),%%4\;\");
              } else if (pic30_S_constraint(operands[0]) ||
                         pic30_Q_constraint(operands[0])) {
                /* [Wn + X] */
                rtx Wn, X;

                Wn = XEXP(XEXP(operands[0],0),0);
                X = XEXP(XEXP(operands[0],0),1);
                if (pic30_eds_target()) {
                  c += sprintf(c,\"mov w%d,DSWPAG\;\",REGNO(Wn)+1);
                }
                {
                  if (REG_P(X)) {
                    c += sprintf(c,\"add w%d,w%d,%%4\;\", REGNO(Wn), REGNO(X));
                    c += sprintf(c,\"rrnc %%4,%%4\;\");
                  } else {
                    c += sprintf(c,\"rrnc %%r0,%%4\;\");
                    if (satisfies_constraint_P(X)) {
                      c += sprintf(c,\"add %%4,#%ld,%%4\;\",INTVAL(X));
                    } else if (satisfies_constraint_N(X)) {
                      c += sprintf(c,\"sub %%4,#%ld,%%4\;\", -1*INTVAL(X));
                    } else {
                      if (INTVAL(X) < 0)
                        c += sprintf(c,\"sub #%ld,%%4\;\",-1*INTVAL(X));
                      else c += sprintf(c,\"add #%ld,%%4\;\",INTVAL(X));
                    }
                  }
                  op0 = \"[%4++]\";
                }
              } else if ((GET_CODE(operands[0]) == MEM) &&
                         (GET_CODE(XEXP(operands[0],0)) == SYMBOL_REF)) {
                /* address of a symbol... might be in a wierd space (like prog)
                 * this is okay... iff the client code is asserting the PSVPAG
                 * themselves... assume they are because it was asked for
                 */
                char *accessor = NULL;
                rtx inner = XEXP(operands[0],0);
                if (pic30_has_space_operand_p(inner,PIC30_PROG_FLAG)) {
                  accessor = \"handle\";
                } else if (pic30_has_space_operand_p(inner,PIC30_EDS_FLAG)) {
                  accessor = \"psvoffset\";
                }
                if (accessor) {
                  c += sprintf(c,\"mov #%s(%%0),%%4\",accessor);
                  op0 = \"[%4++]\";
                } else gcc_assert(0);
              } else {
                gcc_assert(0);
              } 
              break;
     }
     
     switch (word_size) 
     {
       case 1:
         /* 
         ** Byte operation
         */
         repeat_repeat =  repeat_count - 16383;
         if (repeat_repeat < 0) repeat_repeat = 0;
	 if (repeat_repeat) {
           c += sprintf(c, \"%s\;repeat #16383-1\;%s.b %s%s\;\", 
                           repeat_errata_push,set_instr, op1, op0);
           c += sprintf(c,\"repeat #%d-1\;%s.b %s%s\;%s\", 
                           repeat_count, set_instr, op1, op0,repeat_errata_pop);
         } else c += sprintf(c,\"%s\;repeat #%d-1\;%s.b %s%s\;%s\", 
                             repeat_errata_push,repeat_count, set_instr, op1,
                             op0, repeat_errata_pop);
         break;
       default: {
         int repeat_remainder;
	 /* 
	 ** Word operation
	 */
         /* repeat count is expressed in bytes */
         repeat_remainder = (repeat_count & 1);
         repeat_count = repeat_count / 2;
         repeat_repeat =  repeat_count - 16383;
         if (repeat_repeat < 0) repeat_repeat = 0;
	 if (repeat_repeat) {
           c += sprintf(c,\"%s\;repeat #16383-1\;%s %s%s\;\", 
                           repeat_errata_push,set_instr, op1, op0);
           c += sprintf(c,\"repeat #%d-1\;%s %s%s\;%s\", 
                        repeat_count, set_instr, op1, op0,repeat_errata_pop);
         } else c += sprintf(c,\"%s\;repeat #%d-1\;%s %s%s\;%s\", 
                             repeat_errata_push, repeat_count, set_instr, op1, 
                             op0, repeat_errata_pop);
         if (repeat_remainder) 
           c += sprintf(c,\"\;%s.b %s%s\", set_instr, op1, op0);
         break;
       }
     }
     return buffer;
   } "
  [
     (set_attr "type" "use")
  ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; compare instructions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "any_branch_16"
  [(set (pc)
       (if_then_else (match_operator 0 "comparison_operator"
                      [(reg:CC CC_REG) (const_int 0)])
                     (label_ref (match_operand 1 "" ""))
                     (pc)))]
  "(!pic30_isa32_target())"
  "* 
   return pic30_conditional_branch(GET_CODE(operands[0]), operands[1],1,0);
  "
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

(define_expand "cbranch<mode>4_16"
 [(set (reg:CC CC_REG)
       (compare (match_operand:CMPMODES16 1 "pic30_mode1PN_operand" "")
                (match_operand:CMPMODES16 2 "pic30_mode1PN_operand" "")))
  (set (pc)
       (if_then_else (match_operator 0 "comparison_operator"
                      [(reg:CC CC_REG) (const_int 0)])
                     (label_ref (match_operand 3 "" ""))
                     (pc)))]
  "(!pic30_isa32_target())"
  { /* The optimizer will coalesce this if possible, right? */
    enum machine_mode mode2 = GET_MODE(operands[2]);
    if (mode2 == VOIDmode) mode2 = GET_MODE(operands[1]);
    rtx reg_1 = force_reg (GET_MODE(operands[1]), operands[1]);
    rtx reg_2 = operands[2];

    if (TARGET_EDS) {
      /* this change was made here
       * http://fossil.microchip.com/repos.cgi/XC_GCC/info/485c8c9bffc661b6
       * its bad for non-unified cases
       */
      reg_2 = force_reg (mode2, operands[2]);
    }

    emit(
      gen_cmp<mode>_16(reg_1,reg_2)
    );
    emit(
      gen_any_branch_16(operands[0], operands[3])
    );
    DONE;
  }
)

(define_expand "cbranch<mode>4_16"
 [(set (reg:CC CC_REG)
       (compare (match_operand:CMPMODES 1 "pic30_mode1PN_operand" "")
                (match_operand:CMPMODES 2 "pic30_mode1PN_operand" "")))
  (set (pc)
       (if_then_else (match_operator 0 "comparison_operator"
                      [(reg:CC CC_REG) (const_int 0)])
                     (label_ref (match_operand 3 "" ""))
                     (pc)))]
  "(!pic30_isa32_target())"
  { /* The optimizer will coalesce this if possible, right? */
    enum machine_mode mode2 = GET_MODE(operands[2]);
    if (mode2 == VOIDmode) mode2 = GET_MODE(operands[1]);
    rtx reg_1 = force_reg (GET_MODE(operands[1]), operands[1]);
    rtx reg_2 = operands[2];

    if (TARGET_EDS) {
      /* this change was made here 
       * http://fossil.microchip.com/repos.cgi/XC_GCC/info/485c8c9bffc661b6
       * its bad for non-unified cases 
       */
      reg_2 = force_reg (mode2, operands[2]);
    }

    emit(
      gen_cmp<mode>_16(reg_1,reg_2)
    );
    emit(
      gen_any_branch_16(operands[0], operands[3])
    );
    DONE;
  }
) 

;;;;;;;;;;;;;;;;;;
;; quarter integer
;;;;;;;;;;;;;;;;;;

(define_insn "*cmpqi_imm_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:QI 0 "pic30_register_operand" "r")
                 (match_operand:QI 1 "pic30_M_operand"  "M")))
   (clobber (match_dup 0))
  ]
  "(!pic30_isa32_target())"
  "add.b #%J1,%0"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "cmpqi3_sfr0_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:QI 0 "pic30_reg_or_near_operand" "U,r")
                 (match_operand:QI 1 "pic30_register_operand" "a,r")))
  ]
  "(!pic30_isa32_target())"
  "@
   cp.b %0
   sub.b %0,%1,[w15]"
  [
    (set_attr "cc" "set,set")
    (set_attr "type" "etc,etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "cmpqi3_2sfr_16"
  [(set (reg:CC CC_REG)
        (compare 
           (match_operand:QI 0 "pic30_reg_or_near_operand" "?r,U, U, r")
           (match_operand:QI 1 "pic30_reg_or_near_operand" "U, a,?r, r")))
   (clobber (match_scratch:HI 2                          "=&r, X,&r, X"))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %1,%2\;cp.b %0,%2
   cp.b %0
   mov %0,%2\;cp.b %2,%1
   cp.b %0,%1"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ])

(define_expand "cmpqi_16"
 [(set (reg:CC CC_REG)
       (compare (match_operand:QI 0 "pic30_near_mode1PN_operand" "")
                (match_operand:QI 1 "pic30_near_mode1PN_APSV_operand" "")))
  (match_dup 2)]
  "(!pic30_isa32_target())"
  "{
      rtx (*gen)(rtx,rtx);

      if (pic30_near_mode1PN_operand(operands[1],GET_MODE(operands[1]))) {
        gen = gen_cmpqi_normal_DATA_16;
      } else {
        gen = gen_cmpqi_normal_APSV_16;
      }
      if (pic30_near_operand(operands[0],QImode) &&
          pic30_near_operand(operands[1],QImode)) {
  
        operands[2] = gen_reg_rtx(QImode);
        
        emit_insn(gen_movqi_gen_DATA_16(operands[2],operands[1]));
        emit_insn(gen_cmpqi3_sfr0_16(operands[0],operands[2]));
      } else if (pic30_near_operand(operands[1],QImode)) {
        if (pic30_wreg_operand(operands[0],QImode))
          emit_insn(gen_cmpqi3_2sfr_16(operands[0],operands[1]));
        else { 
          rtx pop; 

          operands[2] = gen_reg_rtx(HImode);
          pop = gen_rtx_MEM(QImode, operands[2]);
          emit_insn(gen_movhi_address_16(operands[2],  XEXP(operands[1],0)));
          emit_insn(gen(operands[0],pop));
        }
      }
      else if (pic30_near_operand(operands[0],QImode)) {
        if (pic30_wreg_operand(operands[1],QImode))
          emit_insn(gen_cmpqi3_sfr0_16(operands[0],operands[1]));
        else {
          rtx pop;

          operands[2] = gen_reg_rtx(HImode);
          pop = gen_rtx_MEM(QImode, operands[2]);
          emit_insn(gen_movhi_address_16(operands[2], XEXP(operands[0],0)));
          emit_insn(gen(pop,operands[1]));
        }
      } else {
        emit_insn(gen(operands[0],operands[1]));
      }
      DONE;
   }
  "
)

(define_insn "cmpqi_normal_DATA_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:QI 0 "pic30_mode2_operand"   "r,r,  R<>,r,r")
                 (match_operand:QI 1 "pic30_mode1PN_operand" "r,R<>,r,  P,N")))
  ]
  "(!pic30_isa32_target())"
  "@
   sub.b %0,%1,[w15]
   sub.b %0,%1,[w15]
   subr.b %1,%0,[w15]
   sub.b %0,#%1,[w15]
   add.b %0,#%J1,[w15]"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "cmpqi_normal_APSV_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:QI 0 "pic30_mode2_operand"
                                "r,r,  R<>,r,r")
                 (match_operand:QI 1 "pic30_mode1PN_APSV_operand"
                                "r,R<>,r,  P,N")))
  ]
  "(!pic30_isa32_target())"
  "@
   sub.b %0,%1,[w15]
   sub.b %0,%1,[w15]
   subr.b %1,%0,[w15]
   sub.b %0,#%1,[w15]
   add.b %0,#%J1,[w15]"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;
;; half integer
;;;;;;;;;;;;;;;;;;

(define_insn "cmphi_imm_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:HI 0 "pic30_register_operand" "r")
                 (match_operand:HI 1 "pic30_M_operand"  "M")))
   (clobber (match_dup 0))
  ]
  "(!pic30_isa32_target())"
  "add.w #%J1,%0"
  [
    (set_attr "cc" "set")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "cmphi_sfr0_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:HI 0 "pic30_reg_or_near_operand" "U,r")
                 (match_operand:HI 1 "pic30_register_operand"    "a,r")))
  ]
  "(!pic30_isa32_target())"
  "@
   cp.w  %0
   sub.w %0,%1,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "op_type" "alu")
  ]
)

;        (compare (match_operand:HI 0 "pic30_reg_or_near_operand" "Ur")

(define_insn "cmpzhi_sfr0_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:HI 0 "pic30_mode2_or_near_operand" "R<>,Ur")
                 (const_int 0)))
  ]
  "(!pic30_isa32_target())"
  "cp0.w %0"
  [
    (set_attr "cc" "set")
    (set_attr "type" "use,etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "cmphi_DATA_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:HI 0 "pic30_mode2_operand"   "r,r,  R<>,r,r")
                 (match_operand:HI 1 "pic30_mode1PN_operand" "r,R<>,r,  P,N")))
  ]
  "(!pic30_isa32_target())"
  "@
   sub.w %0,%1,[w15]
   sub.w %0,%1,[w15]
   subr.w %1,%0,[w15]
   sub.w %0,#%1,[w15]
   add.w %0,#%J1,[w15]"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "cmphi_APSV_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:HI 0 "pic30_mode2_operand" 
                                "r,r,  R<>,r,r")
                 (match_operand:HI 1 "pic30_mode1PN_APSV_operand"
                                "r,R<>,r,  P,N")))
  ]
  "(!pic30_isa32_target())"
  "@
   sub.w %0,%1,[w15]
   sub.w %0,%1,[w15]
   subr.w %1,%0,[w15]
   sub.w %0,#%1,[w15]
   add.w %0,#%J1,[w15]"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "cmphi_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:HI 0 "pic30_mode2_operand"
                                "r,r,  R<>,r,r")
                 (match_operand:HI 1 "pic30_mode1PN_APSV_operand"
                                "r,R<>,r,  P,N")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode1PN_operand(operands[1],GET_MODE(operands[1])))
    emit_insn(gen_cmphi_DATA_16(operands[0],operands[1]));
  else
    emit_insn(gen_cmphi_APSV_16(operands[0],operands[1]));
  DONE;
}")

(define_insn "*cmpp16apsv_imm_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:P16APSV 0 "pic30_register_operand" "r")
                 (match_operand:P16APSV 1 "pic30_M_operand"  "M")))
   (clobber (match_dup 0))
  ]
  "(!pic30_isa32_target())"
  "add.w #%J1,%0"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ])

(define_insn "*cmpp16apasv_sfr0_16"
  [(set (reg:CC CC_REG)
        (compare
          (match_operand:P16APSV 0 "pic30_reg_or_near_operand" "U,r")
          (match_operand:P16APSV 1 "pic30_register_operand" "a,r")))
  ]
  "(!pic30_isa32_target())"
  "@
   cp.w %0
   sub.w %0,%1,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ])

(define_insn "cmpp16apsv_DATA_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:P16APSV 0 "pic30_mode2_operand"
                                "r,r,  R<>,r,r")
                 (match_operand:P16APSV 1 "pic30_mode1PN_operand"
                                "r,R<>,r,  P,N")))
  ]
  "(!pic30_isa32_target())"
  "@
   sub.w %0,%1,[w15]
   sub.w %0,%1,[w15]
   subr.w %1,%0,[w15]
   sub.w %0,#%1,[w15]
   add.w %0,#%J1,[w15]"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "cmpp16apsv_APSV_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:P16APSV 0 "pic30_mode2_operand"
                                "r,r,  R<>,r,r")
                 (match_operand:P16APSV 1 "pic30_mode1PN_APSV_operand"
                                "r,R<>,r,  P,N")))
  ]
  "(!pic30_isa32_target())"
  "@
   sub.w %0,%1,[w15]
   sub.w %0,%1,[w15]
   subr.w %1,%0,[w15]
   sub.w %0,#%1,[w15]
   add.w %0,#%J1,[w15]"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "cmpp16apsv_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:P16APSV 0 "pic30_mode1PN_operand"
                                "r,r,  R<>,r,P,r,N")
                 (match_operand:P16APSV 1 "pic30_mode1PN_APSV_operand"
                                "r,R<>,r,  P,r,N,r")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode1PN_operand(operands[1],GET_MODE(operands[1])))
    emit_insn(gen_cmpp16apsv_DATA_16(operands[0],operands[1]));
  else
    emit_insn(gen_cmpp16apsv_APSV_16(operands[0],operands[1]));
  DONE;
}")

;;;;;;;;;;;;;;;;;;
;; single integer
;;;;;;;;;;;;;;;;;;
(define_insn "cmpsi_DATA_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:SI 0 "pic30_mode2mres_operand" "r,r,R,r,>")
                 (match_operand:SI 1 "pic30_mode2mres_operand" "r,R,r,>,r")))
  ]
  "(!pic30_isa32_target())"
  "*
{
  static const char *patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;subb %d0,%D1,[w15]\",
     \"subr %1,%I0,[w15]\;subbr %d1,%D0,[w15]\",
     \"sub %0,%1,[w15]\;subb %d0,%1,[w15]\",
     \"subr %1,%0,[w15]\;subbr %d1,%0,[w15]\"
  };

  static const char *pre_patterns[] = {
    \"add %r1,#4,%r1\;sub %0,%I1,[w15]\;subb %d0,%D1,[w15]\",
    \"add %r0,#4,%r0\;subr %1,%I0,[w15]\;subbr %d1,%D0,[w15]\"
  };

  static const char *psv_psv_patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;nop\;subb %d0,%D1,[w15]\",
     \"subr %1,%I0,[w15]\;nop\;subbr %d1,%D0,[w15]\",
     \"sub %0,%1,[w15]\;nop\;subb %d0,%1,[w15]\",
     \"subr %1,%0,[w15]\;nop\;subbr %d1,%0,[w15]\"
  };

  static const char *psv_psv_pre_patterns[] = {
    \"add %r1,#4,%r1\;sub %0,%I1,[w15]\;nop\;subb %d0,%D1,[w15]\",
    \"add %r0,#4,%r0\;subr %1,%I0,[w15]\;nop\;subbr %d1,%D0,[w15]\"
  };

  if (pic30_psrd_psrd_errata(operands[0],operands[1])) {
    pic30_rtx_nops++;
    if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[1])) {
      return psv_psv_pre_patterns[which_alternative - 3];
    } else return psv_psv_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[1])) {
      return pre_patterns[which_alternative - 3];
    } else return patterns[which_alternative];
  }
}"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc,use,use,use,use")
    (set_attr "op_type" "alu")
  ])


(define_insn "cmpsi_errata_APSV_16"
  [(set 
     (reg:CC CC_REG)
     (compare 
       (match_operand:SI 0 "pic30_mode2mres_operand"      "r,r,R,r,>")
       (match_operand:SI 1 "pic30_mode2mres_APSV_operand" "r,R,r,>,r")))
   (clobber (match_scratch:HI 2                          "=X,&r,&r,&r,&r"))
  ]
  "(!pic30_isa32_target()) && (pic30_errata_mask & psv_errata)"
  "*
{
  static const char *patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;mov %D1,%2\;subb %d0,%2,[w15]\",
     \"subr %1,%I0,[w15]\;mov %D0,%2\;subbr %d1,%2,[w15]\",
     \"sub %0,%1,[w15]\;mov %1,%2\;subb %d0,%2,[w15]\",
     \"subr %1,%0,[w15]\;mov %d1,%2\;subbr %2,%0,[w15]\"
  };
 
  static const char *pre_patterns[] = {
     \"add %r1,#4,%r1\;sub %0,%I1,[w15]\;mov %D1,%2\;subb %d0,%2,[w15]\",
     \"add %r0,#4,%r0\;subr %1,%I0,[w15]\;mov %d1,%2\;subbr %2,%D0,[w15]\"
  };

  static const char *psv_psv_patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;nop\;mov %D1,%2\;subb %d0,%2,[w15]\",
     \"subr %1,%I0,[w15]\;nop\;mov %D0,%2\;subbr %d1,%2,[w15]\",
     \"sub %0,%1,[w15]\;nop\;mov %1,%2\;subb %d0,%2,[w15]\",
     \"subr %1,%0,[w15]\;nop\;mov %d1,%2\;subbr %2,%0,[w15]\"
  };
 
  static const char *psv_psv_pre_patterns[] = {
     \"add %r1,#4,%r1\;sub %0,%I1,[w15]\;nop\;mov %D1,%2\;subb %d0,%2,[w15]\",
     \"add %r0,#4,%r0\;subr %1,%I0,[w15]\;nop\;mov %d1,%2\;subbr %2,%D0,[w15]\"
  };

  if (pic30_psrd_psrd_errata(operands[0],operands[1])) {
    pic30_rtx_nops++;
    if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[1])) {
      return psv_psv_pre_patterns[which_alternative - 3];
    } else return psv_psv_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[1])) {
      return pre_patterns[which_alternative - 3];
    } else return patterns[which_alternative];
  }
}"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc,use,use,use,use")
    (set_attr "op_type" "alu")
  ])

(define_insn "cmpsi_noerrata_APSV_16"
  [(set 
     (reg:CC CC_REG)
       (compare 
          (match_operand:SI 0 "pic30_mode2mres_operand"      "r,r,R,r,>")
          (match_operand:SI 1 "pic30_mode2mres_APSV_operand" "r,R,r,>,r")))
  ]
  "((!(pic30_errata_mask & psv_errata)) && (!pic30_isa32_target()))"
  "*
{
  static const char *patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;subb %d0,%D1,[w15]\",
     \"subr %1,%I0,[w15]\;subbr %d1,%D0,[w15]\",
     \"sub %0,%1,[w15]\;subb %d0,%1,[w15]\",
     \"subr %0,%1,[w15]\;subbr %d1,%0,[w15]\"
  };
  
  static const char *pre_patterns[] = {
     \"add %r1,#4,%r1\;sub %0,%I1,[w15]\;subb %d0,%D1,[w15]\",
     \"add %r0,#4,%r0\;subr %1,%I0,[w15]\;subbr %d1,%D0,[w15]\"
  };

  static const char *psv_psv_patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;nop\;subb %d0,%D1,[w15]\",
     \"subr %1,%I0,[w15]\;nop\;subbr %d1,%D0,[w15]\",
     \"sub %0,%1,[w15]\;nop\;subb %d0,%1,[w15]\",
     \"subr %0,%1,[w15]\;nop\;subbr %d1,%0,[w15]\"
  };
  
  static const char *psv_psv_pre_patterns[] = {
     \"add %r1,#4,%r1\;sub %0,%I1,[w15]\;nop\;subb %d0,%D1,[w15]\",
     \"add %r0,#4,%r0\;subr %1,%I0,[w15]\;nop\;subbr %d1,%D0,[w15]\"
  };

  if (pic30_psrd_psrd_errata(operands[0],operands[1])) {
    pic30_rtx_nops++;
    if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[1])) {
      return psv_psv_pre_patterns[which_alternative - 3];
    } else return psv_psv_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[1])) {
      return pre_patterns[which_alternative - 3];
    } else return patterns[which_alternative];
  }
}"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc,use,use,use,use")
    (set_attr "op_type" "alu")
  ])

(define_insn "cmpsi_zero_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:SI 0 "pic30_register_operand" "r")
                 (match_operand:SI 1 "pic30_O_operand"        "O")))
  ]
  "(!pic30_isa32_target())"
  "sub %0,#0,[w15]\;subb %d0,#0,[w15]"
   
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ])

(define_insn "cmpsi_immNP_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:SI 0 "pic30_register_operand"  "r,r,r")
                 (match_operand:SI 1 "immediate_operand"       "P,N,i")))
  ]
  "(((-31 <= INTVAL(operands[1])) && (INTVAL(operands[1]) <= 31)) ||
    ((0xFFE1 <= INTVAL(operands[1])) && (INTVAL(operands[1]) <= 0xFFFF))) &&
   (INTVAL(operands[1]) != 0) && (!pic30_isa32_target())"
  "@
   sub %0,#%1,[w15]\;subb %d0,#0,[w15]
   add %0,#%J1,[w15]\;addc %d0,#0,[w15]
   add %0,#%j1,[w15]\;subb %d0,#0,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ])

(define_insn "cmpsi_imm_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:SI 0 "pic30_register_operand"  "  r")
                 (match_operand:SI 1 "immediate_operand"       "  i")))
   (clobber (match_scratch:HI 2                                "=&r"))
  ]
  "((1<INTVAL(operands[1])) && 
    (INTVAL(operands[1])<65536) && 
    (!pic30_isa32_target()))"
  "mov #%1,%2\;sub %0,%2,[w15]\;subb %d0,#0,[w15]"
  [
    (set_attr "cc" "clobber")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*cmpsihi3_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:SI   0 "pic30_register_operand" "r")
                 (zero_extend:SI 
                   (match_operand:HI 1 "pic30_register_operand" "r"))))
  ]
  "(!pic30_isa32_target())"
  "sub %0,%1,[w15]\;subb %d0,#0,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ])

(define_expand "cmpsi_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:SI 0 "pic30_mode2mres_operand" "")
                 (match_operand:SI 1 "pic30_mode2mres_APSV_operand" "")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2mres_APSV_operand(operands[1],GET_MODE(operands[1]))) {
    if (pic30_errata_mask & psv_errata) {
      emit(
        gen_cmpsi_errata_APSV_16(operands[0],operands[1])
      );
    } else {
      emit(
        gen_cmpsi_noerrata_APSV_16(operands[0],operands[1])
      );
    }
  } else if (pic30_mode2mres_operand(operands[1], GET_MODE(operands[1]))) {
    emit(
      gen_cmpsi_DATA_16(operands[0],operands[1])
    );
  } else if (immediate_operand(operands[1],VOIDmode)) {
    rtx reg_0 = force_reg(GET_MODE(operands[0]),operands[0]);
    if (INTVAL(operands[1]) == 0) {
      emit(
        gen_cmpsi_zero_16(reg_0, operands[1])
      );
    } else {
      rtx reg = force_reg(GET_MODE(operands[0]),operands[1]);
      emit( 
        gen_cmpsi_DATA_16(reg_0, reg)
      );
    }
  }
  DONE;
}")


;;;;;;;;;;;;;;;;;;
;; double integer
;;;;;;;;;;;;;;;;;;

(define_insn "cmpdi_gen_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:DI 0 "pic30_register_operand"    "r,r")
                 (match_operand:DI 1 "pic30_reg_or_zero_operand" "r,O")))
  ]
  "(!pic30_isa32_target())"
  "@
   cp %0,%1\;cpb %d0,%d1\;cpb %t0,%t1\;cpb %q0,%q1
   sub %0,#0,[w15]\;subb %d0,#0,[w15]\;subb %t0,#0,[w15]\;subb %q0,#0,[w15]"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ])

(define_expand "cmpdi_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:DI 0 "general_operand" "")
                 (match_operand:DI 1 "general_operand" "")))
  ]
  "(!pic30_isa32_target())"
  "
{ rtx op0 = operands[0];
  rtx op1 = operands[1];

  if (!pic30_register_operand(operands[0], DImode))
    op0 = force_reg(DImode, operands[0]);
  if (!pic30_reg_or_zero_operand(operands[1], DImode))
    op1 = force_reg(DImode, operands[1]);
  emit(
      gen_cmpdi_gen_16(op0, op1)
  );
  DONE;
}"
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; truncation instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "movqi_p32ummaddress_16"
   [(set (match_operand:QI       0 "pic30_reg_or_R_operand" "=r,r,R,R")
         (subreg:QI 
           (match_operand:P32UMM 1 "pic30_reg_or_R_operand" " r,R,r,R") 0))]
   "(!pic30_isa32_target())"
   "@
    mov.b %1,%0
    mov.b %1,%0
    mov.b %1,%0
    mov.b %1,%0"
   [
     (set_attr "type" "def,defuse,use,use")
     (set_attr "op_type" "mov")
   ]
)

(define_insn "dtruncsi<mode>2_16"
   [(set (match_operand:TBLMODE 0 "pic30_reg_or_R_operand" "=r,r,R,R")
         (truncate:TBLMODE 
           (match_operand:SI 1 "pic30_reg_or_R_operand"   "  r,R,r,R")))]
   "(!pic30_isa32_target())"
   "*
 {
    static const char *patterns[] = { 
      \"mov.d %1,%0\",
      \"mov.d %1,%0\",
      \"mov.d %1,%0\",
      \"mov.d %1,%0\"
    };
 
    static const char *psrd_psrd_movd_patterns[] = {
      \"mov.d %1,%0\",
      \"mov %Q1,%d0\;mov %1,%0\",
      \"mov.d %1,%0\",
      \"mov %I1,%I0\;mov %D1,%D0\"
    };
 
    if ((pic30_errata_mask & psrd_psrd_errata_movd) == 0) {
      return patterns[which_alternative];
    } else {
      /* check for early clobber */
      int src_regno,dst_regno;
      int overlap;
 
      dst_regno = REGNO(operands[0]);
 
      switch (which_alternative) {
        default: /* no overlap possible */
                 break;
        case 1: {
          src_regno = REGNO(XEXP(operands[1],0));
          overlap = src_regno-dst_regno;
          switch (overlap) {
            default: /* no overlap */
              break;
            case 0:  /* src == dst */
              return \"mov %Q1,%d0\;mov %1,%0\";
            case 1:  /* src == dst+1 */
              break;
          }
          break;
        }
      }
      return psrd_psrd_movd_patterns[which_alternative];
    }
 }"
   [
     (set_attr "type" "def,defuse,etc,use")
     (set_attr "op_type" "mov")
   ]
)

(define_expand "truncsi<mode>2_16"
   [(set (match_operand:TBLMODE 0 "pic30_reg_or_R_operand" "=r,r,R,R")
         (truncate:TBLMODE
           (match_operand:SI 1 "pic30_reg_or_R_operand"   " r,R,r,R")))]
   "(!pic30_isa32_target())"
   "{
      emit(
        gen_dtruncsi<mode>2_16(operands[0],operands[1])
      );
    }"
)

(define_insn "truncsip32eds2_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand"   "=r,r")
        (truncate:P32EDS
          (match_operand:SI 1 "pic30_register_operand"     " r,0")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   rlc %1,[w15]\;rlc %d1,%d0\;mov %1,%0\;bclr %0,#15
   rlc %1,[w15]\;rlc %d1,%d0\;bclr %0,#15"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "truncsip32peds2_16"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand"   "=r")
        (truncate:P32PEDS
          (match_operand:SI 1 "pic30_register_operand"       "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "rlc %1,[w15]\;rlc %d1,%d0\;mov %1,%0\;bclr %0,#15"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; zero extension instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "zero_extendqihi2_DATA_16"
  [(set (match_operand:HI    0 "pic30_register_operand" "=r,r")
        (zero_extend:HI 
           (match_operand:QI 1 "pic30_mode2_operand"     "r,R<>")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "ze %1,%0"
  [
   (set_attr "cc" "math")  ; CAW
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "zero_extendqihi2_APSV_16"
  [(set (match_operand:HI   0 "pic30_register_operand"  "=r,r")
        (zero_extend:HI 
          (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,R<>")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "ze %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "zero_extendqihi2_16"
  [(set (match_operand:HI 0 "pic30_register_operand"       "=r,r")
        (zero_extend:HI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand"  " r,R<>")))]
  "(!pic30_isa32_target())"
  "
  {
    if (pic30_mode2_operand(operands[1],GET_MODE(operands[1]))) {
      emit(
        gen_zero_extendqihi2_DATA_16(operands[0],operands[1])
      );
    } else {
      rtx from = operands[1];
      emit(
        gen_zero_extendqihi2_APSV_16(operands[0],from)
      );
    }
    DONE;
  }")

(define_insn "zero_extendqisi2_16"
  [(set (match_operand:SI   0 "pic30_register_operand" "=r,r")
        (zero_extend:SI 
          (match_operand:QI 1 "pic30_mode2_operand"    " r,R<>")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "ze %1,%0\;clr %d0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "def,defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "zero_extendqidi2_16"
  [(set (match_operand:DI   0 "pic30_register_operand" "=r,r")
        (zero_extend:DI 
          (match_operand:QI 1 "pic30_mode2_operand"    " r,<>R")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "ze %1,%0\;clr %d0\;mul.uu %t0,#0,%t0"
  [
    (set_attr "cc" "clobber")  ; CAW
    ; (set_attr "type" "def,defuse")
    (set_attr "type" "etc,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "zero_extendhiP24PSV2_16"
  [(set (match_operand:P24PSV 0 "pic30_register_operand" "=r")
        (zero_extend:P24PSV 
           (match_operand:HI  1 "pic30_register_operand" " r")))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     int idDst;

     if (REGNO(operands[0]) == REGNO(operands[1]))
     {
       return \"mov #0,%d0\";
     }
     else
     {
       idDst = REGNO(operands[0]);
       if (idDst & 1)
         return \"mov %1,%0\;mov #0,%d0\";
       else
         return \"mul.uu %1,#1,%0\";
     }
   }"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "zero_extendhip32eds2_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand"      "=r,r,r")
        (zero_extend:P32EDS 
          (match_operand:HI 1 "pic30_reg_or_symbolic_address" " 0,r,qs")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   asr %1,#15,%d0\;bclr %0,#15
   mov %1,%0\;asr %0,#15,%d0\;bclr %0,#15
   mov #edsoffset(%1),%0\;mov #edspage(%1),%d0"
  [
    (set_attr "cc"  "clobber,clobber,unchanged")
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "zero_extendhip32peds2_16"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand"     "=r,r,r")
        (zero_extend:P32PEDS
          (match_operand:HI 1 "pic30_reg_or_symbolic_address" " 0,r,qs")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   asr %1,#15,%d0\;bclr %0,#15
   mov %1,%0\;asr %0,#15,%d0\;bclr %0,#15
   mov #edsoffset(%1),%0\;mov #edspage(%1),%d0"
  [
    (set_attr "cc"  "clobber,clobber,unchanged")
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "zero_extendsip32eds2_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand"   "=r,r")
        (zero_extend:P32EDS
          (match_operand:SI 1 "pic30_register_operand"      "0,r")))
   (clobber (reg:CC_C CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   rlc %1,[w15]\;rlc %d1,%d0\;bclr %0,#15
   rlc %1,[w15]\;rlc %d1,%d0\;mov %1,%0\;bclr %0,#15"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "zero_extendsip32peds2_16"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand" "=r,r")
        (zero_extend:P32PEDS
          (match_operand:SI 1 "pic30_register_operand"     "0,r")))
   (clobber (reg:CC_C CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   rlc %1,[w15]\;rlc %d1,%d0\;bclr %0,#15
   rlc %1,[w15]\;rlc %d1,%d0\;mov %1,%0\;bclr %0,#15"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "extendsip32eds2_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "=r,r")
        (sign_extend:P32EDS
          (match_operand:SI 1 "pic30_register_operand"    "0,r")))
   (clobber (reg:CC_C CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   rlc %1,[w15]\;rlc %d1,%d0\;bclr %0,#15
   rlc %1,[w15]\;rlc %d1,%d0\;mov %1,%0\;bclr %0,#15"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "extendsip32peds2_16"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand" "=r,r")
        (sign_extend:P32PEDS
          (match_operand:SI 1 "pic30_register_operand"     "0,r")))
   (clobber (reg:CC_C CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   rlc %1,[w15]\;rlc %d1,%d0\;bclr %0,#15
   rlc %1,[w15]\;rlc %d1,%d0\;mov %1,%0\;bclr %0,#15"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "zero_extendhisi2_16"
  [(set (match_operand:SI   0 "pic30_register_operand" "=r")
        (zero_extend:SI 
          (match_operand:HI 1 "pic30_register_operand" " r")))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     int idDst;

     if (REGNO(operands[0]) == REGNO(operands[1])) {
       return \"clr %d0\";
     } else {
       idDst = REGNO(operands[0]);
       if (idDst & 1)
         return \"mov %1,%0\;mov #0,%d0\";
       else
         return \"mul.uu %1,#1,%0\";
     }
   }"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "extendp32edssi2_16"
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
        (subreg:SI
          (match_operand:P32EDS 1 "pic30_register_operand" "r") 0))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sl %1,%0\;asr %d1,%d0\;rrc %0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)


;;
;; nop extentsions because thse modes are the same size
;;
;; hi

(define_insn "zero_extendp16apsvhi2_16"
  [(set (match_operand:HI       0 "register_operand" "=r")
        (zero_extend:HI 
          (match_operand:P16APSV 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop %1,%0"
)

(define_insn "zero_extendhip16apsv2_16"
  [(set (match_operand:P16APSV 0 "register_operand" "=r")
        (zero_extend:P16APSV 
          (match_operand:HI    1 "register_operand" " 0")))]
  "(!pic30_isa32_target())"
  "; nop %1,%0"
)

;; si

(define_insn "zero_extendp24psvsi2_16"
  [(set (match_operand:SI       0 "register_operand" "=r")
        (zero_extend:SI 
          (match_operand:P24PSV 1 "register_operand" " 0")))]
  "(!pic30_isa32_target())"
  "; nop %1,%0"
)

(define_insn "zero_extendp24progsi2_16"
  [(set (match_operand:SI        0 "register_operand" "=r")
        (zero_extend:SI 
          (match_operand:P24PROG 1 "register_operand" " 0")))]
  "(!pic30_isa32_target())"
  "; nop %1,%0"
)

(define_insn "zero_extendp32extsi2_16"
  [(set (match_operand:SI       0 "register_operand" "=r")
        (zero_extend:SI 
          (match_operand:P32EXT 1 "register_operand" " 0")))]
  "(!pic30_isa32_target())"
  "; nop %1,%0"
)

(define_insn "extendp32extsi2_16"
  [(set (match_operand:SI       0 "register_operand" "=r")
        (sign_extend:SI 
          (match_operand:P32EXT 1 "register_operand" " 0")))]
  "(!pic30_isa32_target())"
  "; nop %1,%0"
)

(define_insn "zero_extendsip24psv2_16"
  [(set (match_operand:P24PSV   0 "register_operand" "=r")
        (zero_extend:P24PSV 
          (match_operand:SI     1 "register_operand" " 0")))]
  "(!pic30_isa32_target())"
  "; nop %1,%0"
)

(define_insn "zero_extendsip24prog2_16"
  [(set (match_operand:P24PROG   0 "register_operand" "=r")
        (zero_extend:P24PROG 
          (match_operand:SI      1 "register_operand" " 0")))]
  "(!pic30_isa32_target())"
  "; nop %1,%0"
)

(define_insn "zero_extendsip32ext2_16"
  [(set (match_operand:P32EXT   0 "register_operand" "=r")
        (zero_extend:P32EXT 
          (match_operand:SI     1 "register_operand" " 0")))]
  "(!pic30_isa32_target())"
  "; nop %1,%0"
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; sign extension instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "extendqihi2_DATA_16"
  [(set (match_operand:HI   0 "pic30_register_operand" "=r,r")
        (sign_extend:HI 
          (match_operand:QI 1 "pic30_mode2_operand"    " r,R<>"))
   )
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "se %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "extendqihi2_APSV_16"
  [(set (match_operand:HI   0 "pic30_register_operand"  "=r,r")
        (sign_extend:HI 
          (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,R<>"))
   )
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "se %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "extendqihi2_16"
 [(set (match_operand:HI   0 "pic30_register_operand"  "=r,r")
       (sign_extend:HI 
         (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,R<>"))
   )
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_operand(operands[1], GET_MODE(operands[1]))) 
    emit(gen_extendqihi2_DATA_16(operands[0], operands[1]));
  else
    emit(gen_extendqihi2_APSV_16(operands[0], operands[1]));
  DONE;
}")

(define_insn "extendqisi2_16"
  [(set (match_operand:SI   0 "pic30_register_operand" "=r,r")
        (sign_extend:SI 
          (match_operand:QI 1 "pic30_mode2_operand"     "r,R<>")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "se %1,%0\;asr %0,#15,%d0"
  [
    (set_attr "cc" "clobber") ;  CAW
    (set_attr "type" "def,defuse")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "extendqidi2_16"
  [(set (match_operand:DI   0 "pic30_register_operand" "=r,r")
        (sign_extend:DI 
          (match_operand:QI 1 "pic30_mode2_operand"    " r,R<>")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "se %1,%0\;asr %0,#15,%d0\;mul.su %d0,#1,%t0"
  [
    (set_attr "cc" "clobber")  ; CAW
    ; (set_attr "type" "def,defuse")
    (set_attr "type" "etc,use")
    (set_attr "op_type" "alu")
  ]
)

;(define_insn "extendhisi2_16"
;  [(set (match_operand:SI 0 "pic30_register_operand"   "=r")
;        (sign_extend:SI 
;           (match_operand:HI 1 "pic30_register_operand" "r")) 
;   )
;   (clobber (reg:CC_NZ CC_REG))
;  ]
;  "(!pic30_isa32_target())"
;  "*
;  {
;    int idSrc, idDst;
;
;    idDst = REGNO(operands[0]);
;    idSrc = REGNO(operands[1]);
;    if (idDst == idSrc) {
;      return \"asr %0,#15,%d0\";
;    } else {
;      if (idDst & 1)
;        return \"mov %1,%0\;asr %0,#15,%d0\";
;      else return \"mul.su %1,#1,%0\";
;    }
;  }"
;  [
;   (set_attr "cc" "clobber")
;   (set_attr "type" "def")
;   (set_attr "op_type" "alu")
;  ]
;)

(define_insn "extendhisi2_16"
  [(set (match_operand:SI 0 "pic30_register_operand"   "=r")
        (sign_extend:SI 
           (match_operand:HI 1 "pic30_register_operand" "r")) 
   )
  ]
  "(!pic30_isa32_target())"
  "mul.su %1,#1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;(define_insn "extendhip32ext2_16"
;  [(set (match_operand:P32EXT 0 "pic30_register_operand" "=r")
;        (sign_extend:P32EXT 
;          (match_operand:HI   1 "pic30_register_operand" " r")))
;   (clobber (reg:CC_NZC CC_REG))
;  ]
;  "(!pic30_isa32_target())"
;  "*
;   {
;     int idSrc, idDst;
;
;     idDst = REGNO(operands[0]);
;     idSrc = REGNO(operands[1]);
;     if (idDst == idSrc) {
;       return \"lsr %0,#15,%d0\";
;     } else {
;       if (idDst & 1)
;         return \"mov %1,%0\;lsr %0,#15,%d0\";
;       else return \"mul.uu %1,#1,%0\";
;     }
;   }"
;  [
;    (set_attr "cc" "clobber")
;    (set_attr "type" "def")
;    (set_attr "op_type" "alu")
;  ]
;)

(define_insn "extendhip32ext2_16"
  [(set (match_operand:P32EXT 0 "pic30_register_operand" "=r")
        (sign_extend:P32EXT
           (match_operand:HI  1 "pic30_register_operand"  "r"))
   )
  ]
  "(!pic30_isa32_target())"
  "mul.uu %1,#1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;(define_insn "zero_extendhip32ext2_16"
;  [(set (match_operand:P32EXT 0 "pic30_register_operand" "=r")
;        (zero_extend:P32EXT 
;          (match_operand:HI   1 "pic30_register_operand" " r")))
;   (clobber (reg:CC_NZC CC_REG))
;  ]
;  "(!pic30_isa32_target())"
;  "*
;   {
;     int idSrc, idDst;
;
;     idDst = REGNO(operands[0]);
;     idSrc = REGNO(operands[1]);
;     if (idDst == idSrc) {
;       return \"lsr %0,#15,%d0\";
;     } else {
;       if (idDst & 1)
;         return \"mov %1,%0\;lsr %0,#15,%d0\";
;       else return \"mul.uu %1,#1,%0\";
;     }
;   }"
;  [
;    (set_attr "cc" "clobber")
;    (set_attr "type" "def")
;    (set_attr "op_type" "alu")
;  ]
;)

(define_insn "zero_extendhip32ext2_16"
  [(set (match_operand:P32EXT 0 "pic30_register_operand" "=r,D,r")
        (sign_extend:P32EXT
           (match_operand:HI  1 "pic30_register_operand"  "0,r,r"))
   )
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lsr %0,#15,%d0
   mov %1,%0\;lsr %0,#15,%d0
   mul.uu %1,#1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "extendhip32eds_stack_16"
  [(set (match_operand: P32EDS 0 "pic30_register_operand"    "=r")
        (unspec:P32EDS [
          (match_operand:HI 1    "pic30_register_operand"    " r")
        ] UNSPEC_EDSSTACKADDR))
   (clobber (reg:CC_C CC_REG))
  ]
  "(!pic30_isa32_target())"
  "rlc %1,[w15]\;mul.uu %1,#1,%0\;rlc %d0,%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "extendhip32peds_stack_16"
  [(set (match_operand: P32PEDS 0 "pic30_register_operand"    "=r")
        (unspec:P32PEDS [
          (match_operand:HI 1    "pic30_register_operand"    " r")
        ] UNSPEC_EDSSTACKADDR))
   (clobber (reg:CC_C CC_REG))
  ]
  "(!pic30_isa32_target())"
  "rlc %1,[w15]\;mul.uu %1,#1,%0\;rlc %d0,%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "extendhip32eds2_16"
  [(set (match_operand: P32EDS 0 "pic30_register_operand"    "=r")
        (sign_extend:P32EDS
          (match_operand:HI 1    "pic30_register_operand"    " r")))
  ]
  "(!pic30_isa32_target())"
  "mul.uu %1,#1,%0\;btsc %0,#15\;mov #__const_psvpage,%d0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "extendhip32eds2_const_16"
  [(set (match_operand: P32EDS 0 "pic30_register_operand"         "=r,r")
        (unspec: P32EDS [
          (match_operand:HI 1    "pic30_reg_or_symbolic_address"  " r,qs")
        ] UNSPEC_EDSCONSTADDR))]
  ""
  "@
   mul.uu %1,#1,%0\;btsc %0,#15\;mov #__const_psvpage,%d0
   mov #edsoffset(%1),%0\;clr %d1\;btsc %0,#15\;mov #__const_psvpage,%d0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "extendhip32peds2_16"
  [(set (match_operand: P32PEDS 0 "pic30_register_operand"    "=r")
        (sign_extend:P32PEDS
          (match_operand:HI 1    "pic30_register_operand"     " r")))]
  "(!pic30_isa32_target())"
  "mul.su %1,#1,%0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "extendhip32peds2_const_16"
  [(set (match_operand: P32PEDS 0 "pic30_register_operand"    "=r")
        (unspec: P32PEDS [
          (match_operand:HI 1    "pic30_register_operand"    " r")
        ] UNSPEC_EDSCONSTADDR))]
   ""
   "mul.uu %1,#1,%0\;btsc %0,#15\;mov #__const_psvpage,%d0"
   [
     (set_attr "type" "def")
   ]
)

(define_insn "extendhidi2_16"
  [(set (match_operand:DI 0 "pic30_register_operand"                "=r,r")
        (sign_extend:DI (match_operand:HI 1 "pic30_register_operand" "0,r")) )
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   asr %0,#15,%d0\;mul.su %d0,#1,%t0
   mul.su %1,#1,%0\;mul.su %d0,#1,%t0"
  [
   (set_attr "cc" "clobber")
   ; (set_attr "type" "def")
   (set_attr "type" "use")
   (set_attr "op_type" "movlit")
  ]
)

(define_insn "extendsidi2_16"
  [(set (match_operand:DI 0 "pic30_register_operand"    "=r,r")
        (sign_extend:DI 
            (match_operand:SI 1 "pic30_register_operand" "0,r")) 
   )
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   asr %d0,#15,%t0\;mov %t0,%q0
   mov.d %1,%0\;asr %d0,#15,%t0\;mov %t0,%q0"
  [
   (set_attr "cc" "clobber")
   ; (set_attr "type" "def")
   (set_attr "type" "etc")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "zero_extendhidi2_16"
  [(set (match_operand:DI 0 "pic30_register_operand"                "=r,r")
        (zero_extend:DI 
           (match_operand:HI 1 "pic30_register_operand"              "0,r"))
   )
  ]
  "(!pic30_isa32_target())"
  "@
   clr %d0\;mul.uu %t0,#0,%t0
   mul.uu %1,#1,%0\;mul.uu %t0,#0,%t0"
  [
   ; (set_attr "type" "def")
   (set_attr "type" "etc")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "zero_extendsidi2_16"
  [(set (match_operand:DI 0 "pic30_register_operand"  "=r,r,&r,r,r")
        (zero_extend:DI 
            (match_operand:SI 1 "pic30_mode2_operand"  "0,r, R,<,>")) 
   )
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
   static const char *patterns[] = {
     \"mul.uu %t0,#0,%t0\",
     \"mov.d %1,%0\;mul.uu %t0,#0,%t0\",
     \"mov.d %1,%0\;mul.uu %t0,#0,%t0\",
     \"mov.d %1,%0\;mul.uu %t0,#0,%t0\",
     \"mov.d %1,%0\;mul.uu %t0,#0,%t0\"
   };

   static const char *psrd_psrd_movd_patterns[] = {
     \"mul.uu %t0,#0,%t0\",
     \"mov.d %1,%0\;mul.uu %t0,#0,%t0\",
     \"mov %1,%0\;mov %Q1,%d0\;mul.uu %t0,#0,%t0\",
     \"mov %1,%0\;mov %1,%d0\;mul.uu %t0,#0,%t0\",
     \"mov %1,%0\;mov %1,%d0\;mul.uu %t0,#0,%t0\"
   };

   if ((pic30_errata_mask & psrd_psrd_errata_movd) == 0) {
     return patterns[which_alternative];
   } else {
     /* check for early clobber */
     int src_regno,dst_regno;
     int overlap; 
 
     dst_regno = REGNO(operands[0]);
 
     switch (which_alternative) {
       default: /* no overlap possible */
                break;
       case 2: {
         src_regno = REGNO(XEXP(operands[1],0));
         overlap = src_regno-dst_regno;
         switch (overlap) {
           default: /* no overlap */
             break;
           case 0:  /* src == dst */
             return \"mov %Q1,%d0\;mul.uu %t0,#0,%t0\;mov %1,%0\";
           case 1:  /* src == dst+1 */
             return\"mov %1,%0\;mul.uu %t0,#0,%t0\;mov %Q1,%d0\";
           case 2:  /* src == dst+2 */
             break;
           case 3:  /* src == dst+3 */
             break;
         }
         break;
       }
       case 3: {
         if (pic30_pre_modify(operands[1])) {
           /* pre-decrement */
           return \"sub %r1,#4,%r1\;mov [%r1],%0\;mov [%r1+2],%d0\;\"
                  \"mul.uu %t0,#0,%t0\";
         } else if (pic30_pre_modify(operands[1])) {
           /* pre-increment */
           return \"add %r1,#4,%r1\;mov [%r1],%0\;mov [%r1+2],%d0\;\"
                  \"mul.uu %t0,#0,%t0\";
         }
         break;
       }
     } 
     return psrd_psrd_movd_patterns[which_alternative];
   }
  }"
  [
   ; (set_attr "type" "def,def,defuse,defuse,defuse")
   (set_attr "type" "etc,etc,use,use,use")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Move instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Invalid move

(define_insn "*movqi_invalid_1_16"
  [(set (match_operand:QI 0 "pic30_register_operand"  "=r")
        (match_operand:QI 1 "pic30_code_operand" "g"))]
  "(!pic30_isa32_target())"
  "*
   {
     error(\"invalid address space for operand\");
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "*movqi_invalid_2_16"
  [(set (match_operand:QI 0 "pic30_code_operand" "=g")
        (match_operand:QI 1 "pic30_register_operand"    "r"))]
  "(!pic30_isa32_target())"
  "*
   {
     error(\"invalid address space for operand\");
     return \"cannot generate instruction\";
   }
  "
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 8-bit moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "movqi_const0_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=r,R<>")
	(const_int 0))]
  "(!pic30_isa32_target())"
  "@
   clr.b %0
   clr.b %0"
  [
    (set_attr "cc" "change0,change0")
    (set_attr "type" "def,etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "movqi_const1_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=r,R<>")
	(const_int -1))]
  "(!pic30_isa32_target())"
  "@
   setm.b %0
   setm.b %0"
  [
    (set_attr "cc" "change0,change0")
    (set_attr "type" "def,etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "movqi_const0sfr_16"
  [(set (match_operand:QI 0 "pic30_near_operand" "=U")
	(const_int 0))]
  "(!pic30_isa32_target())"
  "clr.b %0"
  [
    (set_attr "cc" "change0")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "movqi_const1sfr_16"
  [(set (match_operand:QI 0 "pic30_near_operand" "=U")
	(const_int -1))]
  "(!pic30_isa32_target())"
  "setm.b %0"
  [
    (set_attr "cc" "change0")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "movqi_rimm_16"
  [(set (match_operand:QI 0 "pic30_register_operand" "=r")
        (match_operand:QI 1 "immediate_operand" "i"))]
  "(!pic30_isa32_target())"
  "mov.b #%1,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

; general case
(define_insn "movqi_gen_DATA_16"
  [(set (match_operand:QI 0 "pic30_move_operand"
                 "=r<>,RS,r<>, R,   r<>,RS,r<>, R,   Q,r,a,!U,d")
        (match_operand:QI 1 "pic30_move_operand"
                  "r,  r, <>RS,<>RS,r,  r, RS<>,RS<>,r,Q,U,a, U"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target()) && 
     ((!pic30_near_operand(operands[0],GET_MODE(operands[0]))) || 
      (!pic30_near_operand(operands[1],GET_MODE(operands[1]))))"
  "*
  {  

     switch (which_alternative) {
       default: gcc_assert(0);
       case 0:  return \"mov.b %1,%0\";
       case 1:  return \"mov.b %1,%0\";
       case 2:  return \"mov.b %1,%0\";
       case 3:  return \"mov.b %1,%0\";
       case 4:  return \"mov.b %1,%0\";
       case 5:  return \"mov.b %1,%0\";
       case 6:  return \"mov.b %1,%0\";
       case 7:  return \"mov.b %1,%0\";
       case 8:  return \"mov.b %1,%0\";
       case 9:  return \"mov.b %1,%0\";
       case 10: return \"mov.b %1,WREG\";
       case 11: return \"mov.b WREG,%0\";
       case 12: if (pic30_errata_mask & ecc_errata) {
                  /* ATP we can do better */
                  return \"mov #%1,%0\;nop\;mov.b [%0],%0\";
                } 
                return \"mov #%1,%0\;mov.b [%0],%0\";
    }
  }
  "
  [
    (set_attr "cc" "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move,change0,change0") ; CAW
   (set_attr "type"
	"defuse,etc,defuse,use,def,etc,defuse,use,use,use,def,etc,def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "movqi_gen_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode3_APSV_operand"
                "=r<>,RS,r<>, R,  r<>,RS,r<>, R,   Q,r,a,U,?d")
        (match_operand:QI 1 "pic30_move_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, RS<>,RS<>,r,Q,U,a, U"))
   (use (reg:HI PSVPAG))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {  

     switch (which_alternative) {
       default: gcc_assert(0);
       case 0:  return \"mov.b %1,%0\";
       case 1:  return \"mov.b %1,%0\";
       case 2:  return \"mov.b %1,%0\";
       case 3:  return \"mov.b %1,%0\";
       case 4:  return \"mov.b %1,%0\";
       case 5:  return \"mov.b %1,%0\";
       case 6:  return \"mov.b %1,%0\";
       case 7:  return \"mov.b %1,%0\";
       case 8:  return \"mov.b %1,%0\";
       case 9:  return \"mov.b %1,%0\";
       case 10: return \"mov.b %1,WREG\";
       case 11: return \"mov.b WREG,%0\";
       case 12: if (pic30_errata_mask & ecc_errata) {
                  /* ATP we can do better */
                  return \"mov #%1,%0\;nop\;mov.b [%0],%0\";
                } 
                return \"mov #%1,%0\;mov.b [%0],%0\";
    }
  }
  "
  [
    (set_attr "cc" "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move,change0,change0") ; CAW
   (set_attr "type"
	"defuse,etc,defuse,use,def,etc,defuse,use,use,use,def,etc,def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "movqi_gen_a_DATA_16"
  [(set (match_operand:QI 0 "pic30_move_operand"
		"=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U")
        (match_operand:QI 1 "pic30_move2_operand"
		 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a"))
  ]
  "(!pic30_isa32_target())"
  "*
  {  
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0:  return \"mov.b %1,%0\";
       case 1:  return \"mov.b %1,%0\";
       case 2:  return \"mov.b %1,%0\";
       case 3:  return \"mov.b %1,%0\";
       case 4:  return \"mov.b %1,%0\";
       case 5:  return \"mov.b %1,%0\";
       case 6:  return \"mov.b %1,%0\";
       case 7:  return \"mov.b %1,%0\";
       case 8:  return \"mov.b %1,%0\";
       case 9:  return \"mov.b %1,%0\";
       case 10: return \"mov.b WREG,%0\";
    }
  }
  "
  [
    (set_attr "cc"
	"change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,change0")
   (set_attr "type"
	"def,etc,defuse,use,def,etc,defuse,use,etc,defuse,etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "movqi_gen_a_APSV_16"
  [(set (match_operand:QI 0 "pic30_move_operand"
		"=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U")
        (unspec:QI [
           (match_operand:QI 1 "pic30_move2_APSV_operand"
		 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a")
           (reg:HI PSVPAG)] UNSPECV_USEPSV))
  ]
  "(!pic30_isa32_target())"
  "*
  {  
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0:  return \"mov.b %1,%0\";
       case 1:  return \"mov.b %1,%0\";
       case 2:  return \"mov.b %1,%0\";
       case 3:  return \"mov.b %1,%0\";
       case 4:  return \"mov.b %1,%0\";
       case 5:  return \"mov.b %1,%0\";
       case 6:  return \"mov.b %1,%0\";
       case 7:  return \"mov.b %1,%0\";
       case 8:  return \"mov.b %1,%0\";
       case 9:  return \"mov.b %1,%0\";
       case 10: return \"mov.b WREG,%0\";
    }
  }
  "
  [
    (set_attr "cc"
	"change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,change0")
   (set_attr "type"
	"def,etc,defuse,use,def,etc,defuse,use,etc,defuse,etc")
    (set_attr "op_type" "mov")
  ]
)



; pattern 10 clobbers nz... maybe separate it out...
(define_insn "movqi_gen_b_16"
  [(set (match_operand:QI 0 "pic30_move2_operand"
		"=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,a,r")
        (match_operand:QI 1 "pic30_move_operand"
		 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,U,U"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {  
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0:  return \"mov.b %1,%0\";
       case 1:  return \"mov.b %1,%0\";
       case 2:  return \"mov.b %1,%0\";
       case 3:  return \"mov.b %1,%0\";
       case 4:  return \"mov.b %1,%0\";
       case 5:  return \"mov.b %1,%0\";
       case 6:  return \"mov.b %1,%0\";
       case 7:  return \"mov.b %1,%0\";
       case 8:  return \"mov.b %1,%0\";
       case 9:  return \"mov.b %1,%0\";
       case 10: return \"mov.b %1,WREG\";
       case 11: if (REGNO(operands[0]) == WR0_REGNO) 
                  return \"mov.b %1,WREG\";
                else if (pic30_errata_mask & ecc_errata) { 
                  // ATP we can do better
                  return \"mov #%1,%0\;nop\;mov.b [%0],%0\";
                }
                return \"mov #%1,%0\;mov.b [%0],%0\";
    }
  }
  "
  [
    (set_attr "cc" "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move,change0") ; CAW
   (set_attr "type"
	"def,etc,defuse,use,def,etc,defuse,use,etc,defuse,def,def")
    (set_attr "op_type" "mov")
  ]
)

;; If one of the operands is immediate and the other is not a register,
;; then we should emit two insns, using a scratch register.  This will produce
;; better code in loops if the source operand is invariant, since
;; the source reload can be optimised out.  During reload we cannot
;; use change_address or force_reg which will allocate new pseudo regs.

;; Unlike most other insns, the move insns can`t be split with
;; different predicates, because register spilling and other parts of
;; the compiler, have memoized the insn number already.

(define_expand "movqi_16"
  [(set (match_operand:QI 0 "pic30_general_operand" "")
        (match_operand:QI 1 "pic30_general_operand" ""))]
  "(!pic30_isa32_target())"
  "
  {
     rtx op;

     /* sometimes get here from emit_move_insn even though the rhs is
      * an add or something.  we need to handle it now that there are
      * potential clobbers of the CC
      *
      * pic30_emit_move_sequence may update operands */
     if (pic30_emit_move_sequence(operands, QImode)) DONE;
     if (pic30_near_operand(operands[0], QImode) &&
        pic30_near_operand(operands[1], QImode)) {
        rtx op1 = force_reg(QImode, operands[1]);
        emit(gen_movqi_gen_DATA_16(operands[0], op1));
        DONE;
     }

     op = operands[1];

     while (GET_CODE(op) == CONST) op = XEXP(op,0);
     switch (GET_CODE(op)) {
       default: gcc_assert(0);
       case PLUS: {
         rtx op1 = XEXP(op,0);
         rtx op2 = XEXP(op,1);
         if (GET_CODE(op1) != SYMBOL_REF) {
           if (!pic30_math_operand(op1,QImode)) {
             op1 = force_reg(QImode,op1);
           }
           if (!pic30_mode1JN_operand(op2,QImode)) {
             op2 = force_reg(QImode,op2);
           }
           emit(
             gen_addqi3_16(operands[0], op1, op2)
           );
           DONE;
         }
         /* HANDLE SYMBOL_REF below ... */
       }
       /* FALLSTHROUGH */
       case CONST_INT:
         if (GET_CODE(op) == CONST_INT) {
           if (GET_CODE(operands[0]) == REG) {
             emit(
               gen_movqi_rimm_16(operands[0],operands[1])
             );
             DONE;
           } else {
             if (pic30_mode2_operand(operands[0], GET_MODE(operands[0]))) {
               if (INTVAL(operands[1]) == 0) {
                 emit(
                   gen_movqi_const0_16(operands[0])
                 );
                 DONE;
               } else if (INTVAL(operands[1]) == -1) {
                 emit(
                   gen_movqi_const1_16(operands[0])
                 );
                 DONE;
               }
             } else if (pic30_near_operand(operands[0], GET_MODE(operands[0]))) {
               if (INTVAL(operands[1]) == 0) {
                 emit(
                   gen_movqi_const0sfr_16(operands[0])
                 );
                 DONE;
               } else if (INTVAL(operands[1]) == -1) {
                 emit(
                   gen_movqi_const1sfr_16(operands[0])
                 );
                 DONE;
               }
             } else if (can_create_pseudo_p()) {
               rtx r = force_reg(GET_MODE(operands[0]), op);
               emit(
                 gen_movqi_gen_DATA_16(operands[0],r)
               );
               DONE;
             }
           }
           break;
         }
         /* FALLSTHROUGH */
       case SUBREG:
       case REG:
       case LABEL_REF:
       case SYMBOL_REF:
       case MEM:
         if (pic30_reload_in_progress() ||
             (pic30_move_operand(operands[0],QImode) &&
              pic30_move_operand(operands[1],QImode))) {
           emit(
             gen_movqi_gen_DATA_16(operands[0],operands[1])
           );
           DONE;
         }
         break;
     }
   }
#if 0
  if (pic30_emit_move_sequence(operands, QImode)) DONE;
  if (pic30_near_operand(operands[0], QImode) &&
      pic30_near_operand(operands[1], QImode)) {
      rtx op1 = force_reg(QImode, operands[1]);
      emit(gen_movqi_gen_DATA_16(operands[0], op1));
      DONE;
  }
  if (pic30_move_operand(operands[1],QImode)) {
     emit(gen_movqi_gen_DATA_16(operands[0],operands[1]));
     DONE;
  } else if (pic30_move_APSV_operand(operands[1],QImode)) {
     emit(gen_movqi_gen_APSV_16(operands[0],operands[1]));
     DONE;
  }
#endif
  ")

;; Invalid move

(define_insn "*movhi_invalid_1_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (match_operand:HI 1 "pic30_code_operand"  "g"))]
  "(!pic30_isa32_target())"
  "*
   {
        error(\"invalid address space for operand\");
        return \"cannot generate instruction\";
   }
")

(define_insn "*movhi_invalid_2_16"
  [(set (match_operand:HI 0 "pic30_code_operand" "=g")
        (match_operand:HI 1 "pic30_register_operand"  "r"))]
  "(!pic30_isa32_target())"
  "*
   {
        error(\"invalid address space for operand\");
        return \"cannot generate instruction\";

   }
")

(define_insn "*movhi_invalid_3_16"
  [(set (match_operand:HI 0 "pic30_move_operand" "")
        (mem: HI (match_operand:HI 1 "pic30_invalid_address_operand"  "")))]
  "(!pic30_isa32_target())"
  "*
   {
        error(\"invalid address space for operand\");
        return \"cannot generate instruction\";
   }
")

(define_insn "*movhi_invalid_4_16"
  [(set (mem (match_operand:P24PROG 0 "pic30_prog_operand" ""))
        (match_operand 1 "general_operand" ""))]
  "(!pic30_isa32_target())"
  "*
   {
     error(\"invalid address space for destination\");
     return \"cannot generate instruction\";
   }
")

(define_insn "*movhi_invalid_5_16"
  [(set (mem (match_operand:P24PSV 0 "pic30_psv_operand" ""))
        (match_operand 1 "general_operand" ""))]
  "(!pic30_isa32_target())"
  "*
   {
     error(\"invalid address space for destination\");
     return \"cannot generate instruction\";

   }
")

(define_insn "*movhi_invalid_6_16"
  [(set (mem (match_operand:P32DF 0 "pic30_df_operand" ""))
        (match_operand 1 "general_operand" ""))]
  "(!pic30_isa32_target())"
  "*
   {
     error(\"invalid address space for destination\");
     return \"cannot generate instruction\";
   }
")

(define_insn "*movhi_invalid_7_16"
  [(set (match_operand:HI     0 "register_operand" "")
        (mem:HI 
          (plus:HI 
            (reg:HI SPREG)
            (match_operand    1 "immediate_operand" ""))))]
  "(INTVAL(operands[1]) & 1)"
  "*
   {
     if (!warn_cast_align) {
       error(\"Odd offset to integer sized dereference;\n\"
             \"  suggest -Wcast-align to identify invalid type punning\");
     } else {
       error(\"Odd offset to integer sized dereference\");
     }
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "*movhi_invalid_8_16"
  [(set 
        (mem:HI 
          (plus:HI 
            (reg:HI SPREG)
            (match_operand    0 "immediate_operand" "")))
        (match_operand:HI     1 "general_operand" ""))
  ]
  "(INTVAL(operands[0]) & 1)"
  "*
   {
     if (!warn_cast_align) {
       error(\"Odd offset to integer sized dereference;\n\"
             \"  suggest -Wcast-align to identify invalid type punning\");
     } else {
       error(\"Odd offset to integer sized dereference\");
     }
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "*movhi_invalid9_16"
  [(set (match_operand:HI  0  "register_operand" "")
        (match_operand:HI  1  "pic30_invalid_immediate_operand" ""))]
  ""
  "*
   {
     if (INSN_LOCATION(insn) && insn_file(insn)) {
       error_at(RTL_LOCATION(insn),
                \"Literal value over/underflows register\");
       inform(RTL_LOCATION(insn),
              \"This likely signifies overflow in pointer increment.\");
     } else {
       error(\"Literal value over/underflows register\n\");
     }
     return \"cannot generate instruction\";
   }
  "
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 16-bit moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;
;; immediate zero
;;;;;;;;;;;;;;;;;

(define_insn "movhi_const0sfr_16"
  [(set (match_operand:HI 0 "pic30_near_operand" "=U")
	(const_int 0))]
  "(!pic30_isa32_target())"
  "clr.w %0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "movhi_const1sfr_16"
  [(set (match_operand:HI 0 "pic30_near_operand" "=U")
	(const_int -1))]
  "(!pic30_isa32_target())"
  "setm.w %0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "movhi_const0_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=r,R<>")
	(const_int 0))]
  "(!pic30_isa32_target())"
  "@
   clr.w %0
   clr.w %0"
  [
   (set_attr "cc" "change0,change0")
   (set_attr "type" "def,etc")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "movp16apsv_const0_16"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand" "=r,R<>")
	(const_int 0))]
  "(!pic30_isa32_target())"
  "@
   clr.w %0
   clr.w %0"
  [
   (set_attr "cc" "change0,change0")
   (set_attr "type" "def,etc")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "movhi_const1_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=r,R<>")
	(const_int -1))]
  "(!pic30_isa32_target())"
  "@
   setm.w %0
   setm.w %0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,etc")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "*movp16apsv_const1_16"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand" "=r,R<>")
	(const_int -1))]
  "(!pic30_isa32_target())"
  "@
   setm.w %0
   setm.w %0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,etc")
   (set_attr "op_type" "mov")
  ]
)

;;;;;;;;;;;;;;;;;;;;
;; general immediate
;;;;;;;;;;;;;;;;;;;;

(define_insn "movqi_address_16"
  [(set (match_operand:QI 0 "pic30_register_operand"              "=r")
        (subreg:QI
          (match_operand:HI 1 "pic30_symbolic_address_operand"    " qs") 0))
  ]
  "(!pic30_isa32_target())"
  "mov.b #%1,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "movp16apsv_address_16"
  [(set (match_operand:P16APSV 0 "pic30_register_operand"         "=r")
        (match_operand:P16APSV 1 "pic30_symbolic_address_operand" " rqs"))]
  "(!pic30_isa32_target())"
  "*
{ rtx sym;

  if (pic30_symbolic_address_operand(operands[1], GET_MODE(operands[1]))) {
    /* this can be converted to a register copy, so check for symref first */
    sym = pic30_program_space_operand_p(operands[1]);
    if (sym) {
      tree fndecl = GET_CODE(sym) == SYMBOL_REF ? SYMBOL_REF_DECL(sym) : 0;
      tree fndecl_attrib;
      const char *access=0;
      int slot = 0;

      if (fndecl) {
        if ((fndecl_attrib =
              pic30_lookup_attribute(IDENTIFIER_POINTER(pic30_identBoot[0]),
                               DECL_ATTRIBUTES(fndecl)))) {
          access=\"boot\";
        } else if ((fndecl_attrib = pic30_lookup_attribute(
                                    IDENTIFIER_POINTER(pic30_identSecure[0]),
                                    DECL_ATTRIBUTES(fndecl)))) {
          access=\"secure\";
        }
      }
      if (access) {
        if (TREE_VALUE(fndecl_attrib)) {
          if (TREE_CODE(TREE_VALUE(TREE_VALUE(fndecl_attrib))) == INTEGER_CST) {
            slot = TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(fndecl_attrib)));
          } else access = 0;
        } else access = 0;
      }
      if (access) {
        static char buffer[25];
        sprintf(buffer,\"mov #%s(%d),%%0\", access, slot);
        return buffer;
      } else {
        return \"mov #handle(%1),%0\";
      }
    } else {
      return \"mov #%1,%0\";
    }
  } else return \"mov %1,%0\";
}"
 [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "movlit")
 ]
)

(define_insn "movhi_imm_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (match_operand:HI 1 "const_int_operand"      " i"))
  ]
  "(!pic30_isa32_target())"
  "mov.w #%1,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "movP16APSV_imm_16"
  [(set (match_operand:P16APSV 0 "pic30_register_operand" "=r")
        (match_operand:P16APSV 1 "const_int_operand"      " i"))
  ]
  "(!pic30_isa32_target())"
  "mov #%1,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; builtin move directives
;;;;;;;;;;;;;;;;;;;;;;;;;;

; not 'def' becuase the last instruction generated does not cause a RAW stall
(define_insn "readsfr_16"
  [(set (match_operand:HI   0 "pic30_register_operand" "=r")
        (unspec_volatile:HI [
          (match_operand:HI 1 "pic30_register_operand" " r")
         ] UNSPECV_READSFR))
  ]
  "(!pic30_isa32_target())"
  "*
   if (pic30_errata_mask & psrd_psrd_errata) {
       pic30_rtx_nops++;
      /* this errata should not be needed for this device; but the user
          asked for it... make it psrd_psrd safe */
      return \"push SR\;\"
             \"bset SR,#5\;\"
             \"bset SR,#6\;\"
             \"bset SR,#7\;\"
             \"mov [%1],[w15]\;\"
             \"pop SR\;\"
             \"mov [%1],%0\";
   } else {
      return \"push SR\;\"
             \"bset SR,#5\;\"
             \"bset SR,#6\;\"
             \"bset SR,#7\;\"
             \"mov [%1],[w15]\;\"
             \"mov [%1],%0\;\"
             \"pop SR\";
   }
  "
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "readsfrumm_16"
  [(set (match_operand:HI   0 "pic30_register_operand"     "=r")
        (unspec_volatile:HI [
          (match_operand:P32UMM 1 "pic30_register_operand" " r")
         ] UNSPECV_READSFR))
  ]
  "(!pic30_isa32_target())"
  "*
   if (pic30_extended_ram_target()) {
      return \"rrnc %1,%0\;\"
             \"mov %d1,_DSRPAG\;\"
             \"push SR\;\"
             \"bset SR,#5\;\"
             \"bset SR,#6\;\"
             \"bset SR,#7\;\"
             \"mov [%0],[w15]\;\"
             \"pop SR\;\"
             \"mov [%0],%0\";
   } else {
      return \"rrnc %1,%0\;\"
             \"push SR\;\"
             \"bset SR,#5\;\"
             \"bset SR,#6\;\"
             \"bset SR,#7\;\" 
             \"mov [%0],[w15]\;\"
             \"mov [%0],%0\;\"
             \"pop SR\";
   }
  "
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "writesfr_16"
  [(unspec_volatile:HI [
     (match_operand:HI 0 "pic30_register_operand" "r")
     (match_operand:HI 1 "pic30_register_operand" "r")
  ] UNSPECV_WRITESFR)]
  "(!pic30_isa32_target())"
  "push SR\;bset SR,#5\;bset SR,#6\;bset SR,#7\;mov %0,%0\;mov %0,%0\;mov %1,[%0]\;pop SR"
  [
    (set_attr "op_type" "mov")
  ]
)

(define_insn "writesfrumm_16"
  [(unspec_volatile:HI [
     (match_operand:P32UMM 0 "pic30_register_operand" "r")
     (match_operand:HI     1 "pic30_register_operand" "r")
   ] UNSPECV_WRITESFR)
   (clobber 
     (match_scratch:HI     2                        "=&r"))
  ]
  "(!pic30_isa32_target())"
  "*
   if (pic30_extended_ram_target()) {
     return \"rrnc %0,%2\;mov %d0,DSWPAG\;\"
            \"push SR\;\"
            \"bset SR,#5\;\"
            \"bset SR,#6\;\"
            \"bset SR,#7\;\"
            \"mov %2,%2\;\"
            \"mov %2,%2\;\"
            \"mov %1,[%2]\;\"
            \"pop SR\";
   } else {
     return \"rrnc %0,%2\;\"
            \"push SR\;\"
            \"bset SR,#5\;\"
            \"bset SR,#6\;\"
            \"bset SR,#7\;\"
            \"mov %2,%2\;\"
            \"mov %2,%2\;\"
            \"mov %1,[%2]\;\"
            \"pop SR\";
   }"
  [
    (set_attr "op_type" "mov")
  ]
)     

(define_insn "tbladdress_16"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r")
        (unspec:SI [
          (match_operand:HI 1 "pic30_symbolic_address_operand" "")
         ] UNSPECV_TBLADDRESS))
  ]
  "(!pic30_isa32_target())"
  "mov #tbloffset(%1),%0\;mov #tblpage(%1),%d0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_expand "tblpage_16"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (tblpage:HI 
           (match_operand 1 "pic30_symbolic_address_operand" "")))]
  ""
  "{ char *t = pic30_section_base(operands[1],1,0);
     rtx opnd = gen_rtx_CONST_STRING(Pmode, t);

     emit_insn(
       gen_tblpage_helper_16(operands[0], opnd)
     );
     DONE;
   }
  "
)

(define_insn "tblpage_helper_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (tblpage:HI 
           (match_operand 1 "pic30_string_operand"   "")))
  ]
  "(!pic30_isa32_target())"
  "*
   { static char result[256];

     const char *o1 = pic30_strip_name_encoding_helper(XSTR(operands[1], 0));
     sprintf(result,\"mov #tblpage(%s),%%0\", o1);
     return result;
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_expand "edspage_16"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (edspage:HI 
           (match_operand 1 "pic30_symbolic_address_operand" "qs")
           (match_operand 2 "immediate_operand" "i")))]
  "(!pic30_isa32_target())"
  "{ char *t = pic30_section_base(operands[1],1,0);
     rtx opnd = gen_rtx_CONST_STRING(Pmode, t);

     emit_insn(
       gen_edspage_helper_16(operands[0], opnd, operands[2])
     );
     DONE;
   }
  "
)

(define_insn "movpag_16"
  [(set (reg:HI PSVPAG)
        (edspage:HI
           (match_operand 0 "pic30_reg_or_symbolic_address" "r,qs")
           (match_operand 1 "immediate_operand"             "i,i")))]
  "pic30_ecore_target() || pic30_isav4_target()"
  "*
   {  
      if (INTVAL(operands[1])) {
        error(\"Page offset not accepted\");
        return \"cannot generate instruction\";
      }
      if (which_alternative == 1) {
        const char *t = pic30_section_base(operands[0],1,0);
        static char result[80];

        sprintf(result,\"movpag #edspage(%s),DSRPAG\", t);
        return result;
      } else {
        return \"movpag %0,DSRPAG\";
      }
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "edspage_helper_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (edspage:HI
           (match_operand 1 "pic30_string_operand"   "")
           (match_operand 2 "immediate_operand"   "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "*
   { static char result[256];
     char *e = result;
     const char *o1;

     /* immedidate operand matches a symbol_ref */
     o1 = pic30_strip_name_encoding_helper(XSTR(operands[1], 0));
     e += sprintf(result,\"mov #edspage(%s),%%0\",
                  pic30_strip_name_encoding_helper(o1));
     if (INTVAL(operands[2]))
       sprintf(e,\"\;add %%0,#%ld,%%0\", INTVAL(operands[2]));
     return result;
   }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_expand "edsoffset_16"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (edsoffset:HI
           (match_operand 1 "pic30_symbolic_address_operand" "qs")))]
  "(!pic30_isa32_target())"
  "{ char *t = pic30_section_base(operands[1],0,0);
     rtx opnd = gen_rtx_CONST_STRING(Pmode, t);

     emit_insn(
       gen_edsoffset_helper_16(operands[0], opnd)
     );
     DONE;
   }
  "
)

(define_insn "edsoffset_helper_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (edsoffset:HI
           (match_operand 1 "pic30_string_operand"   "")))]           
  "(!pic30_isa32_target())"
  "*
   { static char result[256];

     const char *o1 = pic30_strip_name_encoding_helper(XSTR(operands[1], 0));
     sprintf(result,\"mov #edsoffset(%s),%%0\", o1);
     return result;
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "tbloffset_16"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (tbloffset:HI 
           (match_operand 1 "pic30_symbolic_address_operand" "qs")))]
  "(!pic30_isa32_target())"
  "mov #tbloffset(%1),%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_expand "psvpage_16"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (psvpage:HI 
           (match_operand 1 "pic30_symbolic_address_operand" "qs")))
  ]
  "(!pic30_isa32_target())"
  "{ char *t = pic30_section_base(operands[1],0,0);
     rtx opnd = gen_rtx_CONST_STRING(Pmode, t);

     emit_insn(
       gen_psvpage_helper_16(operands[0], opnd)
     );
     DONE;
   }"
)

(define_insn "psvpage_helper_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (psvpage:HI 
           (match_operand 1 "pic30_string_operand"   "")))
  ]
  "(!pic30_isa32_target())"
  "*
   { static char result[256];

     const char *o1 = pic30_strip_name_encoding_helper(XSTR(operands[1], 0));
     sprintf(result,\"mov #psvpage(%s),%%0\", o1);
     return result;
   }"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "psvoffset_16"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (psvoffset:HI  
           (match_operand 1 "pic30_symbolic_address_operand" "qs")))
  ]
  "(!pic30_isa32_target())"
  "mov #psvoffset(%1),%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "dmaoffset_16"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (dmaoffset:HI 
          (match_operand  1 "pic30_symbolic_address_operand" "qs")))
  ]
  "(!pic30_isa32_target())"
  "mov #dmaoffset(%1),%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "dmapage_16"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (dmapage:HI 
          (match_operand  1 "pic30_symbolic_address_operand" "qs")))
  ]
  "(!pic30_isa32_target())"
  "mov #dmapage(%1),%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "addr_low_16"
  [(set (match_operand:HI 0 "pic30_register_operand"       "=r,r")
        (addr_low:HI
           (match_operand 1 "pic30_reg_or_symbolic_address" "qs,r")))]
  "(!pic30_isa32_target())"
  "@
   mov #addr_lo(%1),%0
   mov %1,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit,mov")
  ]
)

(define_insn "addr_high_16"
  [(set (match_operand:HI 0 "pic30_register_operand"       "=r,r")
        (addr_high:HI
           (match_operand 1 "pic30_reg_or_symbolic_address" "qs,r")))]
  "(!pic30_isa32_target())"
  "@
   mov #addr_hi(%1),%0
   mov %d1,%0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit,mov")
  ]
)

(define_insn "addr_long_16"
  [(set (match_operand:SI 0 "pic30_register_operand"       "=r,r")
        (addr_long:SI
           (match_operand 1 "pic30_reg_or_symbolic_address" "qs,r")))]
  "(!pic30_isa32_target())"
  "@
   mov #addr_lo(%1),%0\;mov #addr_hi(%1),%d0
   mov %1,%0\;clr %d0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "movlit,mov")
  ]
)

;;;;;;;;;;;;;;;
;; general case
;;;;;;;;;;;;;;;

(define_insn "movacchi_16"
  [(set (match_operand:HI 0 "pic30_register_operand"    "=r")
        (match_operand:HI 1 "pic30_accumulator_operand" " w"))]
  "(!pic30_isa32_target()) && pic30_integer_mac_support"
  "mov.w %m1L,%0"
)

(define_insn "movhiacc_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w")
        (match_operand:HI 1 "pic30_register_operand"    " r"))]
  "(!pic30_isa32_target()) && pic30_integer_mac_support"
  "mov.w %1,%m0L"
)

(define_insn "mov<mode>_gen_16"
  [(set (match_operand:GM16BIT 0 
           "pic30_move_operand" "=r<>, R,   r<>,R,S,S,  Q,r,r,T,a,U")
        (match_operand:GM16BIT 1
	   "pic30_move_operand" " RS<>,RS<>,r,  r,r,<>R,r,Q,T,r,U,a"))
  ]
  "(!pic30_isa32_target())"
  "*
   { 
     const char *format[] = {
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
#if 0
       /* this version clobbers CC... but marking the clobber
            causes reloads to fail */
       \"mov.w %1,WREG\",
#else
       /* this version does not clobber CC... but it is more expensive
            if only there was a way to mark a clobber selectively */
       \"mov.w #%1,w0,mov.w [w0],w0\",
#endif
       \"mov.w WREG,%0\",
       \"push %1\;pop %0\" 
     };

     return format[which_alternative];
   }"
  [
    (set_attr "cc" "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move,move") ; CAW
    (set_attr "type" 
             "defuse,use,def,etc,etc,use,etc,defuse,def,etc,def,etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "mov<mode>_gen_clobber_16"
  [(set (match_operand:GM16BIT 0 
           "pic30_move_operand" "=r<>, R,   r<>,R,S,S,  Q,r,r,T,a,U")
        (match_operand:GM16BIT 1
	   "pic30_move_operand" " RS<>,RS<>,r,  r,r,<>R,r,Q,T,r,U,a"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   { 
     const char *format[] = {
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
       \"mov.w %1,%0\",
#if 0
       /* this version clobbers CC... but marking the clobber
            causes reloads to fail */
       \"mov.w %1,WREG\",
#else
       /* this version does not clobber CC... but it is more expensive
            if only there was a way to mark a clobber selectively */
       \"mov.w #%1,w0,mov.w [w0],w0\",
#endif
       \"mov.w WREG,%0\",
       \"push %1\;pop %0\" 
     };

     return format[which_alternative];
   }"
  [
    (set_attr "cc" "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move,move") ; CAW
    (set_attr "type" 
             "defuse,use,def,etc,etc,use,etc,defuse,def,etc,def,etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "mov<mode>_gen_APSV_16"
  [(set (match_operand:SM16BIT 0 
             "pic30_move_operand"      "=r<>, R,   r<>,R,S,S,  Q,r,r,T,a")
        (unspec:SM16BIT [
          (match_operand:SM16BIT 1
	     "pic30_move_APSV_operand"  "RS<>,RS<>,r,  r,r,<>R,r,Q,T,r,U")
          (reg:HI PSVPAG)] UNSPECV_USEPSV))
   ;(clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   { 
     const char *format[] = {
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
       \"mov %1,%0\",
#if 0
       /* this version clobbers CC... but marking the clobber
            causes reloads to fail */
       \"mov.w %1,WREG\",
#else
       /* this version does not clobber CC... but it is more expensive
            if only there was a way to mark a clobber selectively */
       \"mov.w #%1,w0,mov.w [w0],w0\",
#endif
     };

     return format[which_alternative];
   }"
  [
    (set_attr "cc" "change0,change0,change0,change0,change0,change0,change0,change0,change0,change0,move") ; CAW
    (set_attr "type" 
              "defuse,use,def,use,use,use,use,defuse,def,etc,def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "movhi_address_16"
  [(set (match_operand:HI 0 "pic30_register_operand"         "=r")
        (match_operand:HI 1 "pic30_reg_or_symbolic_address"  " rqs"))
  ]
  "(!pic30_isa32_target())"
  "*
{ rtx sym;

  if (pic30_symbolic_address_operand(operands[1], GET_MODE(operands[1]))) {
    /* this can be converted to a register copy, so check for symref first */
    sym = pic30_program_space_operand_p(operands[1]);
    if (sym) {
      tree fndecl = GET_CODE(sym) == SYMBOL_REF ? SYMBOL_REF_DECL(sym) : 0;
      tree fndecl_attrib;
      const char *access=0;
      int slot = 0;

      if (fndecl) {
        if ((fndecl_attrib =
              pic30_lookup_attribute(IDENTIFIER_POINTER(pic30_identBoot[0]),
                               DECL_ATTRIBUTES(fndecl)))) {
          access=\"boot\";
        } else if ((fndecl_attrib = pic30_lookup_attribute(
                                    IDENTIFIER_POINTER(pic30_identSecure[0]),
                                    DECL_ATTRIBUTES(fndecl)))) {
          access=\"secure\";
        }
      }
      if (access) {
        if (TREE_VALUE(fndecl_attrib)) {
          if (TREE_CODE(TREE_VALUE(TREE_VALUE(fndecl_attrib))) == INTEGER_CST) {
            slot = TREE_INT_CST_LOW(TREE_VALUE(TREE_VALUE(fndecl_attrib)));
          } else access = 0;
        } else access = 0;
      }
      if (access) {
        static char buffer[25];
        sprintf(buffer,\"mov #%s(%d),%%0\", access, slot);
        return buffer;
      } else {
        return \"mov #handle(%1),%0\";
      }
    } else {
      return \"mov #%1,%0\";
    }
  } else return \"mov %1,%0\";
}"
 [
  (set_attr "cc" "change0")
  (set_attr "type" "def")
  (set_attr "op_type" "mov")
 ]
)


;; If one of the operands is immediate and the other is not a register,
;; then we should emit two insns, using a scratch register.  This will produce
;; better code in loops if the source operand is invariant, since
;; the source reload can be optimised out.  During reload we cannot
;; use change_address or force_reg which will allocate new pseudo regs.

;; Unlike most other insns, the move insns can`t be split with
;; different predicates, because register spilling and other parts of
;; the compiler, have memoized the insn number already.

(define_expand "movhi_16"
  [(set (match_operand:HI 0 "pic30_move_operand" "")
        (match_operand:HI 1 "pic30_move_operand" ""))
  ]
  "(!pic30_isa32_target())"
  "{
     rtx op;

     /* sometimes get here from emit_move_insn even though the rhs is
      * an add or something.  we need to handle it now that there are
      * potential clobbers of the CC
      *
      * pic30_emit_move_sequence may update operands */
     if (pic30_emit_move_sequence(operands, HImode)) DONE;

     op = operands[1];

     while (GET_CODE(op) == CONST) op = XEXP(op,0);
     switch (GET_CODE(op)) {
       default: gcc_assert(0);
       case PLUS: {
         rtx op1 = XEXP(op,0);
         rtx op2 = XEXP(op,1);
         if (GET_CODE(op1) != SYMBOL_REF) {
           if (!pic30_JMmath_operand(op1,HImode)) {
             op1 = force_reg(HImode,op1);
           }
           if (!pic30_JMmath_operand(op2,HImode)) {
             op2 = force_reg(HImode,op2);
           }
           emit(
             gen_addhi3_16(operands[0], op1, op2)
           );
           DONE;
         }
         /* handle SYMBOL_REF below */
       }
       /* FALLSTHROUGH */
       case CONST_INT:
         if (GET_CODE(op) == CONST_INT) {
           if (GET_CODE(operands[0]) == REG) {
             emit(
               gen_movhi_imm_16(operands[0],operands[1])
             );
             DONE;
           } else {
             if (pic30_mode2_operand(operands[0], GET_MODE(operands[0]))) {
               if (INTVAL(operands[1]) == 0) {
                 emit(
                   gen_movhi_const0_16(operands[0])
                 );
                 DONE;
               } else if (INTVAL(operands[1]) == -1) {
                 emit(
                   gen_movhi_const1_16(operands[0])
                 );
                 DONE;
               }
             } else if (pic30_near_operand(operands[0], GET_MODE(operands[0]))) {
               if (INTVAL(operands[1]) == 0) {
                 emit(
                   gen_movhi_const0sfr_16(operands[0])
                 );
                 DONE;
               } else if (INTVAL(operands[1]) == -1) {
                 emit(
                   gen_movhi_const1sfr_16(operands[0])
                 );
                 DONE;
               }
             } else if (can_create_pseudo_p()) {
               rtx r = force_reg(GET_MODE(operands[0]), op);
               emit(
                 gen_movhi_gen_16(operands[0],r)
               );
               DONE;
             }
           }
           break;
         }
         /* FALLSTHROUGH */
       case SUBREG:
       case REG:
       case LABEL_REF:
       case SYMBOL_REF:
       case MEM:
         if (pic30_positive_symbolic_address_operand(operands[1],HImode)) {
           emit(
             gen_movhi_address_16(operands[0],operands[1])
           );
           DONE;
         } 
         if (pic30_negative_symbolic_address_operand(operands[1],HImode)) {
           emit(
             gen_movhi_address_16(operands[0],XEXP(op,0))
           );
           emit(
             gen_addhi3_16(operands[0],operands[0],XEXP(op,1))
           );
           DONE;
         } 
         if (pic30_reload_in_progress() ||
             (pic30_move_operand(operands[0],HImode) &&
              pic30_move_operand(operands[1],HImode))) {
           emit(
             gen_movhi_gen_16(operands[0],operands[1])
           );
           DONE;
         }
         break;
     }
   }
#if 0
  { 
    if (pic30_emit_move_sequence(operands, HImode)) DONE;
    if (pic30_move_operand(operands[0],HImode) &&
        pic30_move_operand(operands[1],HImode)) {
      emit(
        gen_movhi_gen_16(operands[0],operands[1])
      );
      DONE;
    }
  }
#endif
  "
)



(define_expand "movp16apsv_16"
  [(set (match_operand:P16APSV 0 "pic30_move_operand" "")
        (match_operand:P16APSV 1 "pic30_move_operand" ""))
  ]
  "(!pic30_isa32_target())"
  "
{ int result = pic30_emit_move_sequence(operands, P16APSVmode);

  if (result > 0) DONE;
}")

;;
;; Reload can generate a partial load of a larger item
;;   Recognize the instruction. - Bug in nullstone cse -O[23]
;;

(define_insn "movhi_reload_lo_16"
  [(set (match_operand:HI    0 "pic30_move_operand" "=r,RS,r,R,T,r")
        (subreg:HI 
           (match_operand:SI 1 "pic30_move_operand" " r,r,RS,R,r,T") 0))
  ]
  "(!pic30_isa32_target())"
  "@
   mov.w %1,%0
   mov.w %1,%0
   mov.w %1,%0
   mov.w %1,%0
   mov.w %1,%0
   mov.w %1,%0"
  [
    (set_attr "cc" "change0,change0,change0,change0,change0,change0") ; CAW
    (set_attr "type" "def,use,defuse,use,etc,def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "movhi_reload_hi_16"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand"   "=r")
        (subreg:HI 
           (match_operand:SI 1 "pic30_UT_operand" "UT") 2))
  ]
  "(!pic30_isa32_target())"
  "mov.w %1+2,%0"
  [
   (set_attr "cc" "change0") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "mov")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 24-bit moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
(define_expand "movp24prog_address_16"
  [(set 
     (match_operand:P24PROG 0 "pic30_move_operand"             "=r,R,<>,QSTU")
     (match_operand:P24PROG 1 "pic30_symbolic_address_operand" " qs,qs,qs ,qs"))
  ]
  "(!pic30_isa32_target())"
  "
{
  rtx op2 = 0;

  if (!pic30_reload_in_progress()) op2 = gen_reg_rtx(GET_MODE(operand0));
  emit_insn(
    gen_tbloffset_16(
      simplify_gen_subreg(HImode, op2 ? op2 : operand0, GET_MODE(operand0), 0), 
      operand1)
  );
  emit_insn(
    gen_tblpage_16(
      simplify_gen_subreg(HImode, op2 ? op2 : operand0, GET_MODE(operand0), 2),
      operand1)
  );
  if (op2) 
    emit_insn(
      gen_movp24prog_gen_16(operand0,op2)
    );
  DONE;
}")

;
; for RAW scheduling variants 2-4 are not "uses" because the 1st instruction
;   would not cause a stall
;
(define_insn_and_split "movp24psv_address_16"
  [(set (match_operand:P24PSV 0 "pic30_move_operand"             "=r,R,<>,Q,TU")
        (match_operand:P24PSV 1 "pic30_symbolic_address_operand" " qs,qs,qs,qs,qs")
   )
   (clobber (match_scratch:HI 2                                  "=X,&r,&r,&r,&r"))]
  "(!pic30_isa32_target())"
  "@
   mov #tbloffset(%1),%0\;mov #tblpage(%1),%d0
   mov #tbloffset(%1),%2\;mov %2,%I0\;mov #tblpage(%1),%2\;mov %2,%D0
   mov #tbloffset(%1),%2\;mov %2,%0\;mov #tblpage(%1),%2\;mov %2,%0
   mov #tbloffset(%1),%2\;mov %2,%0\;mov #tblpage(%1),%2\;mov %2,%Q0
   mov #tbloffset(%1),%2\;mov %2,%0\;mov #tblpage(%1),%2\;mov %2,%0+2"
  "reload_completed && REG_P(operands[0]) && (!pic30_isa32_target())"
  [(set (match_operand:HI 3 "pic30_register_operand" "=r")
        (tblpage:HI (match_operand 4 "pic30_string_operand" "")))
   (set (match_operand:HI 5 "pic30_register_operand" "=r")
        (tbloffset:HI (match_dup 1)))]
  "operands[3] = gen_rtx_REG(HImode, REGNO(operands[0])+1);
   operands[4] = gen_rtx_CONST_STRING(Pmode,
                                      pic30_section_base(operands[1],1,0));
   operands[5] = gen_rtx_REG(HImode, REGNO(operands[0]));"
  [
    (set_attr "type" "def,etc,etc,etc,etc")
    (set_attr "op_type" "mov")
  ]
)  

;
; for RAW scheduling variants 2-4 are not "uses" because the 1st instruction
;   would not cause a stall
;
(define_insn "movp16pmp_address_16"
  [(set (match_operand:P16PMP 0 "pic30_move_operand"             "=r,R,<>,QSTU")
        (match_operand:P16PMP 1 "pic30_symbolic_address_operand" " qs,qs,qs ,qs"))
   (clobber (match_scratch:HI 2                                  "=X,&r,&r,&r"))
  ]
  "(!pic30_isa32_target())"
  "*
   { static char result[256];

     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: sprintf(result,\"mov #%%1,%%0\");
               break;
       case 1: sprintf(result,\"mov #%%1,%%2\;mov %%2,%%0\");
               break;
       case 2: sprintf(result,\"mov #%%1,%%2\;mov %%2,%%0\");
               break;
       case 3: sprintf(result,\"mov #%%1,%%2\;mov %%2,%%0\");
               break;
     }
     return result;
   }
  "
  [
    (set_attr "type" "def,etc,etc,etc")
    (set_attr "op_type" "mov")
  ]
)

;
; for RAW scheduling variants 2-4 are not "uses" because the 1st instruction
;   would not cause a stall
;
(define_insn "movEDS_address_page_16"
  [(set (match_operand:HI     0 "pic30_move_operand"    "=r,R,<>,QSTU")
        (edspage: HI
          (match_operand     1 "pic30_string_operand"   "")
          (match_operand     2 "immediate_operand"      " i,i,i,i"))
   )
   (clobber (match_scratch:HI 3                      "=X,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   { static char result[256];
     const char *o1 = pic30_strip_name_encoding_helper(XSTR(operands[1], 0));
     char *e = result;
     int excess = 0;
     
     if (INTVAL(operands[2]) != 0) {
       /* an excess was specified */
       excess = INTVAL(operands[2]);
     }
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: e += sprintf(result,\"mov #edspage(%s),%%0\", o1);
               if (excess) sprintf(e,\"\;add %%0,#%d,%%0\", excess);
               break;
       case 1: if (excess) 
                 sprintf(result, \"mov #edspage(%s),%%3\;add %%3,#%d,%%0\",
                         o1, excess);
               else
                 sprintf(result, \"mov #edspage(%s),%%3\;mov %%3,%%0\", o1);
               break;
       case 2: if (excess) 
                 sprintf(result, \"mov #edspage(%s),%%3\;add %%3,#%d,%%0\",
                         o1, excess);
               else
                 sprintf(result, \"mov #edspage(%s),%%3\;mov %%3,%%0\",o1);
               break;
       case 3: if (excess) 
                 sprintf(result, \"mov #edspage(%s),%%3\;add %%3,#%d,%%3\;\"
                                 \"mov %%3,%%0\", o1, excess);
               else
                 sprintf(result, \"mov #edspage(%s),%%3\;mov %%3,%%0\",o1);
               break;
     }
     return result;
   }
  "
  [
    (set_attr "type" "def,etc,etc,etc")
    (set_attr "op_type" "mov")
  ]
)

;
; for RAW scheduling variants 2-4 are not "uses" because the 1st instruction
;   would not cause a stall
;
(define_insn "movEDS_address_offset_16"
  [(set (match_operand:HI     0 "pic30_move_operand" "=r,R,<>,QSTU")
        (edsoffset: HI
          (match_operand      1 "pic30_string_operand"  ""))
   )
   (clobber (match_scratch:HI 2                      "=X,&r,&r,&r"))
  ]
  "(!pic30_isa32_target())"
  "*
   { static char result[256];
     const char *o1 = pic30_strip_name_encoding_helper(XSTR(operands[1], 0));

     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: sprintf(result,\"mov #edsoffset(%s),%%0\", o1);
               break;
       case 1: sprintf(result,\"mov #edsoffset(%s),%%2\;mov %%2,%%0\", o1);
               break;
       case 2: sprintf(result,\"mov #edsoffset(%s),%%2\;mov %%2,%%0\", o1);
               break;
       case 3: sprintf(result,\"mov #edsoffset(%s),%%2\;mov %%2,%%0\", o1);
               break;
     }
     return result;
   }
  "
  [
    (set_attr "type" "def,etc,etc,etc")
    (set_attr "op_type" "mov")
  ]
)

(define_expand "movp32eds_address_16"
  [(set (match_operand:P32EDS 0 "pic30_move_operand"             "=r,R,<>,QSTU")
        (match_operand:P32EDS 1 "pic30_symbolic_address_operand" " qs,qs,qs ,qs")
   )
  ]
  "(!pic30_isa32_target())"
  "{ rtx excess;
     char *t = pic30_section_base(operands[1],0,&excess);
     rtx opnd = gen_rtx_CONST_STRING(Pmode, t);
     emit_insn(
       gen_movEDS_address_offset_16(
         simplify_gen_subreg(HImode, operands[0], GET_MODE(operands[0]), 0),
         opnd)
     );
     t = pic30_section_base(operands[1],1,&excess);
     opnd = gen_rtx_CONST_STRING(Pmode, t);
     if (pic30_register_operand(operands[0], P32EDSmode)) {
       emit_insn(
         gen_edspage_helper_16(
           simplify_gen_subreg(HImode, operands[0], GET_MODE(operands[0]), 2),
           opnd, excess)
       );
     } else {
       emit_insn(
         gen_movEDS_address_page_16(
           simplify_gen_subreg(HImode, operands[0], GET_MODE(operands[0]), 2),
           opnd, excess)
       );
     }
     DONE;
   }
  "
)

(define_expand "movp32peds_address_16"
  [(set (match_operand:P32PEDS 0 "pic30_move_operand"            "=r,R,<>,QSTU")
        (match_operand:P32PEDS 1 "pic30_symbolic_address_operand" "qs,qs,qs, qs")
   )
  ]
  "(!pic30_isa32_target())"
  "{ char *t = pic30_section_base(operands[1],0,0);
     rtx opnd = gen_rtx_CONST_STRING(Pmode, t);
     emit_insn(
       gen_movEDS_address_offset_16(
         simplify_gen_subreg(HImode, operands[0], GET_MODE(operands[0]), 0),
         opnd)
     );
     t = pic30_section_base(operands[1],1,0);
     opnd = gen_rtx_CONST_STRING(Pmode, t);
     emit_insn(
       gen_movEDS_address_page_16(
         simplify_gen_subreg(HImode, operands[0], GET_MODE(operands[0]), 2),
         opnd, GEN_INT(0))
     );
     DONE;
   } 
  "
)

(define_insn "movp32df_address_16"
  [(set (match_operand:P32DF 0 "pic30_move_operand"             "=r")
        (match_operand:P32DF 1 "pic30_symbolic_address_operand"  "qs")
   )
  ]
  "(!pic30_isa32_target())"
  "mov #packed_lo(%1),%0\;mov #packed_hi(%1),%d0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_expand "movp32ext_address_16"
  [(set (match_operand:P32EXT 0 "pic30_move_operand"             "=rR<>QSTU")
        (match_operand:P32EXT 1 "pic30_symbolic_address_operand" " qs"))]
  "(!pic30_isa32_target())"
  "{
     if (pic30_address_of_external(operands[0],operands[1])) {
       DONE;
     } else FAIL;
   }
  "
)

(define_expand "movp32umm_address_16"
  [(set (match_operand:P32UMM 0 "pic30_register_operand"         "=r")
        (match_operand:P32UMM 1 "pic30_symbolic_address_operand"  "qs")
   )
  ]
  ""
  "{
     rtx x = operands[1];
     rtx val = operands[1];
     rtx offset = NULL_RTX;
     while (GET_CODE(x) == CONST) x = XEXP(x,0);
     if (GET_CODE(x) == PLUS) {
       // ensure we are adding a positive value
       // relocations cannot be negative
       offset = XEXP(x,1);
 
       if ((GET_CODE(offset) == CONST_INT) && 
           ((INTVAL(offset) < 0) || (INTVAL(offset) > 32768))) {
         gcc_assert(!(pic30_reload_in_progress() || reload_completed));
         val = XEXP(x,0);
         x = gen_reg_rtx(P32UMMmode);
         emit(
           gen_movp32umm_sym_address_16(x,val)
         );
         emit(
           gen_addp32umm3_16(operands[0],x,offset)
         );
         DONE;
       }
     }
     emit(
       gen_movp32umm_sym_address_16(operands[0],operands[1])
     );
     DONE;
   }"
)

(define_insn "reload_large_addrp32umm_16"
 [
  (set (match_operand:P32UMM 0 "pic30_register_operand"        "=&r")
       (match_operand:P32UMM 1 "pic30_symbolic_address_operand" " qs"))
  (clobber (match_operand:HI 2 "pic30_register_operand"        "=&r"))
  (clobber (reg:CC_NZC CC_REG))
 ]
 ""
 "*
  rtx val,offset,x = operands[1];
  static char buffer[512];
  char *c;
  const char *sym;
  int offset_val;

  while (GET_CODE(x) == CONST) x = XEXP(x,0);
  if (GET_CODE(x) == PLUS) {
    offset = XEXP(x,1);
    offset_val = INTVAL(offset);

    val = XEXP(x,0);
    sym = pic30_strip_name_encoding(XSTR(val,0));
    if ((GET_CODE(offset) == CONST_INT) &&
        ((offset_val < 0) || (offset_val > 32768))) {
      c = buffer;
      c += sprintf(c,\"mov #unified_lo(_%s),%%0\;\"
                     \"mov #unified_hi(_%s),%%d0\;\"
                     \"mov #%d,%%2\;\"
                     \"add %%0,%%2,%%0\;\"
                     \"mov #%d,%%2\;\"
                     \"bset _SR,#1\;\"
                     \"addc %%d0,%%2,%%d0\;\"
                     \"btss _SR,#1\;\"
                     \"bset %%0,#0\",
                   sym,sym,
                   (offset_val << 1) & 0xFFFF,
                   (offset_val >> 15) & 0xFFFF);
      return buffer;
    }
  }
  return \"mov #unified_lo(%1),%0\;mov #unified_hi(%1),%d0\";
 "
)

(define_insn "movp32umm_sym_address_16"
  [(set (match_operand:P32UMM 0 "pic30_register_operand"                  "=r")
        (match_operand:P32UMM 1 "pic30_positive_symbolic_address_operand"  "qs")
   )
  ]
  ""
  "mov #unified_lo(%1),%0\;mov #unified_hi(%1),%d0"
  [
    (set_attr "type" "def")
  ]
)

(define_mode_iterator M32BIT_CLASSIC_PLUS [P16PMP P24PSV P24PROG P32EDS P32PEDS P32DF P32EXT P32UMM])

(define_expand "mov<mode>_16"
  [(set (match_operand:M32BIT_CLASSIC_PLUS 0 "pic30_general_operand" "")
        (match_operand:M32BIT_CLASSIC_PLUS 1 "pic30_general_operand" ""))]
  "(!pic30_isa32_target())"
  "{
     rtx op;

     /* sometimes get here from emit_move_insn even though the rhs is
      * an add or something.  we need to handle it now that there are
      * potential clobbers of the CC 
      *
      * pic30_emit_move_sequence may update operands */
     if (pic30_emit_move_sequence(operands, <MODE>mode)) DONE;

     op = operands[1];

     while (GET_CODE(op) == CONST) op = XEXP(op,0);
     switch (GET_CODE(op)) {
       default: gcc_assert(0);
       case PLUS: {
         rtx op1 = XEXP(op,0);
         rtx op2 = XEXP(op,1);
         if (GET_CODE(op1) != SYMBOL_REF) {
           if (pic30_register_operand(operands[0],<MODE>mode) &&
               pic30_register_operand(op1,<MODE>mode)) {
             emit(
               gen_add<mode>3_16(operands[0], op1, op2)
             );
             DONE;
           }
         }
         /* handle SYMBOL_REF below ... */
       }
       /* FALLSTHROUGH */
       case CONST_INT:
         if (GET_CODE(op) == CONST_INT) {
           if (GET_CODE(operands[0]) == REG) {
             emit(
               gen_mov<mode>_lit_16(operands[0],operands[1])
             );
             DONE;
           } else { 
             if (can_create_pseudo_p()) {
               rtx r = force_reg(GET_MODE(operands[0]), op);
               emit(
                 gen_mov<mode>_gen_16(operands[0],r)
               );
               DONE;
             }
           }
           break;
         }
         /* FALLSTHROUGH */
       case SUBREG:
       case REG:
       case SYMBOL_REF:
       case MEM:
         if (pic30_reload_in_progress() ||
             (pic30_move_operand(operands[0],<MODE>mode) &&
              pic30_move_operand(operands[1],<MODE>mode))) {
           emit(
             gen_mov<mode>_gen_16(operands[0],operands[1])
           );
           DONE;
         }
         break;
     }
   }"
)

;;;(define_expand "movp24prog_16"
;;;  [(set (match_operand:P24PROG 0 "pic30_general_operand" "")
;;;        (match_operand:P24PROG 1 "pic30_general_operand" ""))]
;;;  "(!pic30_isa32_target())"
;;;  "
;;;  {
;;;     if (pic30_emit_move_sequence(operands, P24PROGmode)) DONE;
;;;  }"
;;;)
;;;
;;;(define_expand "movp24psv_16"
;;;  [(set (match_operand:P24PSV 0 "pic30_general_operand" "")
;;;        (match_operand:P24PSV 1 "pic30_general_operand" ""))]
;;;  "(!pic30_isa32_target())"
;;;  "
;;;  {
;;;    if (pic30_emit_move_sequence(operands, P24PSVmode)) DONE;
;;;  }"
;;;)
;;;
;;;(define_expand "movp16pmp_16"
;;;  [(set (match_operand:P16PMP 0 "pic30_general_operand" "")
;;;        (match_operand:P16PMP 1 "pic30_general_operand" ""))]
;;;  ""
;;;  "
;;;  {
;;;    if (pic30_emit_move_sequence(operands, P16PMPmode)) DONE;
;;;  }"
;;;)
;;;
;;;(define_expand "movp32eds_16"
;;;  [(set (match_operand:P32EDS 0 "pic30_general_operand" "")
;;;        (match_operand:P32EDS 1 "pic30_general_operand" ""))]
;;;  "(!pic30_isa32_target())"
;;;  "
;;;  {
;;;    if (pic30_emit_move_sequence(operands, P32EDSmode)) DONE;
;;;  }"
;;;)
;;;
;;;(define_expand "movp32peds_16"
;;;  [(set (match_operand:P32PEDS 0 "pic30_general_operand" "")
;;;        (match_operand:P32PEDS 1 "pic30_general_operand" ""))]
;;;  "(!pic30_isa32_target())"
;;;  "
;;;  {
;;;    if (pic30_emit_move_sequence(operands, P32PEDSmode)) DONE;
;;;  }"
;;;)
;;;
;;;(define_expand "movp32df_16"
;;;  [(set (match_operand:P32DF 0 "pic30_general_operand" "")
;;;        (match_operand:P32DF 1 "pic30_general_operand" ""))]
;;;  "(!pic30_isa32_target())"
;;;  "
;;;  {
;;;    if (pic30_emit_move_sequence(operands, P32DFmode)) DONE;
;;;  }"
;;;)
;;;
;;;(define_expand "movp32ext_16"
;;;  [(set (match_operand:P32EXT 0 "pic30_general_operand" "")
;;;        (match_operand:P32EXT 1 "pic30_general_operand" ""))]
;;;  "(!pic30_isa32_target())"
;;;  "
;;;  {
;;;    if (pic30_emit_move_sequence(operands, P32EXTmode)) DONE;
;;;  }"
;;;)
;;;
;;;(define_expand "movp32umm_16"
;;;  [(set (match_operand:P32UMM 0 "pic30_general_operand" "")
;;;        (match_operand:P32UMM 1 "pic30_general_operand" ""))]
;;;  "(!pic30_isa32_target())"
;;;  "
;;;  {
;;;    if (pic30_emit_move_sequence(operands, P32UMMmode)) DONE;
;;;  }"
;;;)

(define_insn "set_vpsv_16"
   [(set (reg:HI PSVPAG)
         (unspec_volatile: HI
           [(match_operand:HI 0 "pic30_register_operand" "r")] UNSPECV_SETPSV))]
   "(!pic30_isa32_target())"
   "*
    {
      if (pic30_ecore_target() ||
          pic30_isav4_target()) return \"movpag %0,DSRPAG\";
      if (pic30_eds_target()) return \"mov %0,_DSRPAG\";
      return \"mov %0,_PSVPAG\";
    }"
   [
     (set_attr "type" "etc")
     (set_attr "op_type" "mov")
   ]
)

(define_insn "assert_psv_16"
   [(set (reg:HI PSVPAG)
            (match_operand:HI 0 "pic30_register_operand" "r"))
    (clobber (match_operand:HI 1 "pic30_register_operand" "=B"))]
   "(!pic30_isa32_target())"
   "
   \; assert PSV page"
   [
     (set_attr "type" "etc")
   ]
)

(define_insn "set_nvpsv_16"
   [(set (reg:HI PSVPAG)
         (match_operand:HI 0 "pic30_register_operand" "r"))]
   "(!pic30_isa32_target())"
   "*
    {
      if (pic30_ecore_target() ||
          pic30_isav4_target()) return \"movpag %0,DSRPAG\";
      if (pic30_eds_target()) return \"mov %0,_DSRPAG\";
      return \"mov %0,_PSVPAG\";
    }"
   [
     (set_attr "type" "etc")
     (set_attr "op_type" "mov")
   ]
)

(define_insn "set_unpsv_16"
   [(set (reg:HI PSVPAG)
         (subreg:HI
            (match_operand:P32PEDS 0 "pic30_register_operand" "r") 2))]
   "(!pic30_isa32_target())"
   "*
    {
      if (pic30_ecore_target() ||
          pic30_isav4_target()) return \"movpag %d0,DSRPAG\";
      if (pic30_eds_target()) return \"mov %d0,_DSRPAG\";
      return \"mov %d0,_PSVPAG\";
    }"
   [
     (set_attr "type" "etc")
     (set_attr "op_type" "mov")
   ]
)

(define_insn "set_unpsv2_16"
   [(set (reg:HI PSVPAG)
         (subreg:HI
            (plus:P32EDS
               (match_operand:P32PEDS 0 "pic30_register_operand" "r")
               (match_operand:P32PEDS 1 "immediate_operand"      "i")) 2))]
   "(!pic30_isa32_target())"
   "*
    {
      if (pic30_ecore_target() ||
          pic30_isav4_target()) return \"movpag %d0,DSRPAG\";
      if (pic30_eds_target()) return \"mov %d0,_DSRPAG\";
      return \"mov %d0,_PSVPAG\";
    }"
   [
     (set_attr "type" "etc")
     (set_attr "op_type" "mov")
   ]
)

(define_expand "set_psv_16"
  [(set (reg:HI PSVPAG)
        (match_operand:HI 0 "pic30_register_operand" "r"))]
  "(!pic30_isa32_target())"
  "
   if (TARGET_TRACK_PSVPAG) {
     set_psv_called=1;
     emit_insn(
       gen_set_nvpsv_16(operand0)
     );
   } else {
     emit_insn(
       gen_set_vpsv_16(operand0)
     );
   }
   DONE;
  "
)

(define_insn "set_vdsw_16"
   [(set (reg:HI DSWPAG)
         (unspec_volatile: HI
           [(match_operand:HI 0 "pic30_register_operand" "r")] 
           UNSPECV_SETDSW))]
   "pic30_eds_target()"
   "mov %0,_DSWPAG"
   [
     (set_attr "type" "etc")
     (set_attr "op_type" "mov")
   ]
)

(define_insn "set_nvdsw_16"
   [(set (reg:HI DSWPAG)
         (match_operand:HI 0 "pic30_register_operand" "r"))]
         
   "pic30_eds_target()"
   "mov %0,_DSWPAG"
   [
     (set_attr "type" "etc")
     (set_attr "op_type" "mov")
   ]
)

(define_expand "set_dsw_16"
   [(set (reg:HI DSWPAG)
         (match_operand:HI 0 "pic30_register_operand" "r"))]
   "pic30_eds_target()"
   "
   if (TARGET_TRACK_PSVPAG) {
     emit_insn(
       gen_set_nvdsw_16(operand0)
     );
   } else {
     emit_insn(
       gen_set_vdsw_16(operand0)
     );
   }
   DONE;
")

(define_insn "copy_psv_16"
   [(set (match_operand:HI 0 "pic30_register_operand" "=r")
         (reg:HI PSVPAG))]
   "(!pic30_isa32_target())"
   "*
    {
      if (pic30_eds_target() || pic30_isav4_target()) return \"mov _DSRPAG,%0\";
      return \"mov _PSVPAG,%0\";
    }"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "copy_dsw_16"
   [(set (match_operand:HI 0 "pic30_register_operand" "=r")
         (reg:HI DSWPAG))]
   "pic30_eds_target()"
   "mov _DSWPAG,%0"
   [
     (set_attr "type" "def")
     (set_attr "op_type" "mov")
   ]
)

(define_insn "set_PMADDR_DATA_16"
  [(set (reg:P16PMP PMADDR)
        (match_operand: P16PMP 0 "pic30_mode2_operand" "r,R<>"))]
  "(!pic30_isa32_target())"
  "@
   mov %0,_PMADDR
   push %0\;pop _PMADDR"
  [
    (set_attr "type" "etc,use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "set_PMADDR_APSV_16"
  [(set (reg:P16PMP PMADDR)
        (match_operand: P16PMP 0 "pic30_mode2_APSV_operand" "r,R<>"))]
  "(!pic30_isa32_target())"
  "@
   mov %0,_PMADDR
   push %0\;pop _PMADDR"
  [
    (set_attr "type" "etc,use")
    (set_attr "op_type" "mov")
  ]
)

(define_expand "set_PMADDR_16"
  [(set (reg:P16PMP PMADDR)
        (match_operand: P16PMP 0 "pic30_mode2_APSV_operand" "r,R<>"))]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_operand(operands[0], GET_MODE(operands[0]))) 
    emit(gen_set_PMADDR_DATA_16(operands[0]));
  else
    emit(gen_set_PMADDR_APSV_16(operands[0]));
  DONE;
}")

(define_insn "while_PMMODE_busy_16"
  [
   (unspec_volatile:HI  [(const_int 0)] UNSPECV_WHILEPMMODE)
   (use (reg:P16PMP PMADDR))
  ]
  "(!pic30_isa32_target())"
  "btsc _PMMODE, #15\;bra . - 2"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "bitset_PMMODE_16"
  [ 
   (set (reg:HI PMMODE)
        (unspec_volatile:HI 
          [(reg:HI PMMODE)
           (match_operand 0 "const_int_operand"      "i")] UNSPECV_SETPMMODE))
  ]
  "((INTVAL(operands[0]) >= 0) && (INTVAL(operands[0]) <= 15))"
  "bset _PMMODE,#%0"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "bitclr_PMMODE_16"
  [ 
   (set (reg:HI PMMODE)
        (unspec_volatile:HI 
          [(reg:HI PMMODE)
           (match_operand 0 "const_int_operand"      "i")] UNSPECV_CLRPMMODE))
   (clobber (reg:P16PMP PMADDR))
  ]
  "((INTVAL(operands[0]) >= 0) && (INTVAL(operands[0]) <= 15))"
  "bclr _PMMODE,#%0"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "get_PMDIN1qi_16"
  [
   (set (match_operand:QI 0 "pic30_mode2_operand" "=r,R<>")
        (unspec_volatile:QI [ (reg:QI PMDIN1)
                              (reg:P16PMP PMADDR) ] UNSPECV_PMDIN1RD))
  ]
  "(!pic30_isa32_target())"
  "@
   mov _PMDIN1,%0
   push _PMDIN1\;pop %0"
  [
    (set_attr "type" "def,etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "get_PMDIN1hi_16"
  [
   (set (match_operand: HI 0 "pic30_mode2_operand" "=r,R<>")
        (unspec_volatile:HI [ (reg:HI PMDIN1)
                              (reg:P16PMP PMADDR) ] UNSPECV_PMDIN1RD))
  ]
  "(!pic30_isa32_target())"
  "@
   mov _PMDIN1,%0
   push _PMDIN1\;pop %0"
  [
    (set_attr "type" "def,etc")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "set_PMDIN1qi_DATA_16"
  [
   (set (reg:QI PMDIN1)
        (unspec_volatile:QI [ 
          (match_operand:QI 0 "pic30_mode2_operand" "r,R<>")
          (reg:P16PMP PMADDR) 
        ] UNSPECV_PMDIN1WT))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %0,_PMDIN1
   push %0\;pop _PMDIN1"
  [
    (set_attr "type" "etc,use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "set_PMDIN1qi_APSV_16"
  [
   (set (reg:QI PMDIN1)
        (unspec_volatile:QI [ 
          (match_operand:QI 0 "pic30_mode2_APSV_operand" "r,R<>")
          (reg:P16PMP PMADDR) 
        ] UNSPECV_PMDIN1WT))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %0,_PMDIN1
   push %0\;pop _PMDIN1"
  [
    (set_attr "op_type" "mov")
  ]
)

(define_expand "set_PMDIN1qi_16"
  [
   (set (reg:QI PMDIN1)
        (unspec_volatile:QI [
          (match_operand:QI 0 "pic30_mode2_APSV_operand" "r,R<>")
          (reg:P16PMP PMADDR)
        ] UNSPECV_PMDIN1WT))
  ]
  "(!pic30_isa32_target())"
  "
  {
    if (pic30_mode2_operand(operands[0], GET_MODE(operands[0]))) 
      emit(gen_set_PMDIN1qi_DATA_16(operands[0]));
    else
      emit(gen_set_PMDIN1qi_APSV_16(operands[0]));
    DONE;
  }"
)

(define_insn "set_PMDIN1hi_DATA_16"
  [
   (set (reg:HI PMDIN1)
        (unspec_volatile:HI [ 
          (match_operand:HI 0 "pic30_mode2_operand" "r,R<>")
          (reg:P16PMP PMADDR) 
        ] UNSPECV_PMDIN1WT))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %0,_PMDIN1
   push %0\;pop _PMDIN1"
  [
    (set_attr "type" "etc,use")
    (set_attr "op_type" "mov")
  ]
) 

(define_insn "set_PMDIN1hi_APSV_16"
  [
   (set (reg:HI PMDIN1)
        (unspec_volatile:HI [ 
          (match_operand:HI 0 "pic30_mode2_APSV_operand" "r,R<>")
          (reg:P16PMP PMADDR) 
        ] UNSPECV_PMDIN1WT))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %0,_PMDIN1
   push %0\;pop _PMDIN1"
  [
    (set_attr "type" "etc,use")
    (set_attr "op_type" "mov")
  ]
) 

(define_expand "set_PMDIN1hi_16"
  [
   (set (reg:HI PMDIN1)
        (unspec_volatile:HI [
          (match_operand:HI 0 "pic30_mode2_APSV_operand" "r,R<>")
          (reg:P16PMP PMADDR)
        ] UNSPECV_PMDIN1WT))
  ]
  "(!pic30_isa32_target())"
  "
  {
    if (pic30_mode2_operand(operands[0], GET_MODE(operands[0]))) 
      emit(gen_set_PMDIN1hi_DATA_16(operands[0]));
    else
      emit(gen_set_PMDIN1hi_APSV_16(operands[0]));
    DONE;
  }"
)

(define_insn "rotlhi_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"   "=r,r,  R<>,R<>")
        (rotate:HI 
           (match_operand:HI 1 "pic30_mode2_operand" "r,R<>,r,  R<>")
           (const_int 1)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   rlnc.w %1,%0
   rlnc.w %1,%0
   rlnc.w %1,%0
   rlnc.w %1,%0"
  [ 
    (set_attr "cc" "math")  ; CAW
    (set_attr "type" "etc,defuse,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "rotlhi_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"       "=r,r,  R<>,R<>")
        (rotate:HI 
          (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,R<>,r,  R<>")
          (const_int 1)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   rlnc.w %1,%0
   rlnc.w %1,%0
   rlnc.w %1,%0
   rlnc.w %1,%0"
  [ 
    (set_attr "cc" "math")  ; CAW
    (set_attr "type" "def,defuse,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_expand "rotlhi3_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=rR<>")
        (rotatert:HI (match_operand:HI 1 "pic30_mode2_APSV_operand" "rR<>")
                     (match_operand:HI 2 "immediate_operand" "i")))]
  "(!pic30_isa32_target())"
  "
{  if (INTVAL(operands[2]) == 1) {
     if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
       emit_insn(gen_rotlhi_DATA_16(operands[0], operands[1]));
     else
       emit_insn(gen_rotlhi_APSV_16(operands[0], operands[1]));
     DONE;
   } else FAIL;
}")

(define_insn "rotrhi_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"   "=r,r,  R<>,R<>")
        (rotatert:HI 
           (match_operand:HI 1 "pic30_mode2_operand" "r,R<>,r,  R<>")
           (const_int 1)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   rrnc.w %1,%0
   rrnc.w %1,%0
   rrnc.w %1,%0
   rrnc.w %1,%0"
  [ 
    (set_attr "cc" "math")  ; CAW
    (set_attr "type" "def,defuse,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "rotrhi_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"        "=r,r,  R<>,R<>")
        (rotatert:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,R<>,r,  R<>")
           (const_int 1)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   rrnc.w %1,%0
   rrnc.w %1,%0
   rrnc.w %1,%0
   rrnc.w %1,%0"
  [ 
    (set_attr "cc" "math")  ; CAW
    (set_attr "type" "def,defuse,use,use") 
    (set_attr "op_type" "alu")
  ]
)

(define_expand "rotrhi3_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=rR<>")
        (rotatert:HI (match_operand:HI 1 "pic30_mode2_APSV_operand" "rR<>")
                     (match_operand:HI 2 "immediate_operand" "i")))]
  "(!pic30_isa32_target())"
  "
{  if (INTVAL(operands[2]) == 1) {
     if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
       emit_insn(gen_rotrhi_DATA_16(operands[0], operands[1]));
     else
       emit_insn(gen_rotrhi_APSV_16(operands[0], operands[1]));
     DONE;
   } else FAIL;
}")

;
; 24-bit unpack instruction
;   a pointer is 23..15.....0
;                page  offset
;   but for PSV access it must be
;                24..16 15 14...0
;                page   1  offset

(define_insn "unpack_EDS_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "=r")
        (unspec_volatile:P32EDS
          [(match_operand:P32EDS 1 "pic30_register_operand" "0")]
            UNSPECV_UNPACKEDS))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "btss %0,#15\;inc %d0,%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "unpack_MPSV_DATA_16"
   [(set (match_operand:SI 0 "pic30_mode2_operand"       "=r,R,r,&r,R,R")
         (unspec_volatile:SI 
           [(match_operand:P24PSV 1 "pic30_mode2_operand" "0,0,r, R,r,R")] 
             UNSPECV_UNPACKMPSV))
    (clobber (reg:CC_NZC CC_REG))
   ]
   "(!pic30_isa32_target())"
   "@
    btsts.c %0,#15\;rlc %d0,%d0
    btsts.c %I0,#15\;rlc %0,%D0
    mov %1,%0\;btsts.c %0,#15\;rlc %d1,%d0
    mov %I1,%0\;btsts.c %0,#15\;rlc %D1,%d0
    mov %1,%0\;btsts.c %I0,#15\;rlc %d1,%D0
    mov %I1,%0\;btsts.c %I0,#15\;rlc %D1,%D0"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def,use,def,defuse,use,use")
     (set_attr "op_type" "alu")
   ]
)

(define_insn "unpack_MPSV_APSV_16"
   [(set (match_operand:SI 0 "pic30_mode2_operand"            "=r,R,r,&r,R,R")
         (unspec_volatile:SI 
           [(match_operand:P24PSV 1 "pic30_mode2_APSV_operand" "0,0,r, R,r,R")] 
             UNSPECV_UNPACKMPSV))
    (clobber (reg:CC_NZC CC_REG))
   ]
   "(!pic30_isa32_target())"
   "@
    btsts.c %0,#15\;rlc %d0,%d0
    btsts.c %I0,#15\;rlc %0,%D0
    mov %1,%0\;btsts.c %0,#15\;rlc %d1,%d0
    mov %I1,%0\;btsts.c %0,#15\;rlc %D1,%d0
    mov %1,%0\;btsts.c %I0,#15\;rlc %d1,%D0
    mov %I1,%0\;btsts.c %I0,#15\;rlc %D1,%D0"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def,use,def,defuse,use,use")
     (set_attr "op_type" "alu")
   ]
)

(define_expand "unpack_MPSV_16"
   [(set (match_operand:SI 0 "pic30_mode2_operand"       "=r,R,r,r,R,R")
         (unspec_volatile:SI
           [(match_operand:P24PSV 1 "pic30_mode2_APSV_operand" "0,0,r,R,r,R")]
             UNSPECV_UNPACKMPSV))]
   "(!pic30_isa32_target())"
   "
{
   if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
     emit(gen_unpack_MPSV_DATA_16(operands[0],operands[1]));
   else
     emit(gen_unpack_MPSV_APSV_16(operands[0],operands[1]));
   DONE;
}")

(define_insn "unpack_MPROG_DATA_16"
   [(set (match_operand:SI 0 "pic30_mode2_operand"        "=r,R,r,&r,R,R")
         (unspec_volatile:SI 
           [(match_operand:P24PROG 1 "pic30_mode2_operand" "0,0,r, R,r,R")] 
             UNSPECV_UNPACKMPROG))
    (clobber (reg:CC_NZC CC_REG))
   ]
   "(!pic30_isa32_target())"
   "@
    btsts.c %0,#15\;rlc %d0,%d0
    btsts.c %I0,#15\;rlc %0,%D0
    mov %1,%0\;btsts.c %0,#15\;rlc %d1,%d0
    mov %I1,%0\;btsts.c %0,#15\;rlc %D1,%d0
    mov %1,%0\;btsts.c %I0,#15\;rlc %d1,%D0
    mov %I1,%0\;btsts.c %I0,#15\;rlc %D1,%D0"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def,use,def,defuse,use,use")
     (set_attr "op_type" "alu")
   ]
)

(define_insn "unpack_MPROG_APSV_16"
   [(set (match_operand:SI 0 "pic30_mode2_operand"             "=r,R,r,&r,R,R")
         (unspec_volatile:SI 
           [(match_operand:P24PROG 1 "pic30_mode2_APSV_operand" "0,0,r, R,r,R")] 
             UNSPECV_UNPACKMPROG))
    (clobber (reg:CC_NZC CC_REG))
   ]
   "(!pic30_isa32_target())"
   "@
    btsts.c %0,#15\;rlc %d0,%d0
    btsts.c %I0,#15\;rlc %0,%D0
    mov %1,%0\;btsts.c %0,#15\;rlc %d1,%d0
    mov %I1,%0\;btsts.c %0,#15\;rlc %D1,%d0
    mov %1,%0\;btsts.c %I0,#15\;rlc %d1,%D0
    mov %I1,%0\;btsts.c %I0,#15\;rlc %D1,%D0"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def,use,def,defuse,use,use")
     (set_attr "op_type" "alu")
   ]
)

(define_expand "unpack_MPROG_16"
   [(set (match_operand:SI 0 "pic30_mode2_operand"       "=r,R,r,r,R,R")
         (unspec_volatile:SI
           [(match_operand:P24PROG 1 "pic30_mode2_APSV_operand" "0,0,r,R,r,R")]
             UNSPECV_UNPACKMPROG))]
   "(!pic30_isa32_target())"
   "
{
  if (pic30_mode2_operand(operands[1],GET_MODE(operands[1]))) 
    emit(gen_unpack_MPROG_DATA_16(operands[0],operands[1]));
  else
    emit(gen_unpack_MPROG_APSV_16(operands[0],operands[1]));
  DONE;
}")

;
;  24-bit read instructions:
;
;    [PTRMODE]read_[READMODE]
;
;    P24PROGread_hi  (read a HI via a P24PROG pointer)
;
;  These patterns are (at least) a use because of the mem
;
(define_insn "P24PROGread_qi_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"              "=r,R<>")
        (unspec_volatile:QI
          [(mem:QI (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPROG))
  ]
  "(!pic30_isa32_target())"
  "@
   mov.b [%1],%0
   mov.b [%1],%0"
  [
    (set_attr "type" "defuse,use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P24PROGread_<mode>_16"
  [(set (match_operand:SM16BIT 0 "pic30_mode2_operand"              "=r,R<>")
        (unspec_volatile:SM16BIT
          [(mem:SM16BIT (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPROG))
  ]
  "(!pic30_isa32_target())"
  "@
   mov [%1],%0
   mov [%1],%0"
  [
    (set_attr "type" "defuse,use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P24PSVread_<mode>_16"
  [(set (match_operand:SM32BIT 0 "pic30_mode2_operand"             "=&r,R")
        (unspec_volatile:SM32BIT
          [(mem:SM32BIT (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPSV))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"mov [%1++],%0\;mov [%1--],%d0\",
       \"mov [%1++],%I0\;mov [%1--],%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"mov [%1++],%0\;nop\;mov [%1--],%d0\",
       \"mov [%1++],%I0\;nop\;mov [%1--],%D0\"
     };

     if (pic30_errata_mask & psrd_psrd_errata) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "defuse,use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P24PROGread_<mode>_16"
  [(set (match_operand:SM32BIT 0 "pic30_mode2_operand"             "=&r,R")
        (unspec_volatile:SM32BIT
          [(mem:SM32BIT (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPROG))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *results[] = {
                       \"mov [%1++],%0\;btss %1,#15\;inc _PSVPAG\;\"
                           \"bset %1,#15\;mov [%1],%d0\",
                       \"mov [%1++],%I0\;btss %1,#15\;inc _PSVPAG\;\"
                           \"bset %1,#15\;mov [%1],%D0\"
                     };
     const char *edsresults[] = {
                       \"mov [%1++],%0\;btss %1,#15\;inc _DSRPAG\;\"
                           \"bset %1,#15\;mov [%1],%d0\",
                       \"mov [%1++],%I0\;btss %1,#15\;inc _DSRPAG\;\"
                           \"bset %1,#15\;mov [%1],%D0\"
                     };

     if (pic30_eds_target()) return edsresults[which_alternative];
     return results[which_alternative];
   }"
  [
    (set_attr "type" "defuse,use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P24PROGread_<mode>_16"
  [(set (match_operand:SM48BIT 0 "pic30_mode2_operand"             "=&r,R")
        (unspec_volatile:SM48BIT
          [(mem:SM48BIT (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPROG))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *results[] = {
                       \"mov [%1++],%0\;btss %1,#15\;inc _PSVPAG\;\"
                           \"bset %1,#15\;mov [%1++],%d0\;btss %1,#15\;\"
                           \"inc _PSVPAG\;bset %1,#15\;mov [%1],%t0\",
                       \"mov [%1++],%I0\;btss %1,#15\;inc _PSVPAG\;\"
                           \"bset %1,#15\;mov [%1++],%I0\;btss %1,#15\;\"
                           \"inc _PSVPAG\;bset %1,#15\;mov [%1],%0\;sub #4,%r0\"
                     };
     const char *edsresults[] = {
                       \"mov [%1++],%0\;btss %1,#15\;inc _DSRPAG\;\"
                           \"bset %1,#15\;mov [%1++],%d0\;btss %1,#15\;\"
                           \"inc _DSRPAG\;bset %1,#15\;mov [%1],%t0\",
                       \"mov [%1++],%I0\;btss %1,#15\;inc _DSRPAG\;\"
                           \"bset %1,#15\;mov [%1++],%I0\;btss %1,#15\;\"
                           \"inc _DSRPAG\;bset %1,#15\;mov [%1],%0\;sub #4,%r0\"
                     };
     if (pic30_eds_target()) return edsresults[which_alternative];
     return results[which_alternative];
   }"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P24PROGread_<mode>_16"
  [(set (match_operand:SM64BIT 0 "pic30_mode2_operand"             "=&r,R")
        (unspec_volatile:SM64BIT
          [(mem:SM64BIT (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPROG))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "*
   {
     const char *results[] = {
                       \"mov [%1++],%0\;btss %1,#15\;inc _PSVPAG\;\"
                           \"bset %1,#15\;mov [%1++],%d0\;btss %1,#15\;\"
                           \"inc _PSVPAG\;bset %1,#15\;mov [%1++],%t0\;\"
                           \"btss %1,#15\;inc _PSVPAG\;bset %1,#15\;\"
                           \"mov [%1],%q0\",
                       \"mov [%1++],%I0\;btss %1,#15\;inc _PSVPAG\;\"
                           \"bset %1,#15\;mov [%1++],%I0\;btss %1,#15\;\"
                           \"inc _PSVPAG\;bset %1,#15\;mov [%1++],%I0\;\"
                           \"btss %1,#15\;inc _PSVPAG\;bset %1,#15\;\"
                           \"mov [%1],%0\;sub #6,%r0\"
                     };
     const char *edsresults[] = {
                       \"mov [%1++],%0\;btss %1,#15\;inc _DSRPAG\;\"
                           \"bset %1,#15\;mov [%1++],%d0\;btss %1,#15\;\"
                           \"inc _DSRPAG\;bset %1,#15\;mov [%1++],%t0\;\"
                           \"btss %1,#15\;inc _DSRPAG\;bset %1,#15\;\"
                           \"mov [%1],%q0\",
                       \"mov [%1++],%I0\;btss %1,#15\;inc _DSRPAG\;\"
                           \"bset %1,#15\;mov [%1++],%I0\;btss %1,#15\;\"
                           \"inc _DSRPAG\;bset %1,#15\;mov [%1++],%I0\;\"
                           \"btss %1,#15\;inc _DSRPAG\;bset %1,#15\;\"
                           \"mov [%1],%0\;sub #6,%r0\"
                     };
     if (pic30_eds_target()) return edsresults[which_alternative];
     return results[which_alternative];
   }"
  [
    (set_attr "type" "defuse,use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P24PSVread_<mode>_16"
  [(set (match_operand:SM48BIT 0 "pic30_mode2_operand"             "=&r,R")
        (unspec_volatile:SM48BIT
          [(mem:SM48BIT (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPSV))
   (clobber (match_dup 1))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"mov [%1++],%0\;mov [%1++],%d0\;mov [%1],%t0\"
       \"mov [%1++],%I0\;mov [%1++],%I0\;mov [%1],%0\;sub #4,%r0\"
     };

     static const char *psv_psv_patterns[] = {
       \"mov [%1++],%0\;nop\;mov [%1++],%d0\;nop\;mov [%1],%t0\",
       \"mov [%1++],%I0\;nop\;mov [%1++],%I0\;nop\;mov [%1],%0\;sub #4,%r0\"
     };

     if (pic30_errata_mask & psrd_psrd_errata) {
       pic30_rtx_nops += 3;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "defuse,use")
  ]
)

(define_insn "P24PSVread_<mode>_16"
  [(set (match_operand:SM64BIT 0 "pic30_mode2_operand"             "=&r,R")
        (unspec_volatile:SM64BIT
          [(mem:SM64BIT (match_operand:HI 1 "pic30_register_operand" "r,r"))
           (reg:HI PSVPAG)]
          UNSPECV_PSVRDPSV))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     static const char *patterns[] = {
       \"mov [%1++],%0\;mov [%1++],%d0\;mov [%1++],%t0\;mov [%1],%q0\",
       \"mov [%1++],%I0\;mov [%1++],%I0\;mov [%1++],%I0\;mov [%1],%0\;sub #6,%r0\"
     };

     static const char *psv_psv_patterns[] = {
       \"mov [%1++],%0\;nop\;mov [%1++],%d0\;nop\;mov [%1++],%t0\;nop\;mov [%1],%q0\",
       \"mov [%1++],%I0\;nop\;mov [%1++],%I0\;nop\;mov [%1++],%I0\;nop\;mov [%1],%0\;sub #6,%r0\"
     };

     if (pic30_errata_mask & psrd_psrd_errata) {
       pic30_rtx_nops += 3;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "defuse,use")
    (set_attr "op_type" "mov")
  ]
)

; EDSread

(define_insn "P32EDSread_qi_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"   "=r,r,  R<>,R<>")
        (unspec_volatile:QI
          [(match_operand:QI 1 "pic30_mode2_operand" "r,R<>,r,  R<>")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
  ]
  "(!pic30_isa32_target())"
  "@
   mov.b %1,%0
   mov.b %1,%0
   mov.b %1,%0
   mov.b %1,%0"
  [
    (set_attr "type" "def,defuse,use,use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P32EDSread_<mode>_16"
  [(set (match_operand:SM16BIT 0 "pic30_mode2_operand"   "=r,r,  R<>,R<>")
        (unspec_volatile:SM16BIT
          [(match_operand:SM16BIT 1 "pic30_mode2_operand" "r,R<>,r,  R<>")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0"
  [
    (set_attr "type" "def,defuse,use,use")
    (set_attr "op_type" "mov")
  ]
)

; The general process for incrementing an EDS pointer (PAGE:offset) in 
;   current devices is
;
;  mov x, [offset]            ; read (or write) data
;  inc2 offset, offset        ; increment for next offset
;  bra nc,1f                  ; carry clear we are finished
;  bset offset,#15            ; put us back into EDS range
;  inc PAGE                   ; update PAGE
;  1:

;
;  for RAW stall detection watch out for implicit mems
;

(define_insn "P32EDSread_eds_<mode>_16"
  [(set (match_operand:SM32BIT 0 "pic30_mode2_operand"      "=&r,R")
        (unspec_volatile:SM32BIT
          [(match_operand:HI 1 "pic30_register_operand" " r,r")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *edsresults[] = { 
                       \"mov [%1],%0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                           \"bset %1,#15\;inc _DSRPAG\;\"
                           \".L1_%=: mov [%1],%d0\",
                       \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                           \"bset %1,#15\;inc _DSRPAG\;\"
                           \".L1_%=: mov [%1],%D0\"
                     };

     return edsresults[which_alternative];
   }"
  [
    (set_attr "type" "defuse,use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P32EDSread_noeds_<mode>_16"
  [(set (match_operand:SM32BIT 0 "pic30_mode2_operand"      "=&r,R")
        (unspec_volatile:SM32BIT
          [(match_operand:HI 1 "pic30_register_operand" " r,r")
           (reg:HI PSVPAG)]
          UNSPECV_NOEDSRD))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *results[] = { 
                       \"mov [%1],%0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                           \"bset %1,#15\;inc _PSVPAG\;\"
                           \".L1_%=: mov [%1],%d0\",
                       \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                           \"bset %1,#15\;inc _PSVPAG\;\"
                           \".L1_%=: mov [%1],%D0\"
                     };

     return results[which_alternative];
   }"
  [
    (set_attr "type" "defuse,use")
    (set_attr "op_type" "mov")
  ]
)

(define_expand "P32EDSread_<mode>_16"
  [(set (match_operand:SM32BIT 0 "pic30_mode2_operand" "=&r,R")
        (unspec_volatile:SM32BIT
          [(match_operand:SM32BIT 1 "pic30_R_operand" " R,R")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_eds_target()) {
    emit(gen_P32EDSread_eds_<mode>_16(operands[0],XEXP(operands[1],0)));
  } else {
    emit(gen_P32EDSread_noeds_<mode>_16(operands[0],XEXP(operands[1],0)));
  }
  DONE;
}")

(define_insn "P32EDSread_eds_<mode>_16"
  [(set (match_operand:SM48BIT 0 "pic30_register_operand"   "=&r")
        (unspec_volatile:SM48BIT
          [(match_operand:HI 1 "pic30_register_operand" " r")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *edsresults[] = {
                     \"mov [%1],%0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L1_%=: \"
                     \"mov [%1],%d0\;inc2 %1,%1\;bra nc,.L2_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L2_%=: \"
                     \"mov [%1],%t0\",
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L1_%=: \"
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L2_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L2_%=: \"
                     \"mov [%1],%0\"
                   };

     return edsresults[0];
   }"
   [
      (set_attr "type" "defuse")
   ]
)

(define_insn "P32EDSread_noeds_<mode>_16"
  [(set (match_operand:SM48BIT 0 "pic30_register_operand"   "=&r")
        (unspec_volatile:SM48BIT
          [(match_operand:HI 1 "pic30_register_operand" " r")
           (reg:HI PSVPAG)]
          UNSPECV_NOEDSRD))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *results[] = {
                     \"mov [%1],%0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L1_%=: \"
                     \"mov [%1],%d0\;inc2 %1,%1\;bra nc,.L2_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L2_%=: \"
                     \"mov [%1],%t0\",
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L1_%=: \"
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L2_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L2_%=: \"
                     \"mov [%1],%0\"
                   };

     return results[0];
   }"
  [
    (set_attr "type" "defuse")
  ]
)

(define_expand "P32EDSread_<mode>_16"
  [(set (match_operand:SM48BIT 0 "pic30_register_operand" "=&r")
        (unspec_volatile:SM48BIT
          [(match_operand:SM48BIT 1 "pic30_R_operand" " R")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
  ]
  "(!pic30_isa32_target())"
  "
{
   if (pic30_eds_target()) {
     emit(gen_P32EDSread_eds_<mode>_16(operands[0],XEXP(operands[1],0)));
   } else {
     emit(gen_P32EDSread_noeds_<mode>_16(operands[0],XEXP(operands[1],0)));
   }
   DONE;
}"
)

(define_insn "P32EDSread_eds_<mode>_16"
  [(set (match_operand:SM64BIT 0 "pic30_register_operand"   "=&r")
        (unspec_volatile:SM64BIT
          [(match_operand:HI 1 "pic30_register_operand" " r")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *edsresults[] = {
                     \"mov [%1],%0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L1_%=: \"
                     \"mov [%1],%d0\;inc2 %1,%1\;bra nc,.L2_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L2_%=: \"
                     \"mov [%1],%t0\;inc2 %1,%1\;bra nc,.L3_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L3_%=: \"
                     \"mov [%1],%q0\",
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L1_%=: \"
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L2_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L2_%=: \"
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L3_%=\;\"
                         \"bset %1,#15\;inc _DSRPAG\;\"
                         \".L3_%=: \"
                     \"mov [%1],%0\"
                   };

     return edsresults[0];
   }"
   [
     (set_attr "type" "defuse")
     (set_attr "op_type" "mov")
   ]
)

(define_insn "P32EDSread_noeds_<mode>_16"
  [(set (match_operand:SM64BIT 0 "pic30_register_operand"   "=&r")
        (unspec_volatile:SM64BIT
          [(match_operand:HI 1 "pic30_register_operand" " r")
           (reg:HI PSVPAG)]
          UNSPECV_NOEDSRD))
   (clobber (reg:HI PSVPAG))
   (clobber (match_dup 1))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *results[] = {
                     \"mov [%1],%0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L1_%=: \"
                     \"mov [%1],%d0\;inc2 %1,%1\;bra nc,.L2_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L2_%=: \"
                     \"mov [%1],%t0\;inc2 %1,%1\;bra nc,.L3_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L3_%=: \"
                     \"mov [%1],%q0\",
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L1_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L1_%=: \"
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L2_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L2_%=: \"
                     \"mov [%1],%I0\;inc2 %1,%1\;bra nc,.L3_%=\;\"
                         \"bset %1,#15\;inc _PSVPAG\;\"
                         \".L3_%=: \"
                     \"mov [%1],%0\"
                   };

     return results[0];
   }"
  [
    (set_attr "type" "defuse")
    (set_attr "op_type" "mov")
  ]
)

(define_expand "P32EDSread_<mode>_16"
  [(set (match_operand:SM64BIT 0 "pic30_register_operand" "=&r")
        (unspec_volatile:SM64BIT
          [(match_operand:SM64BIT 1 "pic30_R_operand" " R")
           (reg:HI PSVPAG)]
          UNSPECV_EDSRD))
  ]
  "(!pic30_isa32_target())"
  "
{
   if (pic30_eds_target()) {
     emit(gen_P32EDSread_eds_<mode>_16(operands[0],XEXP(operands[1],0)));
   } else {
     emit(gen_P32EDSread_noeds_<mode>_16(operands[0],XEXP(operands[1],0)));
   }
   DONE;
}"
)

; P32EDSwrite

(define_insn "P32EDSwrite_qi_16"
  [(set (match_operand:QI 0 "pic30_R_operand" "=R")
        (unspec_volatile:QI
          [(match_operand:QI 1 "pic30_mode2_operand" "rR<>")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
  ]
  "(!pic30_isa32_target())"
  "mov.b %1,%0"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P32EDSwrite_<mode>_16"
  [(set (match_operand:SM16BIT 0 "pic30_R_operand" "=R")
        (unspec_volatile:SM16BIT
          [(match_operand:SM16BIT 1 "pic30_mode2_operand" "rR<>")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
  ]
  "(!pic30_isa32_target())"
  "mov %1,%0"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P32EDSwrite_eds_<mode>_16"
  [(set (mem:SM32BIT (match_operand:HI 0 "pic30_register_operand" "r,r"))
        (unspec_volatile:SM32BIT
          [(match_operand:SM32BIT 1 "pic30_mode2_operand" "r,R")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
   (clobber (reg:HI DSWPAG))
   (clobber (match_dup 0))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *edsresults[] = { 
                     \"mov %1,[%0]\;inc2 %0,%0\;bra nc,.L1_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L1_%=: mov %d1,[%0]\",
                     \"mov %I1,[%0]\;inc2 %0,%0\;bra nc,.L1_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L1_%=: mov %D1,[%0]\",
                   };
     return edsresults[which_alternative];
   }"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P32EDSwrite_noeds_<mode>_16"
  [(set (match_operand:SM32BIT 0 "pic30_R_operand" "=R,R")
        (unspec_volatile:SM32BIT
          [(match_operand:SM32BIT 1 "pic30_mode2_operand" "r,R")]
          UNSPECV_EDSWT))
   (clobber (reg:HI DSWPAG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *results[] = { \"mov %1,%I0\;mov %d1,%D0\",
                               \"mov %I1,%I0\;mov %D1,%D0\" };

     const char *psv_psv_results[] = { \"mov %1,%I0\;mov %d1,%D0\",
                                       \"mov %I1,%I0\;nop\;mov %D1,%D0\" };
                     
     if (pic30_psrd_psrd_errata(operands[0],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_results[which_alternative];
     } else {
       return results[which_alternative];
     }
   }"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

(define_expand "P32EDSwrite_<mode>_16"
  [(set (match_operand:SM32BIT 0 "pic30_R_operand" "=R,R")
        (unspec_volatile:SM32BIT
          [(match_operand:SM32BIT 1 "pic30_mode2_operand" "r,R")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
  ]
  "(!pic30_isa32_target())"
  "
   {
     if (pic30_eds_target()) {
       emit(gen_P32EDSwrite_eds_<mode>_16(XEXP(operands[0],0),operands[1]));
     } else {
       emit(gen_P32EDSwrite_noeds_<mode>_16(operands[0],operands[1]));
     }
     DONE;
   }"
)

(define_insn "P32EDSwrite_eds_<mode>_16"
  [(set (mem:SM48BIT (match_operand:HI 0 "pic30_register_operand" "r,r"))
        (unspec_volatile:SM48BIT
          [(match_operand:SM48BIT 1 "pic30_mode2_operand"         "r,R")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
   (clobber (reg:HI DSWPAG))
   (clobber (match_dup 0))
   (clobber (match_dup 1))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *edsresults[] = {
                     \"mov %1,[%0]\;inc2 %0,%0\;bra nc,.L1_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L1_%=: \"
                     \"mov %d1,[%0]\;inc2 %0,%0\;bra nc,.L2_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L2_%=: \"
                     \"mov %t1,[%0]\",
                     \"mov %I1,[%0]\;inc2 %0,%0\;bra nc,.L1_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L1_%=: \"
                     \"mov %I1,[%0]\;inc2 %0,%0\;bra nc,.L2_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L2_%=: \"
                     \"mov %I1,[%0]\"
                   };

     return edsresults[which_alternative];
  }"
  [
    (set_attr "type" "use")
  ]
)

(define_insn "P32EDSwrite_noeds_<mode>_16"
  [(set (match_operand:SM48BIT 0 "pic30_R_operand"       "=R,R")
        (unspec_volatile:SM48BIT
          [(match_operand:SM48BIT 1 "pic30_mode2_operand" "r,R")]
          UNSPECV_EDSWT))
   (clobber (reg:HI DSWPAG))
   (clobber (match_dup 0))
   (clobber (match_dup 1))
  ]
  ""
  "*
   {
     const char *results[] ={ 
        \"mov.d %1,%I0\;mov.w %t1,%0\",
        \"mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\"
     };

     const char *psv_psv_results[] ={ 
        \"mov.d %1,%I0\;mov.d %t1,%D0\",
        \"mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %I1,%I0\"
     };

     if (pic30_psrd_psrd_errata(operands[0],NULL)) {
       pic30_rtx_nops+=3;
       return psv_psv_results[which_alternative];
     } else {
       return results[which_alternative];
     }
   }"
  [
    (set_attr "type" "use")
  ]
)

(define_expand "P32EDSwrite_<mode>_16"
  [(set (match_operand:SM48BIT 0 "pic30_R_operand" "=R,R")
        (unspec_volatile:SM48BIT
          [(match_operand:SM48BIT 1 "pic30_mode2_operand" "r,R")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
  ]
  ""
  "
  {
    if (pic30_eds_target()) {
      emit(gen_P32EDSwrite_eds_<mode>_16(XEXP(operands[0],0),operands[1]));
    } else {
      emit(gen_P32EDSwrite_noeds_<mode>_16(operands[0],operands[1]));
    }
    DONE;
  }"
)

(define_insn "P32EDSwrite_eds_<mode>_16"
  [(set (mem:SM64BIT (match_operand:HI 0 "pic30_register_operand" "r,r"))
        (unspec_volatile:SM64BIT
          [(match_operand:SM64BIT 1 "pic30_mode2_operand"         "r,R")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
   (clobber (reg:HI DSWPAG))
   (clobber (match_dup 0))
   (clobber (match_dup 1))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "*
   {
     const char *edsresults[] = {
                     \"mov %1,[%0]\;inc2 %0,%0\;bra nc,.L1_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L1_%=: \"
                     \"mov %d1,[%0]\;inc2 %0,%0\;bra nc,.L2_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L2_%=: \"
                     \"mov %t1,[%0]\;inc2 %0,%0\;bra nc,.L3_%=\;\"
                         \"bset [%0],#15\;inc _DSWPAG\;\"
                         \".L3_%=: \"
                     \"mov %q1,[%0]\",
                     \"mov %I1,[%0]\;inc2 %0,%0\;bra nc,.L1_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L1_%=: \"
                     \"mov %I1,[%0]\;inc2 %0,%0\;bra nc,.L2_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L2_%=: \"
                     \"mov %I1,[%0]\;inc2 %0,%0\;bra nc,.L3_%=\;\"
                         \"bset %0,#15\;inc _DSWPAG\;\"
                         \".L3_%=: \"
                     \"mov %1,[%0]\"
                   };

     return edsresults[which_alternative];
  }"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P32EDSwrite_noeds_<mode>_16"
  [(set (match_operand:SM64BIT 0 "pic30_R_operand"       "=R,R")
        (unspec_volatile:SM64BIT
          [(match_operand:SM64BIT 1 "pic30_mode2_operand" "r,R")]
          UNSPECV_EDSWT))
   (clobber (reg:HI DSWPAG))
   (clobber (match_dup 0))
   (clobber (match_dup 1))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     const char *results[] ={ 
        \"mov.d %1,%I0\;mov.d %t1,%D0\",
        \"mov %I1,%I0\;mov %I1,%I0\;mov %I1,%I0\;mov %I1,%I0\"
     };

     const char *psv_psv_results[] ={ 
        \"mov.d %1,%I0\;mov.d %t1,%D0\",
        \"mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %I1,%I0\"
     };

     if (pic30_psrd_psrd_errata(operands[0],NULL)) {
       pic30_rtx_nops+=3;
       return psv_psv_results[which_alternative];
     } else {
       return results[which_alternative];
     }
   }"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

(define_expand "P32EDSwrite_<mode>_16"
  [(set (match_operand:SM64BIT 0 "pic30_R_operand" "=R,R")
        (unspec_volatile:SM64BIT
          [(match_operand:SM64BIT 1 "pic30_mode2_operand" "r,R")
           (reg:HI DSWPAG)]
          UNSPECV_EDSWT))
  ]
  "(!pic30_isa32_target())"
  "
  {
    if (pic30_eds_target()) {
      emit(gen_P32EDSwrite_eds_<mode>_16(XEXP(operands[0],0),operands[1]));
    } else {
      emit(gen_P32EDSwrite_noeds_<mode>_16(operands[0],operands[1]));
    }
    DONE;
  }"
)

; PEDSread

(define_insn "P32PEDSread_qi_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=r,R")
        (unspec_volatile:QI
          [(match_operand:QI 1 "pic30_R_operand"   "R,R")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
  ]
  "(!pic30_isa32_target())"
  "@
   mov.b %1,%0
   mov.b %1,%0"
  [
    (set_attr "type" "defuse,use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P32PEDSread_<mode>_16"
  [(set (match_operand:SM16BIT    0 "pic30_mode2_operand"   "=rR<>,r")
        (unspec_volatile:SM16BIT
          [(match_operand:SM16BIT 1 "pic30_mode2k_operand"  " R,Q")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %1,%0
   mov %1,%0"
  [
    (set_attr "type" "defuse,use")
    (set_attr "op_type" "mov")
  ]
)

; The general process for incrementing an PEDS pointer (PAGE:offset) in 
;   current devices is straightforward as the data they are pointing to 
;   does not cross a page
 
/*VRT: Need optimized fix for psrd psrd*/
(define_insn "P32PEDSread_<mode>_16"
  [(set (match_operand:SM32BIT 0 "pic30_mode2_operand"     "=&r,R,&r")
        (unspec_volatile:SM32BIT
          [(match_operand 1 "pic30_mode2k_operand"  " R,R, Q")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"mov %I1,%0\;mov %D1,%d0\",
       \"mov %I1,%I0\;mov %D1,%D0\",
       \"mov %1,%0\;mov %Q1,%d0\"
     };

     static const char *psv_psv_patterns[] = {
       \"mov %I1,%0\;mov %D1,%d0\",
       \"mov %I1,%I0\;nop\;mov %D1,%D0\",
       \"mov %1,%0\;nop\;mov %Q1,%d0\"
     };
 
     if (pic30_psrd_psrd_errata(operands[1],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "defuse,use,defuse")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P32PEDSread_<mode>_16"
  [(set (match_operand:SM48BIT    0 "pic30_mode2_operand"  "=&r,R,&r")
        (unspec_volatile:SM48BIT
          [(match_operand:SM48BIT 1 "pic30_mode2k_operand" "  R,R,Q")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
   (clobber (match_dup 1))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"mov.d %I1,%0\;mov %D1,%t0\",
       \"mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\",
       \"mov %1,%0\;mov %Q1,%d0\;mov %R1,%t0\"
     };

     static const char *psv_psv_movd_patterns[] = {
       \"mov %I1,%0\;mov %I1,%d0\;mov %1,%t0\",
       \"mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\",
       \"mov %1,%0\;mov %Q1,%d0\;mov %R1,%t0\"
     };

     static const char *psv_psv_patterns[] = {
       \"mov.d %I1,%0\;nop\;mov %1,%t0\",
       \"mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %1,%0\",
       \"mov %1,%0\;nop\;mov %Q1,%d0\;nop\;mov %R1,%t0\"
     };

     if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
       return psv_psv_movd_patterns[which_alternative];
     } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
       pic30_rtx_nops+=3;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     };
   }"
  [
    (set_attr "type" "defuse,use,defuse")
    (set_attr "op_type" "mov")
  ]
)

/*VRT: Need optimized fix for psrd psrd*/
(define_insn "P32PEDSread_<mode>_16"
  [(set (match_operand:SM64BIT    0 "pic30_mode2_operand"  "=&r,R,&r")
        (unspec_volatile:SM64BIT
          [(match_operand:SM64BIT 1 "pic30_mode2k_operand" "  R,R,Q")
           (reg:HI PSVPAG)]
          UNSPECV_PEDSRD))
   (clobber (match_dup 1))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"mov.d %I1,%0\;mov.d %D1,%t0\",
       \"mov %I1,%I0\;mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\",
       \"mov %1,%0\;mov %Q1,%d0\;mov %R1,%t0\;mov %S1,%q0\"
     };

     static const char *psv_psv_movd_patterns[] = {
       \"mov %I1,%0\;mov %I1,%d0\;mov %I1,%t0\;mov %1,%q0\",
       \"mov %I1,%I0\;mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\",
       \"mov %1,%0\;mov %Q1,%d0\;mov %R1,%t0\;mov %S1,%q0\"
     };

     static const char *psv_psv_patterns[] = {
       \"mov.d %I1,%0\;nop\;mov.d %D1,%t0\",
       \"mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %1,%0\",
       \"mov %1,%0\;nop\;mov %Q1,%d0\;nop\;mov %R1,%t0\;nop\;mov %S1,%q0\"
     };

     if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
       return psv_psv_movd_patterns[which_alternative];
     } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
       pic30_rtx_nops+=3;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     };
   }"
  [
    (set_attr "type" "defuse,use,defuse")
    (set_attr "op_type" "mov")
  ]
)

; P32PEDSwrite

(define_insn "P32PEDSwrite_qi_16"
  [(set (match_operand:QI 0 "pic30_mode2k_operand"       "=R<>, Q")
        (unspec_volatile:QI
          [(match_operand:QI 1 "pic30_mode2_operand"     "rR<>, r")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
  ]
  "(!pic30_isa32_target())"
  "@
   mov.b %1,%0
   mov.b %1,%0"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P32PEDSwrite_<mode>_16"
  [(set (match_operand:SM16BIT    0 "pic30_mode2k_operand"  "=R<>, Q")
        (unspec_volatile:SM16BIT
          [(match_operand:SM16BIT 1 "pic30_mode2_operand"   " rR<>,r")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %1,%0
   mov %1,%0"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

; P32PEDS does not cross a page boundary

(define_insn "P32PEDSwrite_<mode>_16"
  [(set (match_operand:SM32BIT 0 "pic30_mode2k_operand"       "=R,R,Q,R")
        (unspec_volatile:SM32BIT
          [(match_operand:SM32BIT 1 "pic30_mode2_operand"     " r,R,r,>")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"mov.d %1,%0\",
       \"mov %I1,%I0\;mov %D1,%D0\",
       \"mov %1,%0\;mov %d1,%Q0\",
       \"mov %1,%I0\;mov %1,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"mov.d %1,%0\",
       \"mov %I1,%I0\;nop\;mov %D1,%D0\",
       \"mov %1,%0\;mov %d1,%Q0\"
       \"mov %1,%I0\;nop\;mov %1,%D0\",
     };

     if (pic30_psrd_psrd_errata(operands[1],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P32PEDSwrite_<mode>_16"
  [(set (match_operand:SM48BIT 0 "pic30_mode2k_operand"  "=R,R,Q")
        (unspec_volatile:SM48BIT
          [(match_operand:SM48BIT 1 "pic30_mode2_operand" "r,R,r")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
   (clobber (reg:HI DSWPAG))
   (clobber (match_dup 1))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"mov.d %1,%I0\;mov %t1,%0\",
       \"mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\",
       \"mov %1,%0\;mov %d1,%Q0\;mov %t1,%R0\"
     };

     static const char *psv_psv_patterns[] = {
       \"mov.d %1,%I0\;mov.w %t1,%0\",
       \"mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %1,%0\",
       \"mov %1,%0\;nop\;mov %d1,%Q0\;nop\;mov %t1,%R0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],NULL)) {
       pic30_rtx_nops+=3;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "P32PEDSwrite_<mode>_16"
  [(set (match_operand:SM64BIT 0 "pic30_mode2k_operand"  "=R,R,Q")
        (unspec_volatile:SM64BIT
          [(match_operand:SM64BIT 1 "pic30_mode2_operand" "r,R,r")
           (reg:HI DSWPAG)]
          UNSPECV_PEDSWT))
   (clobber (reg:HI DSWPAG))
   (clobber (match_dup 1))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"mov.d %1,%I0\;mov.d %t1,%D0\",
       \"mov %I1,%I0\;mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\",
       \"mov %1,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\"
     };

     static const char *psv_psv_patterns[] = {
       \"mov.d %1,%I0\;mov.d %t1,%D0\",
       \"mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %I1,%I0\;nop\;mov %1,%0\",
       \"mov %1,%0\;nop\;mov %d1,%Q0\;nop\;mov %t1,%R0\;nop\;mov %q1,%S0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],NULL)) {
       pic30_rtx_nops+=3;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "mov")
  ]
)

;
; funky addition
;  for eds only
;   shift up low words first so that we don't have to worry about PSV enable bit
;   add
;   check for upper word being zero
;   zero -> 0 in upper bit 1 otherwise ... set carry 
;   shift it in

;
; NB, here we use add #0,%d0 to both clear the carry and test for Zero
;     (cp0 %d0 will set the carry)
;     well - we could do cp0 page; btsc _SR,#3; bclr _SR,#0; rrc offset,offset
;

(define_insn "addp32eds3_eds_lit_16"
  [(set (match_operand: P32EDS  0 "pic30_register_operand" "=r,r")
        (plus: P32EDS
          (match_operand:P32EDS 1 "pic30_register_operand" " 0,0")
          (match_operand:P32EDS 2 "pic30_OJM_operand"      " PJ,M")))
   (clobber (match_scratch:HI   3                          "=&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(pic30_eds_target())"
  "@
   bclr %0,#15\;add #%2,%0\;sl %0,%0\;btsc _SR,#2\;inc %d0,%d0\;add #0,%d0\;btss _SR,#1\;bset _SR,#0\;rrc %0,%0
   bclr %0,#15\;sub #%J2,%0\;sl %0,%0\;btsc _SR,#2\;dec %d0,%d0\;add #0,%d0\;btss _SR,#1\;bset _SR,#0\;rrc %0,%0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "addp32eds3_eds_r_16"
  [(set (match_operand: P32EDS   0 "pic30_register_operand" "=r,&r")
        (plus: P32EDS
          (match_operand:P32EDS  1 "pic30_register_operand" "%r,0")
          (match_operand:P32EDS  2 "pic30_mode2_operand"    "r,R")))
   (clobber (match_scratch:HI 3                             "=&r,&r"))
   (clobber (match_scratch:HI 4                             "=&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(pic30_eds_target())"
  "@
   sl %1,%3\;sl %2,%4\;add %3,%4,%0\;bset _SR,#1\;addc %d1,%d2,%d0\;bclr _SR,#0\;btss _SR,#1\;bset _SR,#0\;rrc %0,%0
   sl %1,%3\;sl %I2,%4\;add %3,%4,%0\;bset _SR,#1\;addc %d1,%D2,%d0\;bclr _SR,#0\;btss _SR,#1\;bset _SR,#0\;rrc %0,%0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
    (set_attr "cc" "clobber")
  ]
)

(define_insn "subp32eds3_eds_16"
  [(set (match_operand: P32EDS   0 "pic30_register_operand" "=r,&r")
        (minus: P32EDS
          (match_operand:P32EDS  1 "pic30_register_operand" "%r,0")
          (match_operand:P32EDS  2 "pic30_mode2_operand"    "r,R")))
   (clobber (match_scratch:HI 3                             "=&r,&r"))
   (clobber (match_scratch:HI 4                             "=&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(pic30_eds_target())"
  "@
   sl %1,%3\;sl %2,%4\;sub %3,%4,%0\;bset _SR,#1\;subb %d1,%d2,%d0\;bclr _SR,#0\;btss _SR,#1\;bset _SR,#0\;rrc %0,%0
   sl %1,%3\;sl %I2,%4\;sub %3,%4,%0\;bset _SR,#1\;subb %d1,%D2,%d0\;bclr _SR,#0\;btss _SR,#1\;bset _SR,#0\;rrc %0,%0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
    (set_attr "cc" "clobber")
  ]
)

; for non eds we will never overflow into PSV bit set - its either set or not
;   preverve psv bit
;   shift up low words first so that we don't have to worry about PSV enable bit
;   add
;   shift in psv bit

(define_insn "addp32eds3_noeds_lit_16"
  [(set (match_operand: P32EDS  0 "pic30_register_operand" "=r,r")
        (plus: P32EDS
          (match_operand:P32EDS 1 "pic30_register_operand" " 0,0")
          (match_operand:P32EDS 2 "pic30_OJM_operand"      " PJ,M")))
   (clobber (match_scratch:HI   3                          "=&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_eds_target() && (!pic30_isa32_target()))"
  "@
   mov %1,%3\;bclr %0,#15\;add #%2,%0\;btsc _SR,#2\;inc %d0,%d0\;sl %0,%0\;sl %3,%3\;rrc %0,%0
   mov %1,%3\;bclr %0,#15\;sub #%J2,%0\;btsc _SR,#2\;dec %d0,%d0\;sl %0,%0\;sl %3,%3\;rrc %0,%0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "addp32eds3_noeds_r_16"
  [(set (match_operand: P32EDS   0 "pic30_register_operand" "=r,r")
        (plus: P32EDS
          (match_operand:P32EDS  1 "pic30_register_operand" "%r,0")
          (match_operand:P32EDS  2 "pic30_mode2_operand"    "r,R")))
   (clobber (match_scratch:HI 3                             "=&r,&r"))
   (clobber (match_scratch:HI 4                             "=&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_eds_target() && (!pic30_isa32_target()))"
  "@
   ior %1,%2,%4\;sl %2,%3\;sl %1,%0\;add %3,%0,%0\;addc %d1,%d2,%d0\;sl %4,%4\;rrc %0,%0
   ior %1,%2,%4\;sl %I2,%3\;sl %1,%0\;add %3,%0,%0\;addc %d1,%D2,%d0\;sl %4,%4\;rrc %0,%0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "subp32eds3_noeds_16"
  [(set (match_operand: P32EDS   0 "pic30_register_operand" "=r,r")
        (minus: P32EDS
          (match_operand:P32EDS  1 "pic30_register_operand" "%r,0")
          (match_operand:P32EDS  2 "pic30_mode2_operand"    "r,R")))
   (clobber (match_scratch:HI 3                             "=&r,&r"))
   (clobber (match_scratch:HI 4                             "=&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_eds_target() && (!pic30_isa32_target()))"
  "@
   ior %1,%2,%4\;sl %2,%3\;sl %1,%0\;sub %3,%0,%0\;subb %d1,%d2,%d0\;sl %4,%4\;rrc %0,%0
   ior %1,%2,%4\;sl %I1,%3\;sl %1,%0\;sub %3,%0,%0\;subb %d1,%D2,%d0\;sl %4,%4\;rrc %0,%0"
  [
    (set_attr "type" "def")
  ]
)

(define_expand "addp32eds3_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "")
        (plus: P32EDS (match_operand:P32EDS 1 "pic30_register_operand" "")
                      (match_operand:P32EDS 2 "pic30_mode1i_operand" "")))]
  "(!pic30_isa32_target())"
  "
{  rtx (*gen_r)(rtx,rtx,rtx) = gen_addp32eds3_eds_r_16;
   rtx (*gen_lit)(rtx,rtx,rtx) = gen_addp32eds3_eds_lit_16;

   if (!pic30_eds_target()) {
     gen_r = gen_addp32eds3_noeds_r_16;
     gen_lit = gen_addp32eds3_noeds_lit_16;
   }

   if (GET_CODE(operands[2]) == CONST_INT) {
     rtx new_val = operands[2];
     if (pic30_OJM_operand(new_val, HImode)) {
       emit_insn(gen_lit(operand0,operand1,operand2));
       DONE;
     } else {
       /* load the immediate separately */
       rtx result = gen_reg_rtx(P32EDSmode);

       emit_insn(gen_movp32eds_lit_16(result, new_val));
       emit_insn(gen_r(operand0, operand1, result));
       DONE;
     }
   }
   emit_insn(gen_r(operand0,operand1,operand2));
   DONE;
}")

(define_expand "subp32eds3_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "")
        (minus: P32EDS (match_operand:P32EDS 1 "pic30_register_operand" "")
                       (match_operand:P32EDS 2 "pic30_mode2_operand" "")))]
  ""
  "
{  rtx (*gen_r)(rtx,rtx,rtx) = gen_subp32eds3_eds_16;

   if (!pic30_eds_target()) {
     gen_r = gen_subp32eds3_noeds_16;
   }

   emit_insn(gen_r(operand0,operand1,operand2));
   DONE;
}")


;
;  Paged arithmetic doesn't cross a page boundary, add low part only
;

(define_insn "addp32peds3_16"
  [(set (match_operand: P32PEDS  0 "pic30_register_operand"   "=r,r,r,r,r,r,r, r,r")
        (plus: P32PEDS
          (match_operand:P32PEDS 1 "pic30_register_operand"   "%0,r,0,0,r,0,0, r,r")
          (match_operand:P32PEDS 2 "pic30_rR_or_JMNP_operand" " P,P,J,N,N,M,Rr,r,R")
        )
   )
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"add %1,#%2,%0\",
       \"add %1,#%2,%0\;mov %d1,%d0\",
       \"add #%2,%0\",
       \"sub %1,#%J2,%0\",
       \"sub %1,#%J2,%0\;mov %d1,%d0\",
       \"sub #%J2,%0\",
       \"add %1,%2,%0\",
       \"add %1,%2,%0\;mov %d1,%d0\",
       \"add %1,%I2,%0\;mov %D2,%d0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %1,#%2,%0\",
       \"add %1,#%2,%0\;mov %d1,%d0\",
       \"add #%2,%0\",
       \"sub %1,#%J2,%0\",
       \"sub %1,#%J2,%0\;mov %d1,%d0\",
       \"sub #%J2,%0\",
       \"add %1,%2,%0\",
       \"add %1,%2,%0\;mov %d1,%d0\",
       \"add %1,%I2,%0\;nop\;mov %D2,%d0\"
     };
     int overlap = -1,src_regno,dst_regno;

     dst_regno = REGNO(operands[0]);
     switch (which_alternative) {
       default: /* no overlap possible */ break;
       case 8:
         src_regno = REGNO(XEXP(operands[2],0));
         overlap = src_regno - dst_regno;
     }

     if (pic30_psrd_psrd_errata(operands[2],NULL)) {
       pic30_rtx_nops++;
       if (overlap == 0) {
         /* src == dst */
         return \"mov %Q2,%d0\;nop\;add %1,%I2,%\";
       }
       return psv_psv_patterns[which_alternative];
     } else {
       if (overlap == 0) {
         /* src == dst */
         return \"mov %Q2,%d0\;add %1,%I2,%\";
       }
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc,etc,etc,etc,etc,etc,use,etc,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addp24prog3_DATA_16"
  [(set (match_operand:P24PROG    0 
             "pic30_mode2_operand"    "=r, r,r,r,r,<>,<>,<>,<>,<>,R,R,R,R,R")
        (plus:P24PROG 
           (match_operand:P24PROG 1 
             "pic30_register_operand" "%r, r,r,r,r,r, r, r, r, r, r,r,r,r,r")
           (match_operand:P24PROG 2 
             "pic30_math_operand"     " r,<>,R,N,P,r, <>,R, N, P, r,<>,R,N,P")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%0\",
       \"add %1,#%2,%0\;addc %d1,#0,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",   // 10
       \"add %1,%2,%I0\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
       \"sub %1,#%J2,%I0\;subb %d1,#0,%D0\",
       \"add %1,#%2,%I0\;addc %d1,#0,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%0\",
       \"add %1,#%2,%0\;addc %d1,#0,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",   // 10
       \"add %1,%2,%I0\;nop\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
       \"sub %1,#%J2,%I0\;subb %d1,#0,%D0\",
       \"add %1,#%2,%I0\;addc %d1,#0,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[2],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,def,def,use,use,use,use,use,use,use,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addp24prog3_APSV_16"
  [(set (match_operand:P24PROG    0 
             "pic30_mode2_operand"    "=r,r,r,r,r,<>,<>,<>,<>,<>,R,R,R,R,R")
        (plus:P24PROG 
           (match_operand:P24PROG 1 
             "pic30_register_operand" "%r,r,r,r,r,r,r,r,r,r,r,r,r,r,r")
           (match_operand:P24PROG 2 
             "pic30_math_APSV_operand" " r,<>,R,N,P,r,<>,R,N,P,r,<>,R,N,P")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%0\",
       \"add %1,#%2,%0\;addc %d1,#0,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
       \"sub %1,#%J2,%I0\;subb %d1,#0,%D0\",
       \"add %1,#%2,%I0\;addc %d1,#0,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%0\",
       \"add %1,#%2,%0\;addc %d1,#0,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;nop\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
       \"sub %1,#%J2,%I0\;subb %d1,#0,%D0\",
       \"add %1,#%2,%I0\;addc %d1,#0,%D0\"
     };
   
     if (pic30_psrd_psrd_errata(operands[2],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,def,def,use,use,use,use,use,use,use,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_expand "addp24prog3_16"
  [(set (match_operand:P24PROG    0
             "pic30_mode2_operand"    "=r,r,r,r,r,<>,<>,<>,<>,<>,R,R,R,R,R")
        (plus:P24PROG
           (match_operand:P24PROG 1
             "pic30_register_operand" "%r,r,r,r,r,r,r,r,r,r,r,r,r,r,r")
           (match_operand:P24PROG 2
             "pic30_math_APSV_operand" " r,<>,R,N,P,r,<>,R,N,P,r,<>,R,N,P")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_math_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_addp24prog3_DATA_16(operands[0],operands[1],operands[2]));
  else
    emit(gen_addp24prog3_APSV_16(operands[0],operands[1],operands[2]));
  DONE;
}")

(define_insn "add2P24PSV3_lit_16"
  [(set (match_operand:P24PSV   0 "pic30_reg_or_R_operand" "=r,r,R,r,r,R,r")
        (plus:P24PSV
          (match_operand:P24PSV 1 "pic30_register_operand" "%0,r,r,0,r,r,0")
          (match_operand:P24PSV 2 "pic30_JN_operand"       " P,P,P,N,N,N,J")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
        \"add %1,#%2,%0\;addc %d1,#0,%d0\",
        \"add %1,#%2,%0\;addc %d1,#0,%d0\",
        \"add %1,#%2,%I0\;addc %d1,#0,%D0\",
        \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
        \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
        \"sub %1,#%J2,%I0\;subb %d1,#0,%D0\",
        \"add #%2,%0\;addc #0,%d0\",
        \"sub #%J2,%0\;subb #0,%d0\",
        \"add %1,#%2,%0\;addc %d1,#0,%d0\",
        \"sub %1,#%2,%0\;subb %d1,#0,%d0\",
        0};

    if ((which_alternative == 0) && (INTVAL(operands[2]) > 15)) {
      if (REGNO(operands[0]) == REGNO(operands[1]))
        which_alternative = 6;
      else which_alternative = 8;
    } else if ((which_alternative == 1) && (INTVAL(operands[2]) < -15)) {
      if (REGNO(operands[0]) == REGNO(operands[1]))
        which_alternative = 7;
      else which_alternative = 8;
    }
    return patterns[which_alternative];
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,def,use,def,def,use,def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addp24psv3_DATA_e_16"
  [(set (match_operand:P24PSV    0 
             "pic30_mode2_operand"   "=r,r, r,<>,<>,<>,R,R, R")
        (plus:P24PSV
           (match_operand:P24PSV 1 
             "pic30_register_operand" "r,r, r,r, r, r, r,r, r")
           (match_operand:P24PSV 2
             "pic30_mode2_operand"    "r,<>,R,r, <>,R, r,<>,R")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;nop\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[2],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addp24psv3_APSV_e_16"
  [(set (match_operand:P24PSV    0 
             "pic30_mode2_operand"     "=r,r, r,<>,<>,<>,R,R, R")
        (plus:P24PSV
           (match_operand:P24PSV 1 
             "pic30_register_operand"   "r,r, r,r, r, r, r,r, r")
           (match_operand:P24PSV 2
             "pic30_mode2_APSV_operand" "r,<>,R,r, <>,R, r,<>,R")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%0\",
       \"add %1,%2,%0\;nop\;addc %d1,%2,%0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%I0\;nop\;addc %d1,%2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\"
     };
   
     if (pic30_psrd_psrd_errata(operands[2],NULL)) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_expand "addp24psv3_16"
  [(set (match_operand:P24PSV 0 "pic30_mode2_operand" "")
        (plus: P24PSV (match_operand:P24PSV 1 "pic30_register_operand" "")
                      (match_operand:P24PSV 2 "pic30_mode1i_operand" "")))]
  "(!pic30_isa32_target())"
  "
{  rtx (*gen)(rtx,rtx,rtx) = gen_addp24psv3_APSV_e_16;

   if (pic30_mode2_operand(operands[2],GET_MODE(operands[2])))
     gen = gen_addp24psv3_DATA_e_16;
   if (GET_CODE(operands[2]) == CONST_INT) {
     rtx new_val = operands[2];
     if (pic30_JN_operand(new_val, HImode)) {
       emit_insn(gen_add2P24PSV3_lit_16(operand0,operand1,operand2));  
       DONE;
     } else {
       /* load the immediate separately */
       rtx result = gen_reg_rtx(P24PSVmode);

       emit_insn(gen_movp24psv_lit_16(result, new_val));
       emit_insn(gen(operand0, operand1, result));
       DONE;
     }
   }
   emit_insn(gen(operand0,operand1,operand2));
   DONE;
}")

;
; APSVrd
;
; target_flags & TARGET_TRACK_PSVPAG => we want to make sure PSVPAG is set right
;

(define_expand "P16APSVrd_qi_16"
  [(set (match_operand:QI 0 "pic30_move_operand"
                "=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U,U")
        (match_operand:QI 1 "pic30_move2_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a,r"))
  ]
  "(!pic30_isa32_target())"
  "
{ rtx sfr;
  rtx psv_page;
  rtx from = operands[1];
  rtx to = operands[0];

  if (TARGET_TRACK_PSVPAG) {
    sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
    psv_page = gen_reg_rtx(HImode);
    emit_insn(
      gen_save_const_psv_16(psv_page, sfr)        /* hopefully optimized away */
    );
    emit(
      gen_set_nvpsv_16(psv_page)                  /* hopefully optimized away */
    );
  }
  if (can_create_pseudo_p()) {
    if (GET_CODE(operands[1]) == MEM) {
      rtx inner = XEXP(operands[1],0);
      switch (GET_CODE(inner)) {
        case CONST:
        case LABEL_REF:
        case SYMBOL_REF:
          from = gen_reg_rtx(GET_MODE(inner));
          emit_move_insn(from, inner);
          from = gen_rtx_MEM(GET_MODE(operands[1]), from);
          break;
        default: break;
      }
    }
    if ((GET_CODE(operands[0]) == MEM) && 
        (!pic30_data_operand(operands[0],GET_MODE(operands[0])))) {
      rtx inner = XEXP(operands[0],0);
      switch (GET_CODE(inner)) {
        case CONST:
        case LABEL_REF:
        case SYMBOL_REF:
          to = gen_reg_rtx(GET_MODE(inner));
          emit_move_insn(to, inner);
          to = gen_rtx_MEM(GET_MODE(operands[0]), to);
          break;
        default: break;
      }
    }
  }
  emit_insn(
    gen_movqi_gen_APSV_16(to,from)
  );
  DONE;
}")

(define_expand "P16APSVrd_<mode>_16"
  [(set (match_operand:SM16BIT 0 "pic30_move_operand"
                "=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U,U")
        (match_operand:SM16BIT 1 "pic30_move2_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a,r"))
  ]
  "(!pic30_isa32_target())"
  "
{ rtx sfr;
  rtx psv_page;

  if (TARGET_TRACK_PSVPAG) {
    sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
    psv_page = gen_reg_rtx(HImode);
    emit_insn(
      gen_save_const_psv_16(psv_page, sfr)        /* hopefully optimized away */
    );
    emit(
      gen_set_nvpsv_16(psv_page)                  /* hopefully optimized away */
    );
  }
  emit_insn(
    gen_mov<mode>_gen_APSV_16(operands[0],operands[1])
  );
  DONE;
}")

(define_expand "P16APSVrd_<mode>_16"
  [(set (match_operand:SM32BIT 0 "pic30_move_operand"
                "=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U,U")
        (match_operand:SM32BIT 1 "pic30_move2_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a,r"))
  ]
  "(!pic30_isa32_target())"
  "
{ rtx sfr;
  rtx psv_page;

  if (TARGET_TRACK_PSVPAG) {
    sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
    psv_page = gen_reg_rtx(HImode);
    emit_insn(
      gen_save_const_psv_16(psv_page, sfr)        /* hopefully optimized away */
    );
    emit(
      gen_set_nvpsv_16(psv_page)                  /* hopefully optimized away */
    );
  }
  emit_insn(
    gen_movp16apsv_gen_APSV_16(operands[0],operands[1])
  );
  DONE;
}")

(define_expand "P16APSVrd_<mode>_16"
  [(set (match_operand:SM48BIT 0 "pic30_move_operand"
                "=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U,U")
        (match_operand:SM48BIT 1 "pic30_move2_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a,r"))
  ]
  "(!pic30_isa32_target())"
  "
{ rtx sfr;
  rtx psv_page;

  if (TARGET_TRACK_PSVPAG) {
    sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
    psv_page = gen_reg_rtx(HImode);
    emit_insn(
      gen_save_const_psv_16(psv_page, sfr)        /* hopefully optimized away */
    );
    emit(
      gen_set_nvpsv_16(psv_page)                  /* hopefully optimized away */
    );
  }
  emit_insn(
    gen_mov<mode>_gen_APSV_16(operands[0],operands[1])
  );
  DONE;
}")

(define_expand "P16APSVrd_<mode>_16"
  [(set (match_operand:SM64BIT 0 "pic30_move_operand"
                "=r<>,R,r<>, R,   r<>,RS,r<>,RS, Q,r,U,U")
        (match_operand:SM64BIT 1 "pic30_move2_APSV_operand"
                 "r,  r,<>RS,<>RS,r,  r, R<>,R<>,r,Q,a,r"))
  ]
  "(!pic30_isa32_target())"
  "
{ rtx sfr;
  rtx psv_page;

  if (TARGET_TRACK_PSVPAG) {
    sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
    psv_page = gen_reg_rtx(HImode);
    emit_insn(
      gen_save_const_psv_16(psv_page, sfr)        /* hopefully optimized away */
    );
    emit(
      gen_set_nvpsv_16(psv_page)                  /* hopefully optimized away */
    );
  }
  emit_insn(
    gen_mov<mode>_gen_APSV_16(operands[0],operands[1])
  );
  DONE;
}")

;
;  These insns and splits define how to read via a P24PROG or P24PSV, decomposed
;    into smaller operations if the optimizer is turned on.

(define_expand "P24PROGrd_qi_16"
   [(set (match_operand:QI 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:QI 
           (match_operand:P24PROG 1 "pic30_psv_operand" "r,r,RQ,ST,ST")))]
   "(!pic30_isa32_target())"
   "
{  rtx op2 = gen_reg_rtx(P24PROGmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0 = operand0;
   
   if (!pic30_mode2_operand(op0, QImode)) {
     op0 = gen_reg_rtx(QImode);
   }
   pic30_managed_psv = 1;
   if (pic30_symbolic_address_operand(operand1,P24PROGmode)) {
     emit_insn(
       gen_movp24prog_address_16(op2, operand1)
     );
   } else {
     emit_insn(
       gen_movp24prog_gen_16(op2, operand1)              /* copy pointer */
     );
   }
   emit_insn(
     gen_copy_psv_16(op3)                                /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPROG_16(op1_,op2)                       /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv_16(gen_rtx_SUBREG(HImode, op1_, 2))     /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_qi_16(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_movqi_16(operand0, op0)
     );
   }
   emit_insn(
     gen_set_psv_16(op3)                                 /* restore PSVPAG */
   );
   DONE;
}")
 
(define_expand "P24PSVrd_qi_16"
   [(set (match_operand:QI 0 "pic30_move_operand" "=r,R,rR,r,R")
         (mem:QI (match_operand:P24PSV 1 "pic30_psv_operand" "r,r,RQ,ST,ST")))
   ]
   "(!pic30_isa32_target())"
   "
{  rtx op2 = gen_reg_rtx(P24PSVmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(QImode);
   pic30_managed_psv = 1;
   if (pic30_symbolic_address_operand(operand1,P24PSVmode)) {
     emit_insn(
       gen_movp24psv_address_16(op2, operand1)
     );
   } else {
     emit_insn(
       gen_movp24psv_gen_16(op2, operand1)                 /* copy pointer */
     );
   }
   emit_insn(
     gen_copy_psv_16(op3)                                  /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPSV_16(op1_,op2)                          /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv_16(gen_rtx_SUBREG(HImode, op1_, 2))       /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_qi_16(op0,
                        gen_rtx_SUBREG(HImode, op1_, 0))   /* read value */
   );
   emit_insn(
     gen_set_psv_16(op3)                                   /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_movqi_16(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PROGrd_<mode>_16"
   [(set (match_operand:SM16BIT 0 "pic30_move_operand"  "=r,R,rR,r,R")
         (mem:SM16BIT 
           (match_operand:P24PROG 1 "pic30_psv_operand" "r,r,RQ,ST,ST")))
   ]
   "(!pic30_isa32_target())"
   "
{  rtx op2 = gen_reg_rtx(P24PROGmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;

   op0 = gen_reg_rtx(<MODE>mode);
   pic30_managed_psv = 1;
   if (pic30_symbolic_address_operand(operand1,P24PROGmode)) {
     emit_insn(
       gen_movp24prog_address_16(op2, operand1)
     );
   } else {
     emit_insn(
       gen_movp24prog_gen_16(op2, operand1)              /* copy pointer */
     );
   }
   emit_insn(
     gen_copy_psv_16(op3)                                /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPROG_16(op1_,op2)                       /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv_16(gen_rtx_SUBREG(HImode, op1_, 2))     /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_<mode>_16(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv_16(op3)                                 /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_mov<mode>_16(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PSVrd_<mode>_16"
   [(set (match_operand:SM16BIT 0 "pic30_move_operand" "=r,R,rR,r,R")
         (mem:SM16BIT 
           (match_operand:P24PSV 1 "pic30_psv_operand" "r,r,RQ,ST,ST")))
   ]
   "(!pic30_isa32_target())"
   "
{  rtx op2 = gen_reg_rtx(P24PSVmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;

   op0 = gen_reg_rtx(<MODE>mode);
   pic30_managed_psv = 1;
   if (pic30_symbolic_address_operand(operand1,P24PSVmode)) {
     emit_insn(
       gen_movp24psv_address_16(op2, operand1)
     );
   } else {
     emit_insn(
       gen_movp24psv_gen_16(op2, operand1)               /* copy pointer */
     );
   }
   emit_insn(
     gen_copy_psv_16(op3)                                /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPSV_16(op1_,op2)                        /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv_16(gen_rtx_SUBREG(HImode, op1_, 2))     /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_<mode>_16(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv_16(op3)                                 /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_mov<mode>_16(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PROGrd_<mode>_16"
   [(set (match_operand:SM32BIT 0 "pic30_move_operand" "=r,R,r,R")
         (mem:SM32BIT (match_operand:P24PROG 1 "pic30_psv_operand" "r,r,R,R")))
   ]
   "(!pic30_isa32_target())"
   "
{  rtx op2 = gen_reg_rtx(P24PROGmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(GET_MODE(operand0));
   pic30_managed_psv = 1;
   if (pic30_symbolic_address_operand(operand1,P24PROGmode)) {
     emit_insn(
       gen_movp24prog_address_16(op2, operand1)
     );
   } else {
     emit_insn(
       gen_movp24prog_gen_16(op2, operand1)              /* copy pointer */
     );
   }
   emit_insn(
     gen_copy_psv_16(op3)                                /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPROG_16(op1_,op2)                       /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv_16(gen_rtx_SUBREG(HImode, op1_, 2))     /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_<mode>_16(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv_16(op3)                                 /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_mov<mode>_16(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PSVrd_<mode>_16"
   [(set (match_operand:SM32BIT 0 "pic30_move_operand" "=r,R,r,R")
         (mem:SM32BIT (match_operand:P24PSV 1 "pic30_psv_operand" "r,r,R,R")))
   ]
   "(!pic30_isa32_target())"
   "
{  rtx op2 = gen_reg_rtx(P24PSVmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(GET_MODE(operand0));
   pic30_managed_psv = 1;
   if (pic30_symbolic_address_operand(operand1,P24PSVmode)) {
     emit_insn(
       gen_movp24psv_address_16(op2, operand1)
     );
   } else {
     emit_insn(
       gen_movp24psv_gen_16(op2, operand1)               /* copy pointer */
     );
   }
   emit_insn(
     gen_copy_psv_16(op3)                                /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPSV_16(op1_,op2)                        /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv_16(gen_rtx_SUBREG(HImode, op1_, 2))     /* set PSVPAG */
   );
   emit_insn(
     gen_P24PSVread_<mode>_16(op0,
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv_16(op3)                                 /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_mov<mode>_16(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PROGrd_<mode>_16"
   [(set (match_operand:SM48BIT 0 "pic30_move_operand" "=r,R,r,R")
         (mem:SM48BIT 
           (match_operand:P24PROG 1 "pic30_psv_operand" "r,r,R,R")))
   ]
   "(!pic30_isa32_target())"
   "
{  rtx op2 = gen_reg_rtx(P24PROGmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(<MODE>mode);
   pic30_managed_psv = 1;
   if (pic30_symbolic_address_operand(operand1,P24PROGmode)) {
     emit_insn(
       gen_movp24prog_address_16(op2, operand1)
     );
   } else {
     emit_insn(
       gen_movp24prog_gen_16(op2, operand1)               /* copy pointer */
     );
   }
   emit_insn(
     gen_copy_psv_16(op3)                                 /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPROG_16(op1_,op2)                        /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv_16(gen_rtx_SUBREG(HImode, op1_, 2))      /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_<mode>_16(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0))  /* read value */
   );
   emit_insn(
     gen_set_psv_16(op3)                                  /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_mov<mode>_16(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PSVrd_<mode>_16"
   [(set (match_operand:SM48BIT 0 "pic30_move_operand" "=r,R,r,R")
         (mem:SM48BIT 
           (match_operand:P24PSV 1 "pic30_psv_operand" "r,r,R,R")))
    (clobber (match_scratch:P24PSV 2 "=r,r,r,r"))
    (clobber (match_scratch:QI 3 "=r,r,r,r"))
   ]
   "(!pic30_isa32_target())"
   "
{  rtx op2 = gen_reg_rtx(P24PSVmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(GET_MODE(operand0));
   pic30_managed_psv = 1;
   if (pic30_symbolic_address_operand(operand1,P24PSVmode)) {
     emit_insn(
       gen_movp24psv_address_16(op2, operand1)
     );
   } else {
     emit_insn(
       gen_movp24psv_gen_16(op2, operand1)               /* copy pointer */
     );
   }
   emit_insn(
     gen_copy_psv_16(op3)                                /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPSV_16(op1_,op2)                        /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv_16(gen_rtx_SUBREG(HImode, op1_, 2))     /* set PSVPAG */
   );
   emit_insn(
     gen_P24PSVread_<mode>_16(op0,
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv_16(op3)                                 /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_mov<mode>_16(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PROGrd_<mode>_16"
   [(set (match_operand:SM64BIT 0 "pic30_move_operand" "=r,R,r,R")
         (mem:SM64BIT (match_operand:P24PROG 1 "pic30_psv_operand" "r,r,R,R")))
   ]
   "(!pic30_isa32_target())"
   "
{  rtx op2 = gen_reg_rtx(P24PROGmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(<MODE>mode);
   pic30_managed_psv = 1;
   if (pic30_symbolic_address_operand(operand1,P24PROGmode)) {
     emit_insn(
       gen_movp24prog_address_16(op2, operand1)
     );
   } else {
     emit_insn(
       gen_movp24prog_gen_16(op2, operand1)              /* copy pointer */
     );
   }
   emit_insn(
     gen_copy_psv_16(op3)                                /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPROG_16(op1_,op2)                       /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv_16(gen_rtx_SUBREG(HImode, op1_, 2))     /* set PSVPAG */
   );
   emit_insn(
     gen_P24PROGread_<mode>_16(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv_16(op3)                                 /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_mov<mode>_16(operand0, op0)
     );
   }
   DONE;
}")

(define_expand "P24PSVrd_<mode>_16"
   [(set (match_operand:SM64BIT 0 "pic30_move_operand" "=r,R,r,R")
         (mem:SM64BIT (match_operand:P24PSV 1 "pic30_psv_operand" "r,r,R,R")))
    (clobber (match_scratch:P24PSV 2 "=r,r,r,r"))
    (clobber (match_scratch:QI 3 "=r,r,r,r"))
   ]
   "(!pic30_isa32_target())"
   "
{  rtx op2 = gen_reg_rtx(P24PSVmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1_ = gen_reg_rtx(SImode);
   rtx op0;
  
   op0 = gen_reg_rtx(GET_MODE(operand0));
   pic30_managed_psv = 1;
   if (pic30_symbolic_address_operand(operand1,P24PSVmode)) {
     emit_insn(
       gen_movp24psv_address_16(op2, operand1)
     );
   } else {
     emit_insn(
       gen_movp24psv_gen_16(op2, operand1)               /* copy pointer */
     );
   }
   emit_insn(
     gen_copy_psv_16(op3)                                /* preserve PSVPAG */
   );
   emit_insn(
     gen_unpack_MPSV_16(op1_,op2)                        /* unpack PSV ptr */
   );
   emit_insn(
     gen_set_psv_16(gen_rtx_SUBREG(HImode, op1_, 2))     /* set PSVPAG */
   );
   emit_insn(
     gen_P24PSVread_<mode>_16(op0, 
                        gen_rtx_SUBREG(HImode, op1_, 0)) /* read value */
   );
   emit_insn(
     gen_set_psv_16(op3)                                 /* restore PSVPAG */
   );
   if (op0 != operand0) {
     emit_insn(
       gen_mov<mode>_16(operand0, op0)
     );
   }
   DONE;
}")

;;;;;;;;;;;;;;;;;;;;;;; PMP

(define_expand "P16PMPrd_qi_16"
   [(set (match_operand:QI 0 "pic30_move_operand"       "=rR")
         (mem:QI
           (match_operand:P16PMP 1 "pic30_pmp_operand" "r")))]
   "(!pic30_isa32_target())"
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[0])); 
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[1]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address_16(addr,operands[1])
     );
   } else {
     emit_move_insn(addr,operands[1]);
   }

   emit_insn(
     gen_set_PMADDR_16(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1qi_16(result)                           /* dummy read */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1qi_16(result)                           /* real read */
   );
   emit_move_insn(operands[0],result);
   DONE;
}")

(define_expand "P16PMPwt_qi_16"
   [(set (mem:QI (match_operand:P16PMP 0 "pic30_pmp_operand" "r"))
         (match_operand:QI 1 "pic30_move_operand"       "rR"))]
   "(!pic30_isa32_target())"
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[1]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[0]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address_16(addr,operands[0])
     );
   } else {
     emit_move_insn(addr,operands[0]);
   }

   emit_insn(
     gen_set_PMADDR_16(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_move_insn(result,operands[1]);
   emit_insn(
     gen_set_PMDIN1qi_16(result)                           /* write */
   );
   DONE;
}")

(define_expand "P16PMPrd_<mode>_16"
   [(set (match_operand:SM16BIT 0 "pic30_move_operand"       "=rR")
         (mem:SM16BIT
           (match_operand:P16PMP 1 "pic30_pmp_operand" "r")))]
   "(!pic30_isa32_target())"
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[0]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[1]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address_16(addr,operands[1])
     );
   } else {
     emit_move_insn(addr,operands[1]);
   }

   emit_insn(
     gen_set_PMADDR_16(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,0)) /* dummy read */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,0)) /* real read */
   );
   emit_move_insn(operands[0],result);
   DONE;
}")

(define_expand "P16PMPwt_<mode>_16"
   [(set (mem:SM16BIT 
           (match_operand:P16PMP 0 "pic30_pmp_operand" "r"))
         (match_operand:SM16BIT 1 "pic30_move_operand"       "rR"))]
   "(!pic30_isa32_target())"
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[1]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[0]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address_16(addr,operands[0])
     );
   } else {
     emit_move_insn(addr,operands[0]);
   }

   emit_insn(
     gen_set_PMADDR_16(addr)                              /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_move_insn(result,operands[1]);
   emit_insn(
     gen_set_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,0)) /* write */
   );
   DONE;
}")

(define_expand "P16PMPrd_<mode>_16"
   [(set (match_operand:SM32BIT 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:SM32BIT
           (match_operand:P16PMP 1 "pic30_pmp_operand" "r,r,RQ,ST,ST")))]
   "(!pic30_isa32_target())"
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[0]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[1]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address_16(addr,operands[1])
     );
   } else {
     emit_move_insn(addr,operands[1]);
   }

   emit_insn(
     gen_bitset_PMMODE_16(GEN_INT(11))                    /* set auto inc mode */
   );
   emit_insn(
     gen_set_PMADDR_16(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,0)) /* dummy read */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,0)) /* real read, pt1 */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,2)) /* real read, pt2 */
   );
   emit_insn(
     gen_bitclr_PMMODE_16(GEN_INT(11))                    /* clr auto inc mode */
   );
   emit_move_insn(operands[0],result);
   DONE;
}")

(define_expand "P16PMPwt_<mode>_16"
   [(set (mem:SM32BIT 
           (match_operand:P16PMP 0 "pic30_pmp_operand" "r,r,RQ,ST,ST"))
         (match_operand:SM32BIT 1 "pic30_move_operand"       "=r,R,rR,r,R"))]
   "(!pic30_isa32_target())"
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[1]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[0]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address_16(addr,operands[0])
     );
   } else {
     emit_move_insn(addr,operands[0]);
   }

   emit_insn(
     gen_set_PMADDR_16(addr)                               /* set up address */
   );
   emit_insn(
     gen_bitset_PMMODE_16(GEN_INT(11))                   /* set auto inc  mode */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_move_insn(result,operands[1]);
   emit_insn(
     gen_set_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,0)) /* write        */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_set_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,2)) /* write        */
   );
   emit_insn(
     gen_bitclr_PMMODE_16(GEN_INT(11))                    /* clr auto inc  mode */
   );
   DONE;
}")

(define_expand "P16PMPrd_<mode>_16"
   [(set (match_operand:SM48BIT 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:SM48BIT
           (match_operand:P16PMP 1 "pic30_pmp_operand" "r,r,RQ,ST,ST")))]
   "(!pic30_isa32_target())"
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[0]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[1]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address_16(addr,operands[1])
     );
   } else {
     emit_move_insn(addr,operands[1]);
   }

   emit_insn(
     gen_bitset_PMMODE_16(GEN_INT(11))                     /* auto inc mode */
   );
   emit_insn(
     gen_set_PMADDR_16(addr)                               /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,0)) /* dummy read */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,0)) /* real read, pt1 */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,2)) /* real read, pt2 */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,4)) /* real read, pt3 */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_bitclr_PMMODE_16(GEN_INT(11))                    /* clr auto inc mode */
   );
   emit_move_insn(operands[0],result);
   DONE;
}")

(define_expand "P16PMPwt_<mode>_16"
   [(set (mem:SM48BIT
           (match_operand:P16PMP 0 "pic30_pmp_operand" "r,r,RQ,ST,ST"))
         (match_operand:SM48BIT 1 "pic30_move_operand"       "=r,R,rR,r,R"))]
   "(!pic30_isa32_target())"
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[1]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[0]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address_16(addr,operands[0])
     );
   } else {
     emit_move_insn(addr,operands[0]);
   }

   emit_insn(
     gen_set_PMADDR_16(addr)                               /* set up address */
   );
   emit_insn(
     gen_bitset_PMMODE_16(GEN_INT(11))                     /* auto inc mode */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_move_insn(result,operands[1]);
   emit_insn(
     gen_set_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,0)) /* write        */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_set_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,2)) /* write        */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_set_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,4)) /* write */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_bitclr_PMMODE_16(GEN_INT(11))       /* clr auto increment mode */
   );
   DONE;
}")

(define_expand "P16PMPrd_<mode>_16"
   [(set (match_operand:SM64BIT 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:SM64BIT
           (match_operand:P16PMP 1 "pic30_pmp_operand" "r,r,RQ,ST,ST")))]
   "(!pic30_isa32_target())"
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[0]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[1]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address_16(addr,operands[1])
     );
   } else {
     emit_move_insn(addr,operands[1]);
   }

   emit_insn(
     gen_bitset_PMMODE_16(GEN_INT(11))                    /* set auto inc mode */
   );
   emit_insn(
     gen_set_PMADDR_16(addr)                              /* set up address */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,0)) /* dummy read */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,0)) /* real read, pt1 */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,2)) /* real read, pt2 */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,4)) /* real read, pt3 */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_get_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,6)) /* real read, pt4 */
   );
   emit_insn(
     gen_bitclr_PMMODE_16(GEN_INT(11))                    /* no auto inc mode */
   );
   emit_move_insn(operands[0],result);
   DONE;
}")


(define_expand "P16PMPwt_<mode>_16"
   [(set (mem:SM64BIT
           (match_operand:P16PMP 0 "pic30_pmp_operand" "r,r,RQ,ST,ST"))
         (match_operand:SM64BIT 1 "pic30_move_operand"       "=r,R,rR,r,R"))]
   "(!pic30_isa32_target())"
   "
{  rtx result = gen_reg_rtx(GET_MODE(operands[1]));
   rtx addr;

   addr = gen_reg_rtx(P16PMPmode);
   if (GET_CODE(operands[0]) == SYMBOL_REF) {
     emit_insn(
       gen_movp16pmp_address_16(addr,operands[0])
     );
   } else {
     emit_move_insn(addr,operands[0]);
   }

   emit_insn(
     gen_set_PMADDR_16(addr)                               /* set up address */
   );
   emit_insn(
     gen_bitset_PMMODE_16(GEN_INT(11))                    /* set auto inc mode */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_move_insn(result,operands[1]);
   emit_insn(
     gen_set_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,0)) /* write */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_set_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,2)) /* write */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_set_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,4)) /* write */
   );
   emit_insn(
     gen_while_PMMODE_busy_16()
   );
   emit_insn(
     gen_set_PMDIN1hi_16(gen_rtx_SUBREG(HImode,result,6)) /* write */
   );
   emit_insn(
     gen_bitclr_PMMODE_16(GEN_INT(11))       /* clr auto increment mode */
   );
   DONE;
}")

;;;;;;;;;;;;;;;;;;;;;;; EXT

;;

(define_expand "P32EXTrd_qi_16"
   [(set (match_operand:QI 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:QI
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   "(!pic30_isa32_target())"
   "{
      if (pic30_read_externals(pst_8)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_8)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])));
        rtx param2,param3;
  
        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        emit_move_insn(param3, GEN_INT(1));
        param2 = gen_reg_rtx(machine_Pmode);
        // if we are in UMM mode, stack slots have a HImode and we need
        //   to promote it to a full blown UMM reg
        emit_move_insn(param2, XEXP(temp,0));
        if (GET_MODE(XEXP(temp,0)) != Pmode) {
           rtx param2a = gen_reg_rtx(Pmode);
           emit(
             gen_zero_extendhip32umm2_16(param2a, param2)
           );
           param2 = param2a;
        } 
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]),
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external8\");
        DONE;
      }
    }"
)

(define_expand "P32EXTwt_qi_16"
   [(set (mem:QI (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:QI 1 "pic30_move_operand"            "r,R,rR,r,R"))]
   "(!pic30_isa32_target())"
   "{
      if (pic30_write_externals(pst_8)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_8)),0),
                          LCT_NORMAL, VOIDmode,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])));
        rtx param2,param3;
  
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        emit_move_insn(param3, GEN_INT(1));
        param2 = gen_reg_rtx(machine_Pmode);
        // if we are in UMM mode, stack slots have a HImode and we need
        //   to promote it to a full blown UMM reg
        emit_move_insn(param2, XEXP(temp,0));
        if (GET_MODE(XEXP(temp,0)) != Pmode) {
           rtx param2a = gen_reg_rtx(Pmode);
           emit(
             gen_zero_extendhip32umm2_16(param2a, param2)
           );
           param2 = param2a;
        } 
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]),
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external8\");
        DONE;
      }
    }"
)

(define_expand "P32EXTrd_<mode>_16"
   [(set (match_operand:EXT16BITRD 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:EXT16BITRD
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   "(!pic30_isa32_target())"
   "{
      if (pic30_read_externals(pst_16)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_16)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])));
        rtx param2,param3;
  
        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        emit_move_insn(param3, GEN_INT(2));
        param2 = gen_reg_rtx(machine_Pmode);
        // if we are in UMM mode, stack slots have a HImode and we need
        //   to promote it to a full blown UMM reg
        emit_move_insn(param2, XEXP(temp,0));
        if (GET_MODE(XEXP(temp,0)) != Pmode) {
           rtx param2a = gen_reg_rtx(Pmode);
           emit(
             gen_zero_extendhip32umm2_16(param2a, param2)
           );
           param2 = param2a;
        }
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]),
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else if (pic30_read_externals(pst_8)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_8)),0),
          simplify_gen_subreg(QImode, operands[0], GET_MODE(operands[0]), 0), 
          LCT_NORMAL, QImode, input, P32EXTmode);
        emit_insn(
          gen_addp32ext3_imm_16(input, input, GEN_INT(1))
        );
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_8)),0),
          simplify_gen_subreg(QImode, operands[0], GET_MODE(operands[0]), 1), 
          LCT_NORMAL, QImode, input, P32EXTmode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external16\");
      }
    }"
)

(define_expand "P32EXTwt_<mode>_16"
   [(set (mem:EXT16BITWT
           (match_operand:P32EXT 0 "pic30_ext_operand"          "r,r,RQ,ST,ST"))
         (match_operand:EXT16BITWT 1 "pic30_move_operand"       "r,R,rR,r,R"))]
   "(!pic30_isa32_target())"
   "{
      if (pic30_write_externals(pst_16)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_16)),0),
                          LCT_NORMAL, VOIDmode,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])));
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        emit_move_insn(param3, GEN_INT(2));
        param2 = gen_reg_rtx(machine_Pmode);
        // if we are in UMM mode, stack slots have a HImode and we need
        //   to promote it to a full blown UMM reg
        emit_move_insn(param2, XEXP(temp,0));
        if (GET_MODE(XEXP(temp,0)) != Pmode) {
           rtx param2a = gen_reg_rtx(Pmode);
           emit( 
             gen_zero_extendhip32umm2_16(param2a, param2)
           );
           param2 = param2a;
        } 
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]),
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else if (pic30_write_externals(pst_8)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(QImode);

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, 
          simplify_gen_subreg(QImode, operands[1], GET_MODE(operands[1]),0));
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_8)),0),
                          LCT_NORMAL, VOIDmode,
                          input, P32EXTmode,
                          input1, QImode);
        emit_insn(
          gen_addp32ext3_imm_16(input, input, GEN_INT(1))
        );
        emit_insn(
          gen_addqi3_16(input1, input1, GEN_INT(1))
        );
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_8)),0),
                          LCT_NORMAL, VOIDmode,
                          input, P32EXTmode,
                          input1, QImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external16\");
      }
    }"
)


(define_expand "P32EXTrd_<mode>_16"
   [(set (match_operand:SM32BIT 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:SM32BIT
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   "(!pic30_isa32_target())"
   "{
      if (pic30_read_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_32)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])));
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        emit_move_insn(param3, GEN_INT(4));
        param2 = gen_reg_rtx(machine_Pmode);
        // if we are in UMM mode, stack slots have a HImode and we need
        //   to promote it to a full blown UMM reg
        emit_move_insn(param2, XEXP(temp,0));
        if (GET_MODE(XEXP(temp,0)) != Pmode) {
           rtx param2a = gen_reg_rtx(Pmode);
           emit(
             gen_zero_extendhip32umm2_16(param2a, param2)
           );
           param2 = param2a;
        }
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]),
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external32\");
      }
    }"
)

(define_expand "P32EXTwt_<mode>_16"
   [(set (mem:SM32BIT 
           (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:SM32BIT   1 "pic30_move_operand" "r,R,rR,r,R"))]
   "(!pic30_isa32_target())"
   "{
      if (pic30_write_externals(pst_32)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_32)),0),
                          LCT_NORMAL, VOIDmode,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])));
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        emit_move_insn(param3, GEN_INT(4));
        param2 = gen_reg_rtx(machine_Pmode);
        // if we are in UMM mode, stack slots have a HImode and we need
        //   to promote it to a full blown UMM reg
        emit_move_insn(param2, XEXP(temp,0));
        if (GET_MODE(XEXP(temp,0)) != Pmode) {
           rtx param2a = gen_reg_rtx(Pmode);
           emit( 
             gen_zero_extendhip32umm2_16(param2a, param2)
           );
           param2 = param2a;
        } 
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]),
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external32\");
      }
    }"
)

(define_expand "P32EXTrd_<mode>_16"
   [(set (match_operand:SM48BIT 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:SM48BIT
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   "(!pic30_isa32_target())"
   "{
      if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])));
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        emit_move_insn(param3, GEN_INT(6));
        param2 = gen_reg_rtx(machine_Pmode);
        // if we are in UMM mode, stack slots have a HImode and we need
        //   to promote it to a full blown UMM reg
        emit_move_insn(param2, XEXP(temp,0));
        if (GET_MODE(XEXP(temp,0)) != Pmode) {
           rtx param2a = gen_reg_rtx(Pmode);
           emit(
             gen_zero_extendhip32umm2_16(param2a, param2)
           );
           param2 = param2a;
        }
        emit_move_insn(param2, XEXP(temp,0));
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]),
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external32\");
      }
    }"
)
(define_expand "P32EXTwt_<mode>_16"
   [(set (mem:SM48BIT 
           (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:SM48BIT   1 "pic30_move_operand" "r,R,rR,r,R"))]
   "(!pic30_isa32_target())"
   "{
      if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])));
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        emit_move_insn(param3, GEN_INT(6));
        param2 = gen_reg_rtx(machine_Pmode);
        // if we are in UMM mode, stack slots have a HImode and we need
        //   to promote it to a full blown UMM reg
        emit_move_insn(param2, XEXP(temp,0));
        if (GET_MODE(XEXP(temp,0)) != Pmode) {
           rtx param2a = gen_reg_rtx(Pmode);
           emit( 
             gen_zero_extendhip32umm2_16(param2a, param2)
           );
           param2 = param2a;
        } 
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]),
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external32\");
      }
    }"
)


(define_expand "P32EXTrd_di_16"
   [(set (match_operand:DI 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:DI
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   "(!pic30_isa32_target())"
   "{
      if (pic30_read_externals(pst_64)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_64)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])));
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        emit_move_insn(param3, GEN_INT(8));
        param2 = gen_reg_rtx(machine_Pmode);
        // if we are in UMM mode, stack slots have a HImode and we need
        //   to promote it to a full blown UMM reg
        emit_move_insn(param2, XEXP(temp,0));
        if (GET_MODE(XEXP(temp,0)) != Pmode) {
           rtx param2a = gen_reg_rtx(Pmode);
           emit(
             gen_zero_extendhip32umm2_16(param2a, param2)
           );
           param2 = param2a;
        }
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]),
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external64\");
      }
    }"
)

(define_expand "P32EXTwt_di_16"
   [(set (mem:DI (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:DI 1 "pic30_move_operand"            "r,R,rR,r,R"))]
   "(!pic30_isa32_target())"
   "{
      if (pic30_write_externals(pst_64)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_64)),0),
                          LCT_NORMAL, VOIDmode,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])));
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        emit_move_insn(param3, GEN_INT(8));
        param2 = gen_reg_rtx(machine_Pmode);
        // if we are in UMM mode, stack slots have a HImode and we need
        //   to promote it to a full blown UMM reg
        emit_move_insn(param2, XEXP(temp,0));
        if (GET_MODE(XEXP(temp,0)) != Pmode) {
           rtx param2a = gen_reg_rtx(Pmode);
           emit( 
             gen_zero_extendhip32umm2_16(param2a, param2)
           );
           param2 = param2a;
        } 
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]),
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external64\");
      }
    }"
)

(define_expand "P32EXTrd_df_16"
   [(set (match_operand:DF 0 "pic30_move_operand"       "=r,R,rR,r,R")
         (mem:DF
           (match_operand:P32EXT 1 "pic30_ext_operand" "r,r,RQ,ST,ST")))]
   "(!pic30_isa32_target())"
   "{
      if (pic30_read_externals(pst_64)) {
        rtx input = gen_reg_rtx(P32EXTmode);

        emit_move_insn(input, operands[1]);
        emit_library_call_value(XEXP(DECL_RTL(pic30_read_externals(pst_64)),0),
                          operands[0], LCT_NORMAL, GET_MODE(operands[0]), 
                          input, P32EXTmode);
        DONE;
      } else if (pic30_read_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[0]),
                                     GET_MODE_SIZE(GET_MODE(operands[0])));
        rtx param2,param3;

        emit_move_insn(input, operands[1]);
        param3 = gen_reg_rtx(HImode);
        emit_move_insn(param3, GEN_INT(8));
        param2 = gen_reg_rtx(machine_Pmode);
        // if we are in UMM mode, stack slots have a HImode and we need
        //   to promote it to a full blown UMM reg
        emit_move_insn(param2, XEXP(temp,0));
        if (GET_MODE(XEXP(temp,0)) != Pmode) {
           rtx param2a = gen_reg_rtx(Pmode);
           emit(
             gen_zero_extendhip32umm2_16(param2a, param2)
           );
           param2 = param2a;
        }
        emit_library_call(XEXP(DECL_RTL(pic30_read_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]),
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        emit_move_insn(operands[0], temp);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __read_external or __read_external64\");
      }
    }"
)

(define_expand "P32EXTwt_df_16"
   [(set (mem:DF (match_operand:P32EXT 0 "pic30_ext_operand" "r,r,RQ,ST,ST"))
         (match_operand:DF 1 "pic30_move_operand"            "r,R,rR,r,R"))]
   "(!pic30_isa32_target())"
   "{
      if (pic30_write_externals(pst_64)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx input1 = gen_reg_rtx(GET_MODE(operands[1]));

        emit_move_insn(input, operands[0]);
        emit_move_insn(input1, operands[1]);
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_64)),0),
                          LCT_NORMAL, VOIDmode,
                          input, P32EXTmode,
                          input1, GET_MODE(operands[1]));
        DONE;
      } else if (pic30_write_externals(pst_any)) {
        rtx input = gen_reg_rtx(P32EXTmode);
        rtx temp = assign_stack_temp(GET_MODE(operands[1]),
                                     GET_MODE_SIZE(GET_MODE(operands[1])));
        rtx param2,param3;
 
        emit_move_insn(input, operands[0]);
        emit_move_insn(temp, operands[1]);
        param3 = gen_reg_rtx(HImode);
        emit_move_insn(param3, GEN_INT(8));
        param2 = gen_reg_rtx(machine_Pmode);
        // if we are in UMM mode, stack slots have a HImode and we need
        //   to promote it to a full blown UMM reg
        emit_move_insn(param2, XEXP(temp,0));
        if (GET_MODE(XEXP(temp,0)) != Pmode) {
           rtx param2a = gen_reg_rtx(Pmode);
           emit( 
             gen_zero_extendhip32umm2_16(param2a, param2)
           );
           param2 = param2a;
        } 
        emit_library_call(XEXP(DECL_RTL(pic30_write_externals(pst_any)),0),
                          LCT_NORMAL, GET_MODE(operands[0]),
                          input, P32EXTmode,
                          param2, Pmode,
                          param3, HImode);
        DONE;
      } else {
        error(\"Cannot access external memory space;\n\"
              \"\tdeclare __write_external or __write_external64\");
      }
    }"
)

;;;;;;;;;;;;;;;;;;; DF

(define_expand "P32DFrd_16"
  [(set (match_operand 0 "pic30_register_operand"    "=a")
        (match_operand 1 "pic30_mem_df_operand" " RQST"))]
  "(!pic30_isa32_target())"
  { rtx op0 = operand0;
     emit_library_call_value(
       gen_rtx_SYMBOL_REF(HImode, \"|Nf|__P32DFrd\"),
       op0,
       LCT_NORMAL,
       GET_MODE(op0),
       XEXP(operands[1], 0), P32DFmode,
       GEN_INT(GET_MODE_SIZE(GET_MODE(op0))), HImode
     );
     DONE;
  }
)

;;;;;;;;;;;;;;;;;;; EDS

(define_expand "P32EDSrd_16"
   [(set (match_operand 0 "pic30_reg_or_R_operand"       "=rR")
         (match_operand 1 "pic30_mem_eds_operand"    " RQST"))]
   "(!pic30_isa32_target())"
   "{
   rtx op2 = gen_reg_rtx(P32EDSmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op0 = operand0;
   rtx op1 = operand1;
   rtx page = gen_reg_rtx(HImode);
   rtx offset = gen_reg_rtx(HImode);
   rtx (*fn)(rtx, rtx);
   int indirect_allowed=1;
   int psv_set=0;
   int unpack=0;

   if (GET_MODE(op0) != GET_MODE(op1)) FAIL;
   switch (GET_MODE(op0)) {
     default:
/*
 *                 fprintf(stderr, \"Unknown mode:P32EDSrd: %s\n\",
 *                         mode_name[GET_MODE(op0)]);
 */
                  FAIL;
     case E_QImode: fn = gen_P32EDSread_qi_16;
                  break;
     case E_HImode: fn = gen_P32EDSread_hi_16;
                  break;
     case E_SImode: fn = gen_P32EDSread_si_16;
                  unpack=1;
                  break;
     case E_DImode: fn = gen_P32EDSread_di_16;
                  indirect_allowed=0;
                  unpack=1;
                  break;
     case E_SFmode: fn = gen_P32EDSread_sf_16;
                  unpack=1;
                  break;
     case E_DFmode: fn = gen_P32EDSread_df_16;
                  indirect_allowed=0;
                  unpack=1;
                  break;
     case E_P16APSVmode: fn = gen_P32EDSread_p16apsv_16;
                  break;
     case E_P24PSVmode: fn = gen_P32EDSread_p24psv_16;
                  unpack=1;
                  break;
     case E_P24PROGmode: fn = gen_P32EDSread_p24prog_16;
                  unpack=1;
                  break;
     case E_P16PMPmode: fn = gen_P32EDSread_p16pmp_16;
                  unpack=1;
                  break;
     case E_P32EXTmode: fn = gen_P32EDSread_p32ext_16;
                  unpack=1;
                  break;
     case E_P32EDSmode: fn = gen_P32EDSread_p32eds_16;
                  unpack=1;
                  break;
     case E_P32PEDSmode: fn = gen_P32EDSread_p32peds_16;
                  unpack=1;
                  break;
     /* Fractional modes */
     case E_QQmode: fn = gen_P32EDSread_qq_16;
                  break;
     case E_HQmode: fn = gen_P32EDSread_hq_16;
                  break;
     case E_SQmode: fn = gen_P32EDSread_sq_16;
                  unpack=1;
                  break;
     case E_DQmode: fn = gen_P32EDSread_dq_16;
                  unpack=1;
                  break;
     case E_TQmode: fn = gen_P32EDSread_tq_16;
                  unpack=1;
                  break;
     case E_USQmode: fn = gen_P32EDSread_usq_16;
                  unpack=1;
                  break;
     case E_UDQmode: fn = gen_P32EDSread_udq_16;
                  unpack=1;
                  break;
     case E_UTQmode: fn = gen_P32EDSread_utq_16;
                  unpack=1;
                  break;
     case E_HAmode: fn = gen_P32EDSread_ha_16;
                  unpack=1;
                  break;
     case E_SAmode: fn = gen_P32EDSread_sa_16;
                  unpack=1;
                  break;
     case E_DAmode: fn = gen_P32EDSread_da_16;
                  unpack=1;
                  break;
     case E_TAmode: fn = gen_P32EDSread_ta_16;
                  unpack=1;
                  break;
     case E_UHAmode: fn = gen_P32EDSread_uha_16;
                  unpack=1;
                  break;
     case E_USAmode: fn = gen_P32EDSread_usa_16;
                  unpack=1;
                  break;
     case E_UDAmode: fn = gen_P32EDSread_uda_16;
                  unpack=1;
                  break;
     case E_UTAmode: fn = gen_P32EDSread_uta_16;
                  unpack=1;
                  break;
   }
   if ((indirect_allowed == 0) && (pic30_R_operand(op0, GET_MODE(op0)))) {
     op0 = gen_reg_rtx(GET_MODE(op0));
   } else if (!pic30_reg_or_R_operand(op0, GET_MODE(op0))) {
     op0 = gen_reg_rtx(GET_MODE(op0));
   }
   pic30_managed_psv = 1;
   if (!TARGET_EDS) {
     emit_insn(
       gen_copy_psv_16(op3)                                /* preserve PSVPAG */
     );
   }
   if (pic30_R_constraint_strict(op1,0) || pic30_Q_constraint(op1) ||
       pic30_S_constraint_ecore(op1,1)) {
     if (GET_CODE(XEXP(op1,0)) == PLUS) {
       expand_binop(P32EDSmode, add_optab, XEXP(XEXP(op1,0),0),
                    XEXP(XEXP(op1,0),1), op2, 1, OPTAB_DIRECT);
     } else {
       emit_insn(
         gen_movp32eds_gen_16(op2, XEXP(op1,0)) /* copy pointer */
       );
     }
   } else {
     if (pic30_ecore_target() || pic30_isav4_target()) {
       psv_set = 1;
       /* create pointer */
       if (pic30_symbolic_address_operand(XEXP(op1,0),VOIDmode) &&
           pic30_symbolic_address_operand_offset(XEXP(op1,0)) < 1023) {
         char *t = pic30_section_base(XEXP(op1,0),0,0);
         rtx opnd = gen_rtx_CONST_STRING(Pmode, t);
         
         emit_insn(
           gen_movpag_16(XEXP(op1,0), GEN_INT(0))
         );
         emit_insn(
           gen_movEDS_address_offset_16(offset, opnd)
         );
       } else {
         rtx reg = force_reg(P32EDSmode, XEXP(op1,0));

         emit_insn(
           gen_movpag_16(
             simplify_gen_subreg(HImode, reg, GET_MODE(reg), 2), 
             GEN_INT(0)
           )
         );
         emit_move_insn(offset,
                        simplify_gen_subreg(HImode, reg, GET_MODE(reg), 0));
       }
     } else {
       emit_insn(
         gen_movp32eds_address_16(op2, XEXP(op1,0))        /* create pointer */
       );
     }
   }
   if (unpack) {
     rtx op2a = gen_reg_rtx(P32EDSmode);
     emit_insn(
       gen_unpack_EDS_16(op2a,op2)
     );
     op2 = op2a;
   }
   if (!psv_set) {
     emit_move_insn(page, gen_rtx_SUBREG(HImode,op2,2));
     emit_insn(
       gen_set_psv_16(page)                                  /* set PSVPAG */
     );
     emit_move_insn(offset, gen_rtx_SUBREG(HImode,op2,0));
   }
   emit_insn(
     fn(op0, gen_rtx_MEM(GET_MODE(op1),offset))         /* read value */
   );
   if (op0 != operand0) {
     emit_move_insn(operand0, op0);
   }
   if (!TARGET_EDS) {
     emit_insn(
       gen_set_vpsv_16(op3)                                /* restore PSVPAG */
     );
   }
   DONE;
}")

(define_insn "P32PEDSumovoffset_16"
  [(set (match_operand:HI         0 "pic30_register_operand" "=r")
        (subreg:HI
           (match_operand:P32PEDS 1 "pic30_register_operand" " r") 0))]
  "(!pic30_isa32_target())"
  "*
   if (REGNO(operands[1]) != REGNO(operands[0])) return \"mov %1,%0\";
   else return \"; nop\";
  "
)

(define_insn "P32PEDSumovoffset2_16"
  [(set (match_operand:HI           0 "pic30_register_operand"   "=r,&r")
        (subreg:HI
           (plus:P32PEDS
             (match_operand:P32PEDS 1 "pic30_register_operand"   " 0,r")
             (match_operand         2 "immediate_operand"  " J,i")) 0))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add #%2,%0
   mov #%2,%0\;add %0,%1,%0"
)


(define_insn "P32PEDSumovpage_16"
  [(set (match_operand:HI         0 "pic30_register_operand" "=r")
	(subreg:HI
           (match_operand:P32PEDS 1 "pic30_register_operand" " r") 2))]
  "(!pic30_isa32_target())"
  "mov %d1,%0"
)

(define_insn "P32PEDSumovpage2_16"
  [(set (match_operand:HI           0 "pic30_register_operand"   "=r")
        (subreg:HI
           (plus:P32PEDS
             (match_operand:P32PEDS 1 "pic30_register_operand"   " r")
             (match_operand         2 "immediate_operand"  " i")) 2))]
  "(!pic30_isa32_target())"
  "mov %d1,%0"
)


(define_expand "P32PEDSrd_16"
   [(set (match_operand 0 "pic30_move_operand"       "=rR")
         (match_operand 1 "pic30_mem_peds_operand"   " RQST"))]
   "(!pic30_isa32_target())"
   "{
   rtx op2 = gen_reg_rtx(P32PEDSmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op0 = operand0;
   rtx op1 = operand1;
   rtx page = gen_reg_rtx(HImode);
   rtx offset = gen_reg_rtx(HImode);
   rtx (*fn)(rtx, rtx);
   int psv_set=0;
   int no_copy = 0;

   if (GET_MODE(op0) != GET_MODE(op1)) FAIL;
   switch (GET_MODE(op0)) {
     default:
/*
 *                 fprintf(stderr, \"Unknown mode:P32PEDSrd: %s\n\",
 *                         mode_name[GET_MODE(op0)]);
 */
                  FAIL;
     case E_QImode: fn = gen_P32PEDSread_qi_16;
                  break;
     case E_HImode: fn = gen_P32PEDSread_hi_16;
                  break;
     case E_SImode: fn = gen_P32PEDSread_si_16;
                  break;
     case E_DImode: fn = gen_P32PEDSread_di_16;
                  break;
     case E_SFmode: fn = gen_P32PEDSread_sf_16;
                  break;
     case E_DFmode: fn = gen_P32PEDSread_df_16;
                  break;
     case E_P16APSVmode: fn = gen_P32PEDSread_p16apsv_16;
                  break;
     case E_P24PSVmode: fn = gen_P32PEDSread_p24psv_16;
                  break;
     case E_P24PROGmode: fn = gen_P32PEDSread_p24prog_16;
                  break;
     case E_P16PMPmode: fn = gen_P32PEDSread_p16pmp_16;
                  break;
     case E_P32EXTmode: fn = gen_P32PEDSread_p32ext_16;
                  break;
     case E_P32EDSmode: fn = gen_P32PEDSread_p32eds_16;
                  break;
     case E_P32PEDSmode: fn = gen_P32PEDSread_p32peds_16;
                  break;
     /* Fractional modes */
     case E_QQmode: fn = gen_P32PEDSread_qq_16;
                  break;
     case E_HQmode: fn = gen_P32PEDSread_hq_16;
                  break;
     case E_SQmode: fn = gen_P32PEDSread_sq_16;
                  break;
     case E_DQmode: fn = gen_P32PEDSread_dq_16;
                  break;
     case E_TQmode: fn = gen_P32PEDSread_tq_16;
                  break;
     case E_USQmode: fn = gen_P32PEDSread_usq_16;
                  break;
     case E_UDQmode: fn = gen_P32PEDSread_udq_16;
                  break;
     case E_UTQmode: fn = gen_P32PEDSread_utq_16;
                  break;
     case E_HAmode: fn = gen_P32PEDSread_ha_16;
                  break;
     case E_SAmode: fn = gen_P32PEDSread_sa_16;
                  break;
     case E_DAmode: fn = gen_P32PEDSread_da_16;
                  break;
     case E_TAmode: fn = gen_P32PEDSread_ta_16;
                  break;
     case E_UHAmode: fn = gen_P32PEDSread_uha_16;
                  break;
     case E_USAmode: fn = gen_P32PEDSread_usa_16;
                  break;
     case E_UDAmode: fn = gen_P32PEDSread_uda_16;
                  break;
     case E_UTAmode: fn = gen_P32PEDSread_uta_16;
                  break;

   }
   if (!pic30_mode2_operand(op0, GET_MODE(op0))) {
     op0 = gen_reg_rtx(GET_MODE(op0));
   }
   pic30_managed_psv = 1;
   if (!TARGET_EDS) {
     emit_insn(
       gen_copy_psv_16(op3)                                /* preserve PSVPAG */
     );
   }
   if (pic30_R_constraint_strict(op1,0)) {
     switch (GET_MODE(op0)) {
       case E_HImode:
         no_copy = 1;
         op2 = XEXP(op1,0);
         fn = gen_P32PEDSread_hi_16;
         break;
       case E_P32PEDSmode:
         no_copy = 1;
         op2 = XEXP(op1,0);
         fn = gen_P32PEDSread_p32peds_16;
         break;
       default:
         emit_insn(
           gen_movp32peds_gen_16(op2, XEXP(op1,0))              /* copy pointer */
         );
         break;
     }
   } else if (pic30_Q_constraint(op1) || pic30_S_constraint(op1)) {
     rtx inner = XEXP(operands[1],0);

     if (pic30_Q_constraint(op1)) { 
       switch (GET_MODE(op0)) {
         case E_HImode:
           no_copy = 1;
           op2 = XEXP(op1,0);
           fn = gen_P32PEDSread_hi_16;
           break;
         case E_P32PEDSmode:
           no_copy = 1;
           op2 = XEXP(op1,0);
           fn = gen_P32PEDSread_p32peds_16;
           break;
         default:
           emit_insn(
             gen_addp32peds3_16(op2, XEXP(inner,0), XEXP(inner,1))
           );
       }
     } else {
       emit_insn(
         gen_addp32peds3_16(op2, XEXP(inner,0), XEXP(inner,1))
       );
     }
   } else {
     if (pic30_ecore_target() || pic30_isav4_target()) {
       char *t = pic30_section_base(XEXP(op1,0),0,0);
       rtx opnd = gen_rtx_CONST_STRING(Pmode, t);
       psv_set=1;
       emit_insn(
         gen_movEDS_address_offset_16(                    /* create pointer */
           offset, 
           opnd)
       );
       offset = gen_rtx_MEM(GET_MODE(op1),offset);
       emit_insn(
         gen_movpag_16(XEXP(op1,0), GEN_INT(0))
       );
     } else {
       emit_insn(
         gen_movp32peds_address_16(op2, XEXP(op1,0))        /* create pointer */
       );
     }
   }
   if (!psv_set) {
     if (!TARGET_EDS) {
       emit_move_insn(page, gen_rtx_SUBREG(HImode,op2,2));
       emit_insn(
         gen_set_psv_16(page)                                  /* set PSVPAG */
       );
       emit_move_insn(offset, gen_rtx_SUBREG(HImode,op2,0));
       offset = gen_rtx_MEM(GET_MODE(op1),offset);
     } else {
       if (no_copy) {
         if (GET_CODE(op2) == PLUS) {
           emit_insn(
             gen_set_unpsv_16(XEXP(op2,0))                       /* set PSVPAG */
           );
         } else {
           emit_insn(
             gen_set_unpsv_16(op2)                               /* set PSVPAG */
           );
         }
         // operands[1] == MEM:mode (P32PEDS)
         offset = gen_rtx_MEM(GET_MODE(op1),gen_rtx_SUBREG(HImode,op2,0));
       } else {
         emit_insn(
           gen_P32PEDSumovpage_16(page,op2)
         );
         emit_insn(
           gen_set_psv_16(page)                                  /* set PSVPAG */
         );
         emit_insn(
           gen_P32PEDSumovoffset_16(offset,op2)
         );
         offset = gen_rtx_MEM(GET_MODE(op1),offset);
       }
     }
   }
   emit_insn(
     fn(op0, offset)                                         /* read value */
   );
   if (op0 != operand0) {
     emit_move_insn(operand0, op0);
   }
   if (!TARGET_EDS) {
     emit_insn(
       gen_set_psv_16(op3)                                 /* restore PSVPAG */
     );
   }
   DONE;
}")

(define_expand "P32EDSwt_16"
   [(set (match_operand 0 "pic30_mem_eds_operand"   "=RQ,ST")
         (match_operand 1 "pic30_move_operand"       " rR,rR"))]
   "(!pic30_isa32_target())"
   "{
   rtx op2 = gen_reg_rtx(P32EDSmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1 = operand1;
   rtx op0 = operand0;
   rtx page = gen_reg_rtx(HImode);
   rtx offset = gen_reg_rtx(HImode);
   rtx (*fn)(rtx, rtx);
   int eds_target = pic30_eds_target();
   int unpack=0;

   if ((GET_CODE(XEXP(op0,0)) == POST_INC) &&
       (REGNO(XEXP(XEXP(op0,0),0)) == SP_REGNO)) {
     /* this is a stack write that can only be generated with -munified
        (which changes the Pmode to P32EDSmode) - change it back to a normal
        write */
     switch (GET_MODE(op0)) {
       default:
/*
 *                   fprintf(stderr, \"Unknown mode:P32EDSwt: %s\n\",
 *                           mode_name[GET_MODE(op0)]);
 */
                    FAIL;
       case E_QImode: fn = gen_movqi_16;
                    break;
       case E_HImode: fn = gen_movhi_16;
                    break;
       case E_SImode: fn = gen_movsi_16;
                    break;
       case E_DImode: fn = gen_movdi_16;
                    break;
       case E_SFmode: fn = gen_movsf_16;
                    break;
       case E_DFmode: fn = gen_movdf_16;
                    break;
       case E_P16APSVmode: fn = gen_movp16apsv_16;
                    break;
       case E_P24PSVmode: fn = gen_movp24psv_16;
                    break;
       case E_P24PROGmode: fn = gen_movp24prog_16;
                    break;
       case E_P16PMPmode: fn = gen_movp16pmp_16;
                    break;
       case E_P32EXTmode: fn = gen_movp32ext_16;
                    break;
       case E_P32EDSmode: fn = gen_movp32eds_16;
                    break;
       case E_P32PEDSmode: fn = gen_movp32peds_16;
                    break;
       /* Fractional modes */
       case E_QQmode: fn = gen_movqq_16;
                    break;
       case E_HQmode: fn = gen_movhq_16;
                    break;
       case E_SQmode: fn = gen_movsq_16;
                    break;
       case E_DQmode: fn = gen_movdq_16;
                    break;
       case E_TQmode: fn = gen_movtq_16;
                    break;
       case E_USQmode: fn = gen_movusq_16;
                    break;
       case E_UDQmode: fn = gen_movudq_16;
                    break;
       case E_UTQmode: fn = gen_movutq_16;
                    break;
       case E_HAmode: fn = gen_movha_16;
                    break;
       case E_SAmode: fn = gen_movsa_16;
                    break;
       case E_DAmode: fn = gen_movda_16;
                    break;
       case E_TAmode: fn = gen_movta_16;
                    break;
       case E_UHAmode: fn = gen_movuha_16;
                    break;
       case E_USAmode: fn = gen_movusa_16;
                    break;
       case E_UDAmode: fn = gen_movuda_16;
                    break;
       case E_UTAmode: fn = gen_movuta_16;
                    break;

     }

     if (fn(gen_rtx_MEM(GET_MODE(op0),
                        gen_rtx_POST_INC(HImode,gen_rtx_REG(HImode, SP_REGNO))),
            op1))
       DONE;
     FAIL;
   }
   if (GET_MODE(op0) != GET_MODE(op1)) FAIL;
   switch (GET_MODE(op0)) {
     default:
/*
 *                 fprintf(stderr, \"Unknown mode:P32EDSwt(2): %s\n\",
 *                         mode_name[GET_MODE(op0)]);
 */
                  FAIL;
     case E_QImode: fn = gen_P32EDSwrite_qi_16;
                  break;
     case E_HImode: fn = gen_P32EDSwrite_hi_16;
                  break;
     case E_SImode: fn = gen_P32EDSwrite_si_16;
                  unpack=1;
                  break;
     case E_DImode: fn = gen_P32EDSwrite_di_16;
                  unpack=1;
                  break;
     case E_SFmode: fn = gen_P32EDSwrite_sf_16;
                  unpack=1;
                  break;
     case E_DFmode: fn = gen_P32EDSwrite_df_16;
                  unpack=1;
                  break;
     case E_P16APSVmode: fn = gen_P32EDSwrite_p16apsv_16;
                  unpack=1;
                  break;
     case E_P24PSVmode: fn = gen_P32EDSwrite_p24psv_16;
                  unpack=1;
                  break;
     case E_P24PROGmode: fn = gen_P32EDSwrite_p24prog_16;
                  unpack=1;
                  break;
     case E_P16PMPmode: fn = gen_P32EDSwrite_p16pmp_16;
                  break;
     case E_P32EXTmode: fn = gen_P32EDSwrite_p32ext_16;
                  unpack=1;
                  break;
     case E_P32EDSmode: fn = gen_P32EDSwrite_p32eds_16;
                  unpack=1;
                  break;
     case E_P32PEDSmode: fn = gen_P32EDSwrite_p32peds_16;
                  unpack=1;
                  break;
     /* Fractional modes */
     case E_QQmode: fn = gen_P32EDSwrite_qq_16;
                  break;
     case E_HQmode: fn = gen_P32EDSwrite_hq_16;
                  break;
     case E_SQmode: fn = gen_P32EDSwrite_sq_16;
                  unpack=1;
                  break;
     case E_DQmode: fn = gen_P32EDSwrite_dq_16;
                  unpack=1;
                  break;
     case E_TQmode: fn = gen_P32EDSwrite_tq_16;
                  unpack=1;
                  break;
     case E_USQmode: fn = gen_P32EDSwrite_usq_16;
                  unpack=1;
                  break;
     case E_UDQmode: fn = gen_P32EDSwrite_udq_16;
                  unpack=1;
                  break;
     case E_UTQmode: fn = gen_P32EDSwrite_utq_16;
                  unpack=1;
                  break;
     case E_HAmode: fn = gen_P32EDSwrite_ha_16;
                  unpack=1;
                  break;
     case E_SAmode: fn = gen_P32EDSwrite_sa_16;
                  unpack=1;
                  break;
     case E_DAmode: fn = gen_P32EDSwrite_da_16;
                  unpack=1;
                  break;
     case E_TAmode: fn = gen_P32EDSwrite_ta_16;
                  unpack=1;
                  break;
     case E_UHAmode: fn = gen_P32EDSwrite_uha_16;
                  unpack=1;
                  break;
     case E_USAmode: fn = gen_P32EDSwrite_usa_16;
                  unpack=1;
                  break;
     case E_UDAmode: fn = gen_P32EDSwrite_uda_16;
                  unpack=1;
                  break;
     case E_UTAmode: fn = gen_P32EDSwrite_uta_16;
                  unpack=1;
                  break;

   }
   if (!pic30_mode2_operand(op1, GET_MODE(op1))) {
     op1 = gen_reg_rtx(GET_MODE(op1));
     emit_move_insn(op1, operand1);
   }
   if (eds_target) {
     pic30_managed_psv = 1;
   }
   if (pic30_R_constraint_strict(op0,0) || pic30_Q_constraint(op0) ||
       pic30_S_constraint_ecore(op0,1)) {
     if (GET_CODE(XEXP(op0,0)) == PLUS) {
       expand_binop(P32EDSmode, add_optab, XEXP(XEXP(op0,0),0),
                    XEXP(XEXP(op0,0),1), op2, 1, OPTAB_DIRECT);
     } else {
       emit_insn(
         gen_movp32eds_gen_16(op2, XEXP(op0,0)) /* copy pointer */
       );
     }
   } else {
     emit_insn(
       gen_movp32eds_address_16(op2, XEXP(op0,0))          /* create pointer */
     );
   }
   if (unpack) {
     rtx op2a = gen_reg_rtx(P32EDSmode);
     emit_insn(
       gen_unpack_EDS_16(op2a,op2)
     );
     op2 = op2a;
   }
   if (eds_target) {
     if (!TARGET_EDS) {
       emit_insn(
         gen_copy_dsw_16(op3)                              /* preserve PSVPAG */
       );
     }
     if (!TARGET_EDS) {
       emit_move_insn(page, gen_rtx_SUBREG(HImode,op2,2));
     } else {
       emit(
         gen_P32PEDSumovpage_16(page, op2)
       );
     }
   }
   if (!TARGET_EDS) {
     emit_move_insn(offset, gen_rtx_SUBREG(HImode,op2,0));
   } else {
     emit(
       gen_P32PEDSumovoffset_16(offset,op2)
     );
   }
   if (eds_target) {
     emit_insn(
       gen_set_dsw_16(page)                                /* set PSVPAG */
     );
   }
   emit_insn(
     fn(gen_rtx_MEM(GET_MODE(op0),offset), op1)         /* write value */
   );
   if (eds_target) {
     if (!TARGET_EDS) {
       emit_insn(
         gen_set_dsw_16(op3)                               /* restore PSVPAG */
       );
     }
   }
   DONE;
}")

(define_expand "P32PEDSwt_16"
   [(set (match_operand 0 "pic30_mem_peds_operand"   "=RQ,ST")
         (match_operand 1 "pic30_move_operand"       " rR,rR"))]
   "(!pic30_isa32_target())"
   "{  
   rtx op2 = gen_reg_rtx(P32PEDSmode);
   rtx op3 = gen_reg_rtx(HImode);
   rtx op1 = operand1;
   rtx op0 = operand0;
   rtx page = gen_reg_rtx(HImode);
   rtx offset = gen_reg_rtx(HImode);
   rtx (*fn)(rtx, rtx);
   int eds_target = pic30_eds_target();
   int copy = 1;

   if (GET_MODE(op0) != GET_MODE(op1)) FAIL;
   switch (GET_MODE(op0)) {
     default:
/*
 *                 fprintf(stderr, \"Unknown mode:P32PEDSwt: %s\n\", 
 *                         mode_name[GET_MODE(op0)]);
 */
                  FAIL;
     case E_QImode: fn = gen_P32PEDSwrite_qi_16;
                  break;
     case E_HImode: fn = gen_P32PEDSwrite_hi_16;
                  break;
     case E_SImode: fn = gen_P32PEDSwrite_si_16;
                  break;
     case E_DImode: fn = gen_P32PEDSwrite_di_16;
                  break;
     case E_SFmode: fn = gen_P32PEDSwrite_sf_16;
                  break;
     case E_DFmode: fn = gen_P32PEDSwrite_df_16;
                  break;
     case E_P16APSVmode: fn = gen_P32PEDSwrite_p16apsv_16;
                  break;
     case E_P24PSVmode: fn = gen_P32PEDSwrite_p24psv_16;
                  break;
     case E_P24PROGmode: fn = gen_P32PEDSwrite_p24prog_16;
                  break;
     case E_P16PMPmode: fn = gen_P32PEDSwrite_p16pmp_16;
                  break;
     case E_P32EXTmode: fn = gen_P32PEDSwrite_p32ext_16;
                  break;
     case E_P32EDSmode: fn = gen_P32PEDSwrite_p32eds_16;
                  break;
     case E_P32PEDSmode: fn = gen_P32PEDSwrite_p32peds_16;
                  break;
     /* Fractional modes */
     case E_QQmode: fn = gen_P32PEDSwrite_qq_16;
                  break;
     case E_HQmode: fn = gen_P32PEDSwrite_hq_16;
                  break;
     case E_SQmode: fn = gen_P32PEDSwrite_sq_16;
                  break;
     case E_DQmode: fn = gen_P32PEDSwrite_dq_16;
                  break;
     case E_TQmode: fn = gen_P32PEDSwrite_tq_16;
                  break;
     case E_USQmode: fn = gen_P32PEDSwrite_usq_16;
                  break;
     case E_UDQmode: fn = gen_P32PEDSwrite_udq_16;
                  break;
     case E_UTQmode: fn = gen_P32PEDSwrite_utq_16;
                  break;
     case E_HAmode: fn = gen_P32PEDSwrite_ha_16;
                  break;
     case E_SAmode: fn = gen_P32PEDSwrite_sa_16;
                  break;
     case E_DAmode: fn = gen_P32PEDSwrite_da_16;
                  break;
     case E_TAmode: fn = gen_P32PEDSwrite_ta_16;
                  break;
     case E_UHAmode: fn = gen_P32PEDSwrite_uha_16;
                  break;
     case E_USAmode: fn = gen_P32PEDSwrite_usa_16;
                  break;
     case E_UDAmode: fn = gen_P32PEDSwrite_uda_16;
                  break;
     case E_UTAmode: fn = gen_P32PEDSwrite_uta_16;
                  break;

   }
   if (!pic30_mode2_operand(op1, GET_MODE(op1))) {
     op1 = gen_reg_rtx(GET_MODE(op1));
     emit_move_insn(op1, operand1);
   }
   if (eds_target) {
     pic30_managed_psv = 1;
   }
   if (pic30_R_constraint_strict(op0,0)) {
     emit_insn(
       gen_movp32peds_gen_16(op2, XEXP(op0,0))              /* copy pointer */
     );
   } else if (pic30_Q_constraint(op0) || pic30_S_constraint(op0)) {
     rtx inner = XEXP(operands[0],0);

     if (pic30_Q_constraint(op0)) {
       switch (GET_MODE(op1)) {
         case E_HImode:
           op2 = XEXP(op0,0);
           fn = gen_P32PEDSwrite_hi_16;
           break;
         case E_P32EDSmode:
           op2 = XEXP(op0,0);
           fn = gen_P32PEDSwrite_p32eds_16;
           break;
         case E_P32PEDSmode:
           op2 = XEXP(op0,0);
           fn = gen_P32PEDSwrite_p32peds_16;
           break;
         default:
           emit_insn(
             gen_addp32peds3_16(op2, XEXP(inner,0), XEXP(inner,1))
           );
       }
     } else {
       emit_insn(
         gen_addp32peds3_16(op2, XEXP(inner,0), XEXP(inner,1))
       );
     }
   } else {
     copy = 0;
     char *t = pic30_section_base(XEXP(op0,0),0,0);
     rtx opnd = gen_rtx_CONST_STRING(Pmode, t);
     emit_insn(
       gen_movEDS_address_offset_16( offset, opnd)
     );
     t = pic30_section_base(XEXP(op0,0),1,0);
     opnd = gen_rtx_CONST_STRING(Pmode, t);
     emit_insn(
       gen_movEDS_address_page_16(
         page,
         opnd, GEN_INT(0))
     );
   }
   if (eds_target) {
     if (!TARGET_EDS) {
       emit_insn(
         gen_copy_dsw_16(op3)                              /* preserve PSVPAG */
       );
     }
     if (copy) {
       if (!TARGET_EDS) {
         emit_move_insn(page, gen_rtx_SUBREG(HImode,op2,2));
       } else {
         emit(
           gen_P32PEDSumovpage_16(page, op2)
         );
       }
     }
   }
   if (eds_target) {
     emit_insn(
       gen_set_dsw_16(page)                                /* set PSVPAG */
     );
   }
   if (copy) {
     if (!TARGET_EDS) {
       emit_move_insn(offset, gen_rtx_SUBREG(HImode,op2,0));
     } else {
       emit(
         gen_P32PEDSumovoffset_16(offset,op2)
       );
     }
   }
   emit_insn(
     fn(gen_rtx_MEM(GET_MODE(op0),offset), op1)         /* write value */
   );
   if (eds_target) {
     if (!TARGET_EDS) {
       emit_insn(
         gen_set_dsw_16(op3)                               /* restore PSVPAG */
       );
     }
   }
   DONE;
}")

;; unified 

;; read/write pointer will handle the full pointer value

(define_insn "p32umm_offset_16"
 [(set (match_operand:HI       0 "pic30_register_operand"       "=r,r")
       (utrunc:HI
         (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address" "r,qs")))
   (clobber (reg:CC_NZC CC_REG))
 ]
 "(TARGET_EDS)"
 "@
  rrnc %1,%0
  mov #edsoffset(%1),%0"
)

(define_insn "p32umm_readpointer_16"
 [(set (match_operand:HI       0 "pic30_register_operand"       "=r,r")
       (utrunc:HI
         (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address" "r,qs")))
  (set (reg:HI PSVPAG)
         (unspec_volatile:HI [
            (match_dup 1)
          ] UNSPEC_UMMPAGE))
  (clobber (reg:CC_NZC CC_REG))
 ]
 "(TARGET_EDS)"
 "@
  mov %d1,%u0\;rrnc %1,%0
  mov #unified_hi(%1),%0\;mov %0,%u0\;mov #edsoffset(%1),%0"
)

(define_insn "p32umm_writepointer_16"
 [(set (match_operand:HI       0 "pic30_register_operand"       "=r,r")
       (utrunc:HI
         (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address" "r,qs")))
  (set (reg:HI DSWPAG)
         (unspec_volatile:HI [
            (match_dup 1)
          ] UNSPEC_UMMPAGE))
  (clobber (reg:CC_NZC CC_REG))
 ]
 "(TARGET_EDS)"
 "*
  if (pic30_ecore_target()||pic30_isav4_target()) {
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:
        return \"mov %d1,DSWPAG\;\"
               \"rrnc %1,%0\";
      case 1:
        return \"mov #unified_hi(%1),%0\;\"
               \"mov %0,DSWPAG\;\"
               \"mov #edsoffset(%1),%0\";
    }
  } else {
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:
        return \"rrnc %1,%0\";
      case 1:
        return \"mov #edsoffset(%1),%0\";
    }
  }"
)

(define_insn "p32umm_rwpointer_16"
 [(set (match_operand:HI       0 "pic30_register_operand"       "=r,r")
       (utrunc:HI
         (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address" "r,qs")))
  (set (reg:HI PSVPAG)
         (unspec_volatile:HI [
            (match_dup 1)
          ] UNSPEC_UMMPAGE))
  (set (reg:HI DSWPAG)
         (unspec_volatile:HI [
            (match_dup 1)
          ] UNSPEC_UMMPAGE))
  (clobber (reg:CC_NZC CC_REG))
 ]
 "(TARGET_EDS)"
 "*
  if (pic30_ecore_target()||pic30_isav4_target()) {
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:
        return \"mov %d1,DSWPAG\;\"
               \"mov %d1,%u0\;\"
               \"rrnc %1,%0\";
      case 1:
        return \"mov #unified_hi(%1),%0\;\"
               \"mov %0,DSWPAG\;\"
               \"mov %0,%u0\;\"
               \"mov #edsoffset(%1),%0\";
    }
  } else {
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:
        return \"mov %d1,%u0\;\"
               \"rrnc %1,%0\";
      case 1:
        return \"mov #unified_hi(%1),%0\;\"
               \"mov %0,%u0\;\"
               \"mov #edsoffset(%1),%0\";
    }
  }"
)

; as above, but with a MEM

(define_insn "p32umm_offsetmem_16"
 [(set (match_operand:HI       0 "pic30_register_operand" "=r,  r,r,r")
       (utrunc:HI
         (match_operand:P32UMM 1 "pic30_mem_umm_operand"  " R<>,Q,S,Um")))
  (clobber (reg:CC_NZC CC_REG))
 ]
 "(TARGET_EDS)"
 "*
  { static char buffer[256]; 
    rtx mem_inner = XEXP(operands[1],0);
    int val;
    const char *op;
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  /* R<> */
               return \"rrnc %r1,%0\";
      case 1:  /* Q */ 
               val = INTVAL(XEXP(mem_inner,1));
               op = (val >= 0) ? \"add\" : \"sub\";
               if (val < 0) val = -val;
               sprintf(buffer,
                      \"rrnc %%r1,%%0\;\"
                      \"%s #%d,%%0\", op, val);
               return buffer;
      case 2:  /* S */
               sprintf(buffer,
                      \"add %%r1,w%d,%%0\;\"
                      \"rrnc %%0,%%0\", REGNO(XEXP(mem_inner,1)));
               return buffer;
      case 3:  /* UT */
               return 
                      \"mov #edsoffset(%1),%0\";
    }
  }"
)

(define_insn "p32umm_updateoffset_16"
 [(set (match_operand:P32UMM 0 "pic30_register_operand"  "+r")
       (unspec:P32UMM [
          (match_operand:HI  1 "pic30_register_operand"   "r")
        ] UNSPEC_UMMOFFSET))
  (clobber (reg:CC_NZC CC_REG))
 ]
 "(TARGET_EDS)"
 "rlnc %1,%0"
)

(define_insn "p32umm_readmem_16"
 [(set (match_operand:HI       0 "pic30_register_operand" "=&r,&r,&r,&r")
       (utrunc:HI
         (match_operand:P32UMM 1 "pic30_mem_umm_operand"  " R<>,Q, S,qm")))
  (set (reg:HI PSVPAG)
         (unspec_volatile:HI [
            (match_dup 1)
          ] UNSPEC_UMMPAGE))
  (clobber (match_scratch:HI   2                          "=X, &r,&r,X"))
  (clobber (match_scratch:HI   3                          "=X, &r,X,X"))
  (clobber (reg:CC_NZC CC_REG))
 ]
 "(TARGET_EDS)"
 "*
  { static char buffer[256]; 
    rtx mem_inner = XEXP(operands[1],0);
    int val,is_add;
    const char *op,*op2;
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  /* R<> */
               if (pic30_extended_ram_target() && (TARGET_BIG)) {
                 /* page == 0, pre-init to 1 */
                 return \"mov %T1,%u0\;\"
                        \"btss %r1,#0\;\"
                        \"inc %u0\;\"
                        \"rrnc %r1,%0\";
               } else {
                 return \"mov %T1,%u0\;rrnc %r1,%0\";
               }
      case 1:  /* Q */
               val = INTVAL(XEXP(mem_inner,1));
               is_add = 1;
               op = \"add\";
               if (val < 0) {
                 op = \"sub\";
                 is_add = 0;
                 val = -val;
               }
               if (pic30_extended_ram_target()) {
                 if (TARGET_BIG) {
                   if ((val * 2) < 31) {
                     if (is_add) {
                       /* adding - must check for overflow and
                        *          potential overflow (preset page 1)
                        */
                       sprintf(buffer,
                             \"add %%r1,#%d,%%0\;\"     /* add low */
                             \"and.b #0,%%3\;\"         /* write to bit 0 and
                                                           clear Z */
                             \"addc %%T1,#0,%%2\;\"     /* overflow to PAGE */
                             \"bsw.z %%0,%%3\;\"        /* assert PSV bit */
                             \"btsc _SR,#1\;\"          /* if PAGE 0  */
                             \"inc %%2,%%2\;\"          /*   prep for ovflow */
                             \"mov %%2,%%u0\;\"
                             \"rrnc %%0,%%0\;\", val*2);
                     } else {
                       /* subtract - must check for underflow and
                        */
                       sprintf(buffer,
                             \"sub %%r1,#%d,%%0\;\"     /* add low */
                             \"and.b #0,%%3\;\"         /* write to bit 0 and
                                                           clear Z */
                             \"subb %%T1,#0,%%2\;\"     /* overflow to PAGE */
                             \"bsw.z %%0,%%3\;\"        /* assert PSV bit */
                             \"mov %%2,%%u0\;\"
                             \"rrnc %%0,%%0\;\", val*2);
                     }
                   } else { 
                     if (is_add) {
                       /* adding - must check for overflow and
                        *          potential overflow (preset page 1)
                        */
                       sprintf(buffer,
                             \"mov #%d,%%2\;\"
                             \"add %%r1,%%2,%%0\;\"     /* add low */
                             \"and.b #0,%%3\;\"         /* write to bit 0 and
                                                           clear Z */
                             \"addc %%T1,#0,%%2\;\"     /* overflow to PAGE */
                             \"bsw.z %%0,%%3\;\"        /* assert PSV bit */
                             \"btsc _SR,#1\;\"          /* if PAGE 0  */
                             \"inc %%2,%%2\;\"          /*   prep for ovflow */
                             \"mov %%2,%%u0\;\"
                             \"rrnc %%0,%%0\;\", val*2);
                     } else {
                       /* subtract - must check for underflow and 
                        *            potential overflow (preset page 1)
                        */
                       sprintf(buffer,
                             \"mov #%d,%%2\;\"
                             \"sub %%r1,%%2,%%0\;\"     /* add low */
                             \"and.b #0,%%3\;\"         /* write to bit 0 and
                                                           clear Z */
                             \"subb %%T1,#0,%%2\;\"     /* overflow to PAGE */
                             \"bsw.z %%0,%%3\;\"        /* assert PSV bit */
                             \"mov %%2,%%u0\;\"
                             \"rrnc %%0,%%0\;\", val*2);
                     }
                   }
                 } else {
                   if ((val * 2) < 31) {
                     sprintf(buffer,
                             \"%s %%r1,#%d,%%0\;\"
                             \"mov %%T1,%%u0\;\"
                             \"rrnc %%0,%%0\;\", op, val*2);
                   } else {
                     sprintf(buffer,
                             \"mov #%d,%%2\;\"
                             \"%s %%r1,%%2,%%0\;\"
                             \"mov %%T1,%%u0\;\"
                             \"rrnc %%0,%%0\;\", val*2, op);
                   }
                 }
               } else {
                 if ((val * 2) < 31) {
                   sprintf(buffer, 
                           \"%s %%r1,#%d,%%0\;\"
                           \"rrnc %%0,%%0\;\", op, val*2);
                 } else {
                   sprintf(buffer, 
                           \"mov #%d,%%2\;\"
                           \"%s %%r1,%%2,%%0\;\"
                           \"rrnc %%0,%%0\;\", val*2, op);
                 }
               }
               return buffer;
      case 2:  /* S */
               if (pic30_extended_ram_target() && (TARGET_BIG)) {
                 sprintf(buffer,
                         \"add %%r1,w%d,%%0\;\"
                         \"bclr %%0,#0\;\"
                         \"bset _SR,#1\;\"
                         \"addc %%T1,w%d,%%2\;\"
                         \"btss _SR,#1\;\"
                         \"bset %%0,#0\;\"
                         \"btsc _SR,#1\;\"
                         \"inc %%2,%%2\;\"
                         \"mov %%2,%%u0\;\"
                         \"rrnc %%0,%%0\", REGNO(XEXP(mem_inner,1)), 
                                           REGNO(XEXP(mem_inner,1))+1);
               } else if (TARGET_BIG) {
                 sprintf(buffer,
                         \"add %%r1,w%d,%%0\;\"
                         \"bclr %%0,#0\;\"
                         \"bset _SR,#1\;\"
                         \"addc %%T1,w%d,%%2\;\"
                         \"btss _SR,#1\;\"
                         \"bset %%0,#0\;\"
                         \"mov %%2,%%u0\;\"
                         \"rrnc %%0,%%0\", REGNO(XEXP(mem_inner,1)), 
                                           REGNO(XEXP(mem_inner,1))+1);
               } else {
                 /* offsest must be < 32K (and not overflow the page),
                    PSV bit (unpacked bit 0) will not change */
                 sprintf(buffer,
                         \"add %%r1,w%d,%%0\;\"
                         \"mov %%T1,%%u0\;\"
                         \"rrnc %%0,%%0\", REGNO(XEXP(mem_inner,1)));
               }
               return buffer;
      case 3:  /* UT */
               return \"mov #unified_hi(%1),%0\;\"
                      \"mov %0,%u0\;\"
                      \"mov #edsoffset(%1),%0\";
    }
  }"
)

(define_insn "p32umm_writemem_16"
 [(set (match_operand:HI       0 "pic30_register_operand" "= &r, &r,&r,&r,&r")
       (utrunc:HI
         (match_operand:P32UMM 1 "pic30_mem_umm_operand"  "  R<>, Q, S, U,qm")))
  (set (reg:HI DSWPAG)
         (unspec_volatile:HI [
            (match_dup 1)
          ] UNSPEC_UMMPAGE))
  (clobber (match_scratch:HI   2                          "=X,   &r,&r, X, X"))
  (clobber (match_scratch:HI   3                          "=X,   &r, X, X, X"))
  (clobber (reg:CC_NZC CC_REG))
 ]
 "(TARGET_EDS)"
 "*
  { static char buffer[256]; 
    rtx mem_inner = XEXP(operands[1],0);
    int val,is_add;
    const char *op,*op2;
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  /* R<> */
               if (pic30_extended_ram_target()) {
                 if (TARGET_BIG) {
                   return \"mov %T1,DSWPAG\;\"
                          \"btss %r1,#0\;\"
                          \"inc DSWPAG\;\"
                          \"rrnc %r1,%0\";
                 } else {
                   return \"mov %T1,DSWPAG\;\"
                          \"rrnc %r1,%0\";
                 }
               } else {
                  return \"rrnc %r1,%0\";
               }
      case 1:  /* Q */
               val = INTVAL(XEXP(mem_inner,1));
               is_add = 1;
               op = \"add\";
               if (val < 0) {
                 op = \"sub\";
                 is_add = 0;
                 val = -val;
               }
               if (pic30_extended_ram_target()) {
                 if (TARGET_BIG) {
                   if ((val * 2) < 31) {
                     if (is_add) {
                       /* adding - must check for overflow and
                        *          potential overflow (preset page 1)
                        */
                       sprintf(buffer,
                             \"add %%r1,#%d,%%0\;\"     /* add low */
                             \"and.b #0,%%3\;\"         /* write to bit 0 and
                                                           clear Z */
                             \"addc %%T1,#0,%%2\;\"     /* overflow to PAGE */
                             \"bsw.z %%0,%%3\;\"        /* assert PSV bit */
                             \"btsc _SR,#1\;\"          /* if PAGE 0  */
                             \"inc %%2,%%2\;\"          /*   prep for ovflow */
                             \"mov %%2,DSWPAG\;\"
                             \"rrnc %%0,%%0\;\", val*2);
                     } else {
                       /* subtract - must check for underflow and
                        *            potential overflow (preset page 1)
                        */
                       sprintf(buffer,
                             \"sub %%r1,#%d,%%0\;\"     /* add low */
                             \"and.b #0,%%3\;\"         /* write to bit 0 and
                                                           clear Z */
                             \"subb %%T1,#0,%%2\;\"     /* overflow to PAGE */
                             \"bsw.z %%0,%%3\;\"        /* assert PSV bit */
                             \"mov %%2,DSWPAG\;\"
                             \"rrnc %%0,%%0\;\", val*2);
                     }
                   } else {
                     if (is_add) {
                       /* adding - must check for overflow and
                        *          potential overflow (preset page 1)
                        */
                       sprintf(buffer,
                             \"mov #%d,%%2\;\"
                             \"add %%r1,%%2,%%0\;\"     /* add low */
                             \"and.b #0,%%3\;\"         /* write to bit 0 and
                                                           clear Z */
                             \"addc %%T1,#0,%%2\;\"     /* overflow to PAGE */
                             \"bsw.z %%0,%%3\;\"        /* assert PSV bit */
                             \"btsc _SR,#1\;\"          /* if PAGE 0  */
                             \"inc %%2,%%2\;\"          /*   prep for ovflow */
                             \"mov %%2,DSWPAG\;\"
                             \"rrnc %%0,%%0\;\", val*2);
                     } else {
                       /* subtract - must check for underflow and
                        *            potential overflow (preset page 1)
                        */
                       sprintf(buffer,
                             \"mov #%d,%%2\;\"
                             \"sub %%r1,%%2,%%0\;\"     /* add low */
                             \"and.b #0,%%3\;\"         /* write to bit 0 and
                                                           clear Z */
                             \"subb %%T1,#0,%%2\;\"     /* overflow to PAGE */
                             \"bsw.z %%0,%%3\;\"        /* assert PSV bit */
                             \"mov %%2,DSWPAG\;\"
                             \"rrnc %%0,%%0\;\", val*2);
                     }
                   }
                 } else {
                   if ((val * 2) < 31) {
                     sprintf(buffer,
                             \"%s %%r1,#%d,%%0\;\"
                             \"mov %%T1,DSWPAG\;\"
                             \"rrnc %%0,%%0\;\", op, val*2);
                   } else {
                     sprintf(buffer,
                             \"mov #%d,%%2\;\"
                             \"%s %%r1,%%2,%%0\;\"
                             \"mov %%T1,DSWPAG\;\"
                             \"rrnc %%0,%%0\;\", val*2, op);
                   }
                 }
               } else {
                 if ((val * 2) < 31) {
                   sprintf(buffer,
                           \"%s %%r1,#%d,%%0\;\"
                           \"rrnc %%0,%%0\;\", op, val*2);
                 } else {
                   sprintf(buffer,
                           \"mov #%d,%%2\;\"
                           \"%s %%r1,%%2,%%0\;\"
                           \"rrnc %%0,%%0\;\", val*2, op);
                 }
               } 
               return buffer;
      case 2:  /* S */
               if (pic30_extended_ram_target()) {
                  if (TARGET_BIG) {
                    sprintf(buffer,
                            \"add %%r1,w%d,%%0\;\"
                            \"bclr %%0,#0\;\"
                            \"bset _SR,#1\;\"
                            \"addc %%T1,w%d,%%2\;\"
                            \"btss _SR,#1\;\"
                            \"bset %%0,#0\;\"
                            \"btsc _SR,#1\;\"
                            \"inc %%2,%%2\;\"
                            \"mov %%2,DSWPAG\;\"
                            \"rrnc %%0,%%0\", REGNO(XEXP(mem_inner,1)),
                                              REGNO(XEXP(mem_inner,1))+1);
 		 } else {
                    sprintf(buffer,
                            \"add %%r1,w%d,%%0\;\"
                            \"addc %%T1,w%d,%%2\;\"
                            \"mov %%2,DSWPAG\;\"
                            \"rrnc %%0,%%0\", REGNO(XEXP(mem_inner,1)),
                                              REGNO(XEXP(mem_inner,1))+1);
                  }
               } else {
                 sprintf(buffer,
                         \"add %%r1,w%d,%%0\;\"
                         \"rrnc %%0,%%0\", REGNO(XEXP(mem_inner,1)));
               }
               return buffer;
      case 3:  /* U */
               return \"mov #edsoffset(%1),%0\";
      case 4:  /* T */
               if (pic30_extended_ram_target()) {
                 return \"mov #unified_hi(%1),%0\;\"
                        \"mov %0,DSWPAG\;\"
                        \"mov #edsoffset(%1),%0\";
               } else {
                 return \"mov #edsoffset(%1),%0\";
               }
    }
  }"
)

(define_insn "p32umm_rwmem_16"
 [(set (match_operand:HI       0 "pic30_register_operand" "=&r,&r,&r,&r,&r")
       (utrunc:HI
         (match_operand:P32UMM 1 "pic30_mem_umm_operand"  " R<>,Q,S,U,m")))
  (set (reg:HI PSVPAG)
         (unspec_volatile:HI [
            (match_dup 1)
          ] UNSPEC_UMMPAGE))
  (set (reg:HI DSWPAG)
         (unspec_volatile:HI [
            (match_dup 1)
          ] UNSPEC_UMMPAGE))
  (clobber (match_scratch:HI   2                          "=&r,&r,&r,X,X"))
  (clobber (reg:CC_NZC CC_REG))
 ]
 "(TARGET_EDS)"
 "*
  { static char buffer[256]; 
    rtx mem_inner = XEXP(operands[1],0);
    int val;
    const char *op,*op2;
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  /* R<> */
               if (pic30_extended_ram_target() && (TARGET_BIG)) {
                 return \"mov %T1,%%2\;\"
                        \"btss %r1,#0\;\"
                        \"inc %%2,%%2\;\"
                        \"mov %%2,%u0\;\"
                        \"mov %%2,DSWPAG\;\"
                        \"rrnc %r1,%0\";
               } else if (pic30_eds_target()) {
                 return \"mov %T1,%u0\;\"
                        \"mov %T1,DSWPAG\;\"
                        \"rrnc %r1,%0\";
               } else {
                 return \"mov %T1,%u0\;\"
                        \"rrnc %r1,%0\";
               }
      case 1:  /* Q */
               val = INTVAL(XEXP(mem_inner,1));
               op = (val >= 0) ? \"add\" : \"sub\";
               op2 = (val >= 0) ? \"addc\" : \"subb\";
               if (val < 0) val = -val;
               if (pic30_extended_ram_target()) {
                 if (TARGET_BIG) {
                   if ((val * 2) < 31) {
                     sprintf(buffer,
                             \"%s %%r1,#%d,%%0\;\"
                             \"bset _SR,#1\;\"
                             \"%s %%T1,#0,%%2\;\"
                             \"btsc _SR,#1\;\"
                             \"inc %%2,%%2\;\"
                             \"mov %%2,%%u0\;\"
                             \"mov %%2,DSWPAG\;\"
                             \"rrnc %%0,%%0\;\", op, val*2, op2);
                   } else {
                     sprintf(buffer,
                             \"mov #%d,%%2\;\"
                             \"%s %%r1,%%2,%%0\;\"
                             \"bset _SR,#1\;\"
                             \"%s %%T1,#0,%%2\;\"
                             \"btsc _SR,#1\;\"
                             \"inc %%2,%%2\;\"
                             \"mov %%2,%%u0\;\"
                             \"mov %%2,DSWPAG\;\"
                             \"rrnc %%0,%%0\;\", val*2, op, op2);
                   }
                 } else {
                   if ((val * 2) < 31) {
                     sprintf(buffer,
                             \"%s %%r1,#%d,%%0\;\"
                             \"mov %%T1,%%u0\;\"
                             \"mov %%T1,DSWPAG\;\"
                             \"rrnc %%0,%%0\;\", op, val*2);
                   } else {
                     sprintf(buffer,
                             \"mov #%d,%%2\;\"
                             \"%s %%r1,%%2,%%0\;\"
                             \"mov %%T1,%%u0\;\"
                             \"mov %%T1,DSWPAG\;\"
                             \"rrnc %%0,%%0\;\", val*2, op);
                   }
                 }
               } else {
                 if ((val * 2) < 31) {
                   sprintf(buffer,
                           \"%s %%r1,#%d,%%0\;\"
                           \"rrnc %%0,%%0\;\", op, val*2);
                 } else {
                   sprintf(buffer,
                           \"mov #%d,%%2\;\"
                           \"%s %%r1,%%2,%%0\;\"
                           \"rrnc %%0,%%0\;\", val*2, op);
                 }
               }
               return buffer;
      case 2:  /* S */
               if (pic30_extended_ram_target()) {
                 if (TARGET_BIG) {
                   sprintf(buffer,
                           \"add %%r1,w%d,%%0\;\"
                           \"bclr %%0,#0\;\"
                           \"bset _SR,#1\;\"
                           \"addc %%T1,w%d,%%2\;\"
                           \"btss _SR,#1\;\"
                           \"bset %%0,#0\;\"
                           \"btsc _SR,#1\;\"
                           \"inc %%2,%%2\;\"
                           \"mov %%2,%%u0\;\"
                           \"mov %%2,DSWPAG\;\"
                           \"rrnc %%0,%%0\", REGNO(XEXP(mem_inner,1)),
                                             REGNO(XEXP(mem_inner,1))+1);
                 } else {
                   sprintf(buffer,
                           \"add %%r1,w%d,%%0\;\"
                           \"addc %%T1,w%d,%%2\;\"
                           \"mov %%2,%%u0\;\"
                           \"mov %%2,DSWPAG\;\"
                           \"rrnc %%0,%%0\", REGNO(XEXP(mem_inner,1)),
                                             REGNO(XEXP(mem_inner,1))+1);
                 }
               } else {
                 sprintf(buffer,
                         \"add %%r1,w%d,%%0\;\"
                         \"rrnc %%0,%%0\", REGNO(XEXP(mem_inner,1)));
               }
               return buffer;
      case 3:  /* U */
               return \"mov #unified_hi(%1),%0\;\"
                      \"mov %0,%u0\;\"
                      \"mov #edsoffset(%1),%0\";
      case 4:  /* T */
               if (pic30_eds_target()) {
                 return \"mov #unified_hi(%1),%0\;\"
                        \"mov %0,DSWPAG\;\"
                        \"mov %0,%u0\;\"
                        \"mov #edsoffset(%1),%0\";
               } else {
                 return \"mov #unified_hi(%1),%0\;\"
                        \"mov %0,%u0\;\"
                        \"mov #edsoffset(%1),%0\";
               }
    }
  }"
)

;; unified conversions
;;   these require shifting so that we can form a correct integer to 
;;   add

(define_insn "zero_extendqip32umm2_16"
  [(set (match_operand:P32UMM 0 "pic30_register_operand"      "=r,r")
        (uextend:P32UMM 
          (match_operand:QI 1 "pic30_reg_or_symbolic_address" " r,qs")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "@
   ze %1,%0\;mul.uu %0,#2,%0
   mov #unified_lo(%1), %0\;mov #unified_hi(%1), %d0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "zero_extendhip32umm2_16"
  [(set (match_operand:P32UMM 0 "pic30_register_operand"      "=r,r")
        (uextend:P32UMM 
          (match_operand:HI 1 "pic30_reg_or_symbolic_address" " r,qs")))
  ]
  ""
  "@
   mul.uu %1,#2,%0
   mov #unified_lo(%1), %0\;mov #unified_hi(%1), %d0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)   

(define_insn "zero_extendsip32umm2_16"
  [(set (match_operand:P32UMM 0 "pic30_register_operand"   "=r")
        (uextend:P32UMM
          (match_operand:SI 1 "pic30_register_operand"      "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "sl %1,%0\;rlc %d1,%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ] 
)

(define_insn "zero_extenddip32umm2_16"
  [(set (match_operand:P32UMM 0 "pic30_register_operand"   "=r")
        (uextend:P32UMM
          (match_operand:DI 1 "pic30_register_operand"      "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "sl %1,%0\;rlc %d1,%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "extendp32ummp32eds2_16"
  [(set (match_operand:P32EDS   0 "pic30_register_operand"       "=r,r,r")
        (uextend:P32EDS
          (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address" "0,r,qs")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  ""
  "@
   rrnc %0,%0
   rrnc %1,%0\;mov %d1,%d0
   mov #edsoffset(%1),%0\;mov #edspage(%1),%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "extendp32ummp32peds2_16"
  [(set (match_operand:P32PEDS  0 "pic30_register_operand"       "=r,r,r")
        (uextend:P32PEDS
          (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address" "0,r,qs")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  ""
  "@
   rrnc %0,%0
   rrnc %1,%0\;mov %d1,%d0
   mov #edsoffset(%1),%0\;mov #edspage(%1),%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "extendp32edsp32umm2_16"
  [(set (match_operand:P32UMM   0 "pic30_register_operand"       "=r,r,r")
        (uextend:P32UMM
          (match_operand:P32EDS 1 "pic30_reg_or_symbolic_address" "0,r,qs")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  ""
  "@
   rlnc %0,%0
   rlnc %1,%0\;mov %d1,%d0
   mov #unified_lo(%1),%0\;mov #unified_hi(%1),%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "extendp32pedsp32umm2_16"
  [(set (match_operand:P32UMM    0 "pic30_register_operand"       "=r,r,r")
        (uextend:P32UMM
          (match_operand:P32PEDS 1 "pic30_reg_or_symbolic_address" "0,r,qs")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  ""
  "@
   rlnc %0,%0
   rlnc %1,%0\;mov %d1,%d0
   mov #unified_lo(%1),%0\;mov #unified_hi(%1),%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "extendp32ummdi2_16"
  [(set (match_operand:DI       0 "pic30_register_operand"       "=r,r")
        (uextend:DI
          (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address" "r,qs")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  ""
  "@
   sl %d1,[w15]\;addc %1,#0,%0\;addc %d1,#0,%d0\;asr %d0,%d0\;rrc %0,%0\;asr %d0,#15,%t0\;asr %d0,#15,%q0
   mul.uu %q0,#0,%q0\;mov #addr_lo(%1),%0\;mov #addr_hi(%1),%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "extendp32ummsi2_16"
  [(set (match_operand:SI       0 "pic30_register_operand"       "=r,r")
        (uextend:SI
          (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address" "r,qs")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "@
   sl %d1,[w15]\;addc %1,#0,%0\;addc %d1,#0,%d0\;asr %d0,%d0\;rrc %0,%0
   mov #addr_lo(%1),%0\;mov #addr_hi(%1),%d0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "extendp32ummhi2_16"
  [(set (match_operand:HI       0 "pic30_register_operand"       "=r,r")
        (utrunc:HI
          (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address" "r,qs")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "@
   sl %d1,[w15]\;addc %1,#0,%0\;asr %0,%0
   mov #%1,%0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

; I am surprised this is requested
(define_insn "extendp32ummqi2_16"
  [(set (match_operand:QI       0 "pic30_register_operand"       "=r,r")
        (utrunc:QI
          (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address" "r,qs")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "@
   lsr.b %1,%0
   mov.b #%1,%0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "subsip32umm3_16"
  [(set(match_operand:SI         0 "pic30_register_operand" "=r")
       (minus:SI
         (utrunc:SI
           (match_operand:P32UMM 1 "pic30_register_operand" " r"))
         (utrunc:SI
           (match_operand:P32UMM 2 "pic30_register_operand" " r"))))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "sub %1,%2,%0\;subb %d1,%d2,%d0\;sl %d0,[W15]\;addc %0,#0,%0\;addc %d0,#0,%d0\;asr %d0,%d0\;rrc %0,%0"
)

(define_insn "subhip32umm3_16"
  [(set(match_operand:HI         0 "pic30_register_operand" "=r")
       (minus:HI
         (utrunc:HI
           (match_operand:P32UMM 1 "pic30_register_operand"  "r"))
         (utrunc:HI
           (match_operand:P32UMM 2 "pic30_register_operand"  "r"))))  
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "sub %1,%2,%0\;sl %0,[w15]\;addc %0,#0,%0\;asr %0,%0"
)

(define_insn "subp32umm3_16"
  [(set (match_operand: P32UMM   0 "pic30_register_operand" "=r")
        (minus: P32UMM
          (match_operand:P32UMM  1 "pic30_register_operand" " r")
          (match_operand:P32UMM  2 "pic30_register_operand" " r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "sub %1,%2,%0\;subb %d1,%d2,%d0"
)

;; unified operations for unrolling and such
(define_insn "one_cmplp32umm2_16"
  [(set (match_operand:P32UMM   0 "register_operand" "=r")
        (not:P32UMM 
          (match_operand:P32UMM 1 "register_operand" " r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  ""
  "com %1,%0\;com %d1,%d0"
  [
    (set_attr "cc" "clobber") ; CAW
  ]
)

(define_insn "andp32umm3_16"
  [(set (match_operand:P32UMM   0 "register_operand" "=r")
        (and:P32UMM 
          (match_operand:P32UMM 1 "register_operand" " r")
          (match_operand:P32UMM 2 "register_operand" " r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  ""
  "and %1,%2,%0\;and %d1,%d2,%d0"
)


;; unified subreg
;;   On occaision (ie accessing a packed structure) we need to get the raw 
;;   bits in a different mode do not convert these (hopefully we don't 
;;   generate them when we don't need to).   pic30_convert_pointer should 
;;   catch when we are doing real conversions
;;
;;   unions and bitfields make these things

(define_insn "read_subreg0P32UMM_hi_16"
  [(set (match_operand:HI       0 "pic30_register_operand" "=r,r")
        (subreg:HI 
          (match_operand:P32UMM 1 "pic30_register_operand" " 0,r") 0))
  ]
  ""
  "@
   ; nop
   mov.w %1,%0"
)

(define_insn "read_subreg1P32UMM_hi_16"
  [(set (match_operand:HI       0 "pic30_register_operand" "=r")
        (subreg:HI 
          (match_operand:P32UMM 1 "pic30_register_operand" " r") 2))
  ]
  ""
  "mov.w %d1,%0"
)

(define_insn "write_subreg0P32UMM_hi_16"
  [(set (subreg:HI 
          (match_operand:P32UMM 0 "pic30_register_operand" "=r,r") 0)
        (match_operand:HI       1 "pic30_register_operand" " 0,r"))]
  ""
  "@
   ; nop
   mov.w %1,%0"
)

(define_insn "write_subreg1P32UMM_hi_16"
  [(set (subreg:HI 
          (match_operand:P32UMM 0 "pic30_register_operand" "=r") 2)
        (match_operand:HI       1 "pic30_register_operand" " r"))]
  ""
  "mov.w %1,%d0"
)

(define_insn "read_subreg0P32UMM_si_16"
  [(set (match_operand:SI       0 "pic30_register_operand"        "=r,r,r,i")
        (subreg:SI
          (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address_or_immediate" " 0,r,qs,i") 0))
  ]
  ""
  "@
   ; nop
   mov.d %1,%0
   mov #unified_lo(%1),%0\;mov #unified_hi(%1),%d0
   mov #z1,%0\;mov #y1,%0"
)

(define_insn "write_subreg0P32UMM_si_16"
  [(set (subreg:SI
          (match_operand:P32UMM 0 "pic30_register_operand" "=r,r") 0)
        (match_operand:SI       1 "pic30_register_operand" " 0,r"))]
  ""
  "@
   ; nop
   mov.d %1,%0"
)

(define_insn "read_subreg0si_P32UMM_16"
  [(set (match_operand:P32UMM 0 "pic30_register_operand" "=r,r")
        (subreg:P32UMM
          (match_operand:SI   1 "pic30_register_operand" " 0,r") 0))
  ]
  ""
  "@
   ; nop
   mov.d %1,%0"
)

(define_insn "write_subreg0si_P32UMM_16"
  [(set (subreg:P32UMM
          (match_operand:SI   0 "pic30_register_operand"        "=r,r,r,r") 0)
        (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address_or_immediate" " 0,r,qs,i"))]
  ""
  "@
   ; nop
   mov.d %1,%0
   mov #unified_lo(%1),%0\;mov #unified_hi(%1),%d0
   mov #z1,%0\;mov #y1,%0"
)

(define_insn "read_subreg0P32UMM_di_16"
  [(set (match_operand:DI       0 "pic30_register_operand"        "=r,r,r,r")
        (subreg:DI
          (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address_or_immediate" " 0,r,qs,i") 0))
  ]
  ""
  "@
   ; nop
   mov.d %1,%0
   mov #unified_lo(%1),%0\;mov #unified_hi(%1),%d0
   mov #z1,%0\;mov #y1,%0"
)

(define_insn "write_subreg0P32UMM_di_16"
  [(set (subreg:DI
          (match_operand:P32UMM 0 "pic30_register_operand" "=r,r") 0)
        (match_operand:DI       1 "pic30_register_operand" " 0,r"))]
  ""
  "@
   ; nop
   mov.d %1,%0"
)

(define_insn "read_subreg0di_P32UMM_16"
  [(set (match_operand:P32UMM 0 "pic30_register_operand" "=r,r")
        (subreg:P32UMM
          (match_operand:DI   1 "pic30_register_operand" " 0,r") 0))
  ]
  ""
  "@
   ; nop
   mov.d %1,%0"
)

(define_insn "write_subreg0di_P32UMM_16"
  [(set (subreg:P32UMM
          (match_operand:DI   0 "pic30_register_operand"        "=r,r,r,r") 0)
        (match_operand:P32UMM 1 "pic30_reg_or_symbolic_address_or_immediate" " 0,r,qs,i"))]
  ""
  "@
   ; nop
   mov.d %1,%0
   mov #unified_lo(%1),%0\;mov #unified_hi(%1),%d0
   mov #z1,%0\;mov #y1,%0"
)



;;; for these patterns I am using a 'unspec' to prevent merging
;;;   copyprop and the like sometimes tries to change these
;;;   perhaps a secondary reload would be better, or LO/HI mode for each
;;;   part of the address 

(define_insn "P32UMMrdr_qi_16"
   [(set (match_operand:QI      0 "pic30_mode2_operand"    "=r,  R<>,&r, r,r")
         (unspec:QI [
           (match_operand:QI    1 "pic30_mem_umm_operand"  " R<>,R<>,QS,U,T")
           (clobber 
             (match_scratch:HI  2                          "=X,  r,  X, X,X"))
          ] UNSPEC_UNIFIED_RD))
    (clobber (reg:HI PSVPAG))
    (clobber (reg:CC CC_REG))
   ]
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "*
    { rtx lhs = NULL_RTX;
      rtx rhs = NULL_RTX;
      rtx addr = XEXP(operands[1],0);
      static char buffer[255];
      switch (which_alternative) {
        case 1: 
          lhs = operands[2];
          /* FALLSTHROUGH */
        case 0:
          if (lhs == NULL_RTX) lhs = operands[0];
          switch (GET_CODE(XEXP(operands[1],0))) {
            default:  gcc_assert(0);
            case  REG:
              sprintf(buffer,\"mov %%T1,%%u0\;\"
                             \"rrnc %%r1,w%d\;\"
                             \"mov.b [w%d],%%0\", REGNO(lhs), REGNO(lhs));
              return buffer;
            case PRE_INC:
              sprintf(buffer,\"mov %%T1,%%u0\;\"
                             \"add #2,%%r1\;\"
                             \"rrnc %%r1,w%d\;\"
                             \"mov.b [w%d],%%0\;\", REGNO(lhs), REGNO(lhs));
              return buffer;
            case PRE_DEC:
              sprintf(buffer,\"mov %%T1,%%u0\;\"
                             \"sub #2,%%r1\;\"
                             \"rrnc %%r1,w%d\;\"
                             \"mov.b [w%d],%%0\;\", REGNO(lhs), REGNO(lhs));
              return buffer;
            case POST_INC:
              sprintf(buffer,\"mov %%T1,%%u0\;\"
                             \"rrnc %%r1,w%d\;\"
                             \"mov.b [w%d],%%0\;\"
                             \"add #2,%%r1\", REGNO(lhs), REGNO(lhs));
              return buffer;
            case POST_DEC:
              sprintf(buffer,\"mov %%T1,%%u0\;\"
                             \"rrnc %%r1,w%d\;\"
                             \"mov.b [w%d],%%0\;\"
                             \"sub #2,%%r1\", REGNO(lhs), REGNO(lhs));
              return buffer;
          }
        case 2:
          /* QS */
          lhs = XEXP(addr,0);
          rhs = XEXP(addr,1);
          switch (GET_CODE(addr)) {
            default:  gcc_assert(0);
            case PLUS: 
              if (GET_CODE(rhs) == REG) {
                /* a reg has already been extended */
                sprintf(buffer,\"mov %%T1,%%u0\;\"
                               \"add w%d,w%d,%%0\;\"
                               \"rrnc %%0,%%0\;\"
                               \"mov.b [%%0],%%0\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"sub %%0,#%d,%%0\;\"
                                 \"mov.b [%%0],%%0\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"add %%0,#%d,%%0\;\"
                                 \"mov.b [%%0],%%0\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"sub #%d,%%0\;\"
                                 \"mov.b [%%0],%%0\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"add #%d,%%0\;\"
                                 \"mov.b [%%0],%%0\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            case MINUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(buffer,\"mov %%T1,%%u0\;\"
                               \"sub w%d,w%d,%%0\;\"
                               \"rrnc %%0,%%0\;\"
                               \"mov.b [%%0],%%0\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"add %%0,#%d,%%0\;\"
                                 \"mov.b [%%0],%%0\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"sub %%0,#%d,%%0\;\"
                                 \"mov.b [%%0],%%0\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"add #%d,%%0\;\"
                                 \"mov.b [%%0],%%0\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"sub #%d,%%0\;\"
                                 \"mov.b [%%0],%%0\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
          }
        case 3:
          return \"mov %1,%0\";
        case 4:
          return \"mov #edspage(%1),%0\;\"
                 \"mov %0,%u0\;\"
                 \"mov #edsoffset(%1),%0\;\"
                 \"mov.b [%0],%0\";
      }
    }"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)
    
;;; can be used for repeated pushes in special case, make it an unspec to
;;; protect it...

(define_insn "P32UMMpushnext_hi_16"
   [(set (match_operand:HI        0 "pic30_mode2_operand"    "=rR<>, r")
         (unspec:HI [
            (match_operand:P32UMM 1 "pic30_mem_umm_operand"  " R<>,  Q")
         ] UNSPEC_UNIFIED_PUSH))
   ]
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "@
    mov.w %1,%0
    mov.w %1,%0"
   [ 
     (set_attr "type" "defuse")
   ]
)

(define_insn "P32UMMsetuppushaddr_16"
  [(unspec:P32UMM [
      (match_operand:P32UMM 0 "pic30_mem_umm_operand" "<>")
   ] UNSPEC_UNIFIED_PUSH)
   (clobber (reg:HI PSVPAG))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
  "mov %T0,%u0\;rrnc %r0,%r0"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)

(define_insn "P32UMMrdr_<mode>_16"
   [(set (match_operand:SM16BIT   0 "pic30_mode2_operand"    "=r,  R<>,&r, r,r")
         (unspec:SM16BIT [
           (match_operand:SM16BIT 1 "pic30_mem_umm_operand"  " R<>,R<>,QS,U,T")
           (clobber 
             (match_scratch:HI    2                          "=X,  r,  X, X,X"))
          ] UNSPEC_UNIFIED_RD))
    (clobber (reg:HI PSVPAG))
    (clobber (reg:CC_NZC CC_REG))
   ]  
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "*
    { rtx lhs = NULL_RTX;
      rtx rhs = NULL_RTX;
      rtx addr = XEXP(operands[1],0);
      static char buffer[255];
      switch (which_alternative) {
        case 1: 
          lhs = operands[2];
          /* FALLSTHROUGH */
        case 0:
          if (lhs == NULL_RTX) lhs = operands[0];
          switch (GET_CODE(XEXP(operands[1],0))) {
            default:  gcc_assert(0);
            case  REG:
              sprintf(buffer,\"mov %%T1,%%u0\;\"
                             \"rrnc %%r1,w%d\;\"
                             \"mov.w [w%d],%%0\", REGNO(lhs), REGNO(lhs));
              return buffer;
            case PRE_INC:
              sprintf(buffer,\"mov %%T1,%%u0\;\"
                             \"add #4,%%r1\;\"
                             \"rrnc %%r1,w%d\;\"
                             \"mov.w [w%d],%%0\;\", REGNO(lhs), REGNO(lhs));
              return buffer;
            case PRE_DEC:
              sprintf(buffer,\"mov %%T1,%%u0\;\"
                             \"sub #4,%%r1\;\"
                             \"rrnc %%r1,w%d\;\"
                             \"mov.w [w%d],%%0\;\", REGNO(lhs), REGNO(lhs));
              return buffer;
            case POST_INC:
              sprintf(buffer,\"mov %%T1,%%u0\;\"
                             \"rrnc %%r1,w%d\;\"
                             \"mov.w [w%d],%%0\;\"
                             \"add #4,%%r1\", REGNO(lhs), REGNO(lhs));
              return buffer;
            case POST_DEC:
              sprintf(buffer,\"mov %%T1,%%u0\;\"
                             \"rrnc %%r1,w%d\;\"
                             \"mov.w [w%d],%%0\;\"
                             \"sub #4,%%r1\", REGNO(lhs), REGNO(lhs));
              return buffer;
          }
        case 2:
          /* QS */
          lhs = XEXP(addr,0);
          rhs = XEXP(addr,1);
          switch (GET_CODE(addr)) {
            default:  gcc_assert(0);
            case PLUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(buffer,\"mov %%T1,%%u0\;\"
                               \"add w%d,w%d,%%0\;\"
                               \"rrnc %%0,%%0\;\"
                               \"mov.w [%%0],%%0\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"sub %%0,#%d,%%0\;\"
                                 \"mov.w [%%0],%%0\", REGNO(lhs), -val);
                  return buffer;
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"add %%0,#%d,%%0\;\"
                                 \"mov.w [%%0],%%0\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"sub #%d,%%0\;\"
                                 \"mov.w [%%0],%%0\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"add #%d,%%0\;\"
                                 \"mov.w [%%0],%%0\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            case MINUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(buffer,\"mov %%T1,%%u0\;\"
                               \"sub w%d,w%d,%%0\;\"
                               \"rrnc %%0,%%0\;\"
                               \"mov.w [%%0],%%0\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"add %%0,#%d,%%0\;\"
                                 \"mov.w [%%0],%%0\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"sub %%0,#%d,%%0\;\"
                                 \"mov.w [%%0],%%0\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"add #%d,%%0\;\"
                                 \"mov.w [%%0],%%0\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"sub #%d,%%0\;\"
                                 \"mov.w [%%0],%%0\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
          }
        case 3:
          return \"mov %1,%0\";
        case 4:
          return \"mov #edspage(%1),%0\;\"
                 \"mov %0,%u0\;\"
                 \"mov #edsoffset(%1),%0\;\"
                 \"mov.w [%0],%0\";
      }
    }"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)

(define_insn "P32UMMrdr_<mode>_16"
   [(set (match_operand:SM32BIT   0 "pic30_mode2_operand"    "=r,  R,  <>, &r, r,r")
         (unspec:SM32BIT [
           (match_operand:SM32BIT 1 "pic30_mem_umm_operand"  " R<>,R<>,R<>,QS,U,T")
           (clobber 
             (match_scratch:HI    2                          "=X,  r,  r,  X, X,X"))
          ] UNSPEC_UNIFIED_RD))
    (clobber (reg:HI PSVPAG))
    (clobber (reg:CC_NZC CC_REG))
   ]  
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "*
    { rtx lhs = NULL_RTX;
      rtx rhs = NULL_RTX;
      rtx addr = XEXP(operands[1],0);
      static char buffer[255];
      switch (which_alternative) {
        default: gcc_assert(0);
        case 0:
          switch (GET_CODE(XEXP(operands[1],0))) {
            default:  gcc_assert(0);
            case  REG:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%0\;\"
                      \"mov.d [%0],%0\";
            case PRE_INC:
              return  \"mov %T1,%u0\;\"
                      \"add #8,%r1\;\"
                      \"rrnc %r1,%d0\;\"
                      \"mov [%d0++],%0\;\"
                      \"mov [%d0],%d0\";
            case PRE_DEC: 
              return  \"mov %T1,%u0\;\"
                      \"sub #8,%r1\;\"
                      \"rrnc %r1,%d0\;\"
                      \"mov [%d0++],%0\;\"
                      \"mov [%d0],%d0\";
            case POST_INC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%d0\;\"
                      \"mov [%d0++],%0\;\"
                      \"mov [%d0],%d0\;\"
                      \"add #8,%r1\";
            case POST_DEC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%d0\;\"
                      \"mov [%d0++],%0\;\"
                      \"mov [%d0],%d0\;\"
                      \"sub #8,%r1\";
          }
        case 1: 
          switch (GET_CODE(XEXP(operands[1],0))) {
            default:  gcc_assert(0);
            case  REG:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%D0\";
            case PRE_INC:
              return  \"mov %T1,%u0\;\"
                      \"add #8,%r1\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%D0\";
            case PRE_DEC: 
              return  \"mov %T1,%u0\;\"
                      \"sub #8,%r1\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%D0\";
            case POST_INC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%D0\;\"
                      \"add #8,%r1\";
            case POST_DEC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%Q0\;\"
                      \"sub #8,%r1\";
          }
          break;
        case 2:
          switch (GET_CODE(XEXP(operands[1],0))) {
            default:  gcc_assert(0);
            case  REG:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\";
            case PRE_INC:
              return  \"mov %T1,%u0\;\"
                      \"add #8,%r1\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\";
            case PRE_DEC: 
              return  \"mov %T1,%u0\;\"
                      \"sub #8,%r1\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\";
            case POST_INC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\;\"
                      \"add #8,%r1\";
            case POST_DEC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\;\"
                      \"sub #8,%r1\";
          }
          break;
        case 3: 
          /* QS */
          lhs = XEXP(addr,0);
          rhs = XEXP(addr,1);
          switch (GET_CODE(addr)) {
            default:  gcc_assert(0);
            case PLUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(buffer,\"mov %%T1,%%u0\;\"
                               \"add w%d,w%d,%%0\;\"
                               \"rrnc %%0,%%0\;\"
                               \"mov.d [%%0],%%0\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"sub %%0,#%d,%%0\;\"
                                 \"mov.d [%%0],%%0\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"add %%0,#%d,%%0\;\"
                                 \"mov.d [%%0],%%0\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"sub #%d,%%0\;\"
                                 \"mov.d [%%0],%%0\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"add #%d,%%0\;\"
                                 \"mov.d [%%0],%%0\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            case MINUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(buffer,\"mov %%T1,%%u0\;\"
                               \"sub w%d,w%d,%%0\;\"
                               \"rrnc %%0,%%0\;\"
                               \"mov.d [%%0],%%0\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"add %%0,#%d,%%0\;\"
                                 \"mov.d [%%0],%%0\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"sub %%0,#%d,%%0\;\"
                                 \"mov.d [%%0],%%0\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"add #%d,%%0\;\"
                                 \"mov.d [%%0],%%0\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%0\;\"
                                 \"sub #%d,%%0\;\"
                                 \"mov.d [%%0],%%0\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            }
        case 4: return \"mov %1,%0\;\"
                       \"mov %1+2,%d0\";
        case 5: return \"mov #edspage(%1),%0\;\"
                       \"mov %0,%u0\;\"
                       \"mov #edsoffset(%1),%0\;\"
                       \"mov.d [%0],%0\";
     }
   }"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)

(define_expand "P32UMMrd_<mode>_16"
   [(set (match_operand:ALLRDMODES 0 "pic30_mode3_operand"   "")
         (match_operand:ALLRDMODES 1 "pic30_mem_umm_operand" ""))
   ]
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "
    if (can_create_pseudo_p()) {
      rtx read_address = gen_reg_rtx(machine_Pmode);
      
      emit(
        gen_p32umm_readmem_16(read_address, operands[1])
      );
      emit_move_insn(operands[0], 
                     gen_rtx_MEM(GET_MODE(operands[0]),read_address));
      DONE;
    } else {
      gcc_assert(0);
      rtx op1 = pic30_form_UMM_address(operands[1]);
      if (pic30_reg_or_symbolic_address(op1,<MODE>mode)) {
        emit(
          gen_P32UMMrdr_<mode>_16(operands[0],op1)
        );
        DONE;
      } else if (!pic30_reload_in_progress()) {
        rtx r = gen_reg_rtx(<MODE>mode);
        emit(
          gen_P32UMMrdr_<mode>_16(r,op1)
        );
        emit_move_insn(operands[0],r);
        DONE;
      }
   }
   FAIL;
   "
)

(define_insn "P32UMMrdr_<mode>_16"
   [(set (match_operand:SM48BIT   0 "pic30_mode2_operand"    "=r, R,  <>, r, r,r")
         (unspec:SM48BIT [
           (match_operand:SM48BIT 1 "pic30_mem_umm_operand"  "R<>,R<>,R<>,QS,U,T")
           (clobber 
             (match_scratch:HI    2                          "=X, r,  r,  X, X,X"))
          ] UNSPEC_UNIFIED_RD))
    (clobber (reg:HI PSVPAG))
    (clobber (reg:CC_NZC CC_REG))
   ]  
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "*
    { rtx lhs = NULL_RTX;
      rtx rhs = NULL_RTX;
      rtx addr = XEXP(operands[1],0);
      static char buffer[255];
      switch (which_alternative) {
        case 0:
          switch (GET_CODE(XEXP(operands[1],0))) {
            default:  gcc_assert(0);
            case  REG:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%t0\;\"
                      \"mov.d [%t0++],%0\;\"
                      \"mov.w [%t0],%t0\";
            case PRE_INC:
              return  \"mov %T1,%u0\;\"
                      \"add #12,%r1\;\"
                      \"rrnc %r1,%t0\;\"
                      \"mov [%t0++],%0\;\"
                      \"mov [%t0++],%d0\;\"
                      \"mov [%t0],%t0\";
            case PRE_DEC: 
              return  \"mov %T1,%u0\;\"
                      \"sub #12,%r1\;\"
                      \"rrnc %r1,%t0\;\"
                      \"mov [%t0++],%0\;\"
                      \"mov [%t0++],%d0\;\"
                      \"mov [%t0],%t0\";
            case POST_INC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%t0\;\"
                      \"mov [%t0++],%0\;\"
                      \"mov [%t0++],%d0\;\"
                      \"mov [%t0],%t0\;\"
                      \"add #12,%r1\";
            case POST_DEC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%t0\;\"
                      \"mov [%t0++],%0\;\"
                      \"mov [%t0++],%d0\;\"
                      \"mov [%t0],%t0\;\"
                      \"sub #12,%r1\";
          }
        case 1: 
          switch (GET_CODE(XEXP(operands[1],0))) {
            default:  gcc_assert(0);
            case  REG:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%0\;\"
                      \"sub #4,%r0\";
            case PRE_INC:
              return  \"mov %T1,%u0\;\"
                      \"add #12,%r1\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%0\;\"
                      \"sub #4,%r0\";
            case PRE_DEC: 
              return  \"mov %T1,%u0\;\"
                      \"sub #12,%r1\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%0\;\"
                      \"sub #4,%r0\";
            case POST_INC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%0\;\"
                      \"add #12,%r1\;\"
                      \"sub #4,%r0\";
            case POST_DEC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%0\;\"
                      \"sub #4,%r0\;\"
                      \"sub #12,%r1\";
          }
          break;
        case 2:
          switch (GET_CODE(XEXP(operands[1],0))) {
            default:  gcc_assert(0);
            case  REG:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\";
            case PRE_INC:
              return  \"mov %T1,%u0\;\"
                      \"add #12,%r1\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\";
            case PRE_DEC: 
              return  \"mov %T1,%u0\;\"
                      \"sub #12,%r1\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\";
            case POST_INC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\;\"
                      \"add #12,%r1\";
            case POST_DEC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\;\"
                      \"sub #12,%r1\";
          }
          break;
        case 3: 
          /* QS */
          lhs = XEXP(addr,0);
          rhs = XEXP(addr,1);
          switch (GET_CODE(addr)) {
            default:  gcc_assert(0);
            case PLUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(buffer,\"mov %%T1,%%u0\;\"
                               \"add w%d,w%d,%%t0\;\"
                               \"rrnc %%t0,%%t0\;\"
                               \"mov.d [%%t0++],%%0\;\"
                               \"mov.w [%%t0],%%t0\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"sub %%t0,#%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.w [%%t0],%%t0\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"add %%t0,#%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.w [%%t0], %%t0\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"sub #%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.w [%%t0],%%t0\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"add #%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.w [%%t0],%%t0\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            case MINUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(buffer,\"mov %%T1,%%u0\;\"
                               \"sub w%d,w%d,%%0\;\"
                               \"rrnc %%0,%%0\;\"
                               \"mov.d [%%t0++],%%0\;\"
                               \"mov.w [%%t0],%%t0\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"add %%t0,#%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.w [%%t0],%%t0\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"sub %%t0,#%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.w [%%t0],%%t0\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"add #%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.w [%%t0],%%t0\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"sub #%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.w [%%t0],%%t0\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            }
        case 4: return \"mov %1,%0\;\"
                       \"mov %1+2,%d0\;\"
                       \"mov %1+4,%t0\";
        case 5: return \"mov #edspage(%1),%0\;\"
                       \"mov %0,%u0\;\"
                       \"mov #edsoffset(%1),%t0\;\"
                       \"mov.d [%t0++],%0\;\"
                       \"mov [%t0],%t0\";
      }
    }"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)


(define_insn "P32UMMrdr_<mode>_16"
   [(set (match_operand:SM64BIT   0 "pic30_mode2_operand"    "=r,  R,  <>, r, r,r")
         (unspec:SM64BIT [
           (match_operand:SM64BIT 1 "pic30_mem_umm_operand"  " R<>,R<>,R<>,QS,U,T")
           (clobber 
             (match_scratch:HI    2                          "=X,  r,  r,  X, X,X"))
          ] UNSPEC_UNIFIED_RD))
    (clobber (reg:HI PSVPAG))
    (clobber (reg:CC_NZC CC_REG))
   ]  
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "*
    { rtx lhs = NULL_RTX;
      rtx rhs = NULL_RTX;
      rtx addr = XEXP(operands[1],0);
      static char buffer[255];
      switch (which_alternative) {
        case 0:
          switch (GET_CODE(XEXP(operands[1],0))) {
            default:  gcc_assert(0);
            case  REG:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%t0\;\"
                      \"mov.d [%t0++],%0\;\"
                      \"mov.d [%t0],%t0\";
            case PRE_INC:
              return  \"mov %T1,%u0\;\"
                      \"add #16,%r1\;\"
                      \"rrnc %r1,%q0\;\"
                      \"mov [%q0++],%0\;\"
                      \"mov [%q0++],%d0\;\"
                      \"mov [%q0++],%t0\;\"
                      \"mov [%q0],%q0\";
            case PRE_DEC: 
              return  \"mov %T1,%u0\;\"
                      \"sub #16,%r1\;\"
                      \"rrnc %r1,%q0\;\"
                      \"mov [%q0++],%0\;\"
                      \"mov [%q0++],%d0\;\"
                      \"mov [%q0++],%t0\;\"
                      \"mov [%q0],%q0\";
            case POST_INC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%q0\;\"
                      \"mov [%q0++],%0\;\"
                      \"mov [%q0++],%d0\;\"
                      \"mov [%q0++],%t0\;\"
                      \"mov [%q0],%q0\;\"
                      \"add #16,%r1\";
            case POST_DEC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%q0\;\"
                      \"mov [%q0++],%0\;\"
                      \"mov [%q0++],%d0\;\"
                      \"mov [%q0++],%t0\;\"
                      \"mov [%q0],%q0\;\"
                      \"sub #16,%r1\";
          }
        case 1: 
          switch (GET_CODE(XEXP(operands[1],0))) {
            default:  gcc_assert(0);
            case  REG:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%0\;\"
                      \"sub #6,%r0\";
            case PRE_INC:
              return  \"mov %T1,%u0\;\"
                      \"add #16,%r1\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%0\;\"
                      \"sub #6,%r0\";
            case PRE_DEC: 
              return  \"mov %T1,%u0\;\"
                      \"sub #16,%r1\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%0\;\"
                      \"sub #6,%r0\";
            case POST_INC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%0\;\"
                      \"add #16,%r1\;\"
                      \"sub #6,%r0\";
            case POST_DEC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2++],%I0\;\"
                      \"mov [%2],%0\;\"
                      \"sub #16,%r1\;\"
                      \"sub #6,%r0\";
          }
          break;
        case 2:
          switch (GET_CODE(XEXP(operands[1],0))) {
            default:  gcc_assert(0);
            case  REG:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\";
            case PRE_INC:
              return  \"mov %T1,%u0\;\"
                      \"add #16,%r1\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\";
            case PRE_DEC: 
              return  \"mov %T1,%u0\;\"
                      \"sub #16,%r1\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\";
            case POST_INC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\;\"
                      \"add #16,%r1\";
            case POST_DEC:
              return  \"mov %T1,%u0\;\"
                      \"rrnc %r1,%2\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2++],%0\;\"
                      \"mov [%2],%0\;\"
                      \"sub #16,%r1\";
          }
          break;
        case 3:
          /* QS */
          lhs = XEXP(addr,0);
          rhs = XEXP(addr,1);
          switch (GET_CODE(addr)) {
            default:  gcc_assert(0);
            case PLUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(buffer,\"mov %%T1,%%u0\;\"
                               \"add w%d,w%d,%%t0\;\"
                               \"rrnc %%t0,%%t0\;\"
                               \"mov.d [%%t0++],%%0\;\"
                               \"mov.d [%%t0],%%t0\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"sub %%t0,#%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.d [%%t0],%%t0\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"add %%t0,#%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.d [%%t0], %%t0\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"sub #%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.d [%%t0],%%t0\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"add #%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.d [%%t0],%%t0\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            case MINUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(buffer,\"mov %%T1,%%u0\;\"
                               \"sub w%d,w%d,%%0\;\"
                               \"rrnc %%0,%%0\;\"
                               \"mov.d [%%t0++],%%0\;\"
                               \"mov.d [%%t0],%%t0\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"add %%t0,#%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.d [%%t0],%%t0\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"sub %%t0,#%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.d [%%t0],%%t0\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"add #%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.d [%%t0],%%t0\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(buffer,\"mov %%T1,%%u0\;\"
                                 \"rrnc w%d,%%t0\;\"
                                 \"sub #%d,%%t0\;\"
                                 \"mov.d [%%t0++],%%0\;\"
                                 \"mov.d [%%t0],%%t0\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            }
        case 4: return \"mov %1,%0\;\"
                       \"mov %1+2,%d0\;\"
                       \"mov %1+4,%t0\;\"
                       \"mov %1+6,%q0\";
        case 5: return \"mov #edspage(%1),%0\;\"
                       \"mov %0,%u0\;\"
                       \"mov #edsoffset(%1),%t0\;\"
                       \"mov.d [%t0++],%0\;\"
                       \"mov.d [%t0],%t0\";
      }
    }"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)


(define_expand "P32UMMwt_<mode>_16"
   [(set (match_operand:ALLRDMODES 0 "pic30_mem_umm_operand"   "")
         (match_operand:ALLRDMODES 1 "pic30_move_operand" ""))
   ]
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "
    if (can_create_pseudo_p()) {
      rtx write_address = gen_reg_rtx(machine_Pmode);

      emit(
        gen_p32umm_writemem_16(write_address, operands[0])
      );
      emit_move_insn(gen_rtx_MEM(GET_MODE(operands[0]),write_address),
                     operands[1]);
      DONE;
    } else {
      gcc_assert(0);
      rtx op0 = pic30_form_UMM_address(operands[0]);
      if (pic30_register_operand(operands[1],<MODE>mode)) {
        emit(
          gen_P32UMMwtr_<mode>_16(op0,operands[1])
        );
        DONE;
      } else if (!pic30_reload_in_progress()) {
        rtx r = gen_reg_rtx(<MODE>mode);
        emit_move_insn(r,operands[1]);
        emit(
          gen_P32UMMwtr_<mode>_16(op0,r)
        );   
        DONE;
      }
    }
    FAIL;
   "
)

(define_insn "P32UMMwtr_qi_16"
   [(set (match_operand:QI      0 "pic30_mem_wtumm_operand" "=R,QS,U,T")
         (unspec:QI [
           (match_operand:QI    1 "pic30_register_operand"  " r,r, a,r")
           (clobber 
              (match_scratch:HI 2                         "=&r,&r,&r,&r"))
         ] UNSPEC_UNIFIED_WT))
    (clobber (reg:HI DSWPAG))
    (clobber (reg:CC CC_REG))
   ]
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "*
    { rtx lhs;
      rtx rhs;
      rtx addr = XEXP(operands[0],0);
      static char buffer[255];
      char *b = buffer;
      switch(which_alternative) {
        default: gcc_assert(0);
        case 0: if (pic30_eds_target()) {
                  return \"mov %T0,DSWPAG\;\"
                         \"rrnc %r0,%2\;\"
                         \"mov.b %1,[%2]\";
                } else {
                  return 
                         \"rrnc %r0,%2\;\"
                         \"mov.b %1,[%2]\";
                }
        case 1:
          /* QS */
          lhs = XEXP(addr,0);
          rhs = XEXP(addr,1);
          if (pic30_eds_target()) {
            b += sprintf(b,\"mov %%T0,DSWPAG\;\");
          }
          switch (GET_CODE(addr)) {
            default:  gcc_assert(0);
            case PLUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(b,
                               \"add w%d,w%d,%%2\;\"
                               \"rrnc %%2,%%2\;\"
                               \"mov.b %%1,[%%2]\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub %%2,#%d,%%2\;\"
                                 \"mov.b %%1,[%%2]\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add %%2,#%d,%%2\;\"
                                 \"mov.b %%1,[%%2]\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub #%d,%%2\;\"
                                 \"mov.b %%1,[%%2]\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add #%d,%%2\;\"
                                 \"mov.b %%1,[%%2]\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            case MINUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(b,
                               \"sub w%d,w%d,%%2\;\"
                               \"rrnc %%2,%%2\;\"
                               \"mov.b %%1,[%%2]\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add %%2,#%d,%%2\;\"
                                 \"mov.b %%1,[%%2]\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub %%2,#%d,%%2\;\"
                                 \"mov.b %%1,[%%2]\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add #%d,%%2\;\"
                                 \"mov.b %%1,[%%2]\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub #%d,%%2\;\"
                                 \"mov.b %%1,[%%2]\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            }
        case 3:
          /* T */
          if (pic30_eds_target()) {
            return \"mov #edspage(%0),%2\;\"
                   \"mov %2,DSWPAG\;\"
                   \"mov #edsoffset(%0),%2\;\"
                   \"mov.b %1,[%2]\";
          } else {
            return \"mov #edsoffset(%0),%2\;\"
                   \"mov.b %1,[%2]\";
          }
        case 2:
          /* U */                
          return \"mov.b WREG,%0\";  
      }
    }"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)


(define_insn "P32UMMpopnext_eds_hi_16"
   [(set (match_operand:P32UMM 0 "pic30_mem_umm_operand"  "=R<>Q")
         (unspec:P32UMM [
           (match_operand:HI   1 "pic30_mode2_operand"    " <>R")
         ] UNSPEC_UNIFIED_POP))
   ]
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode) && pic30_eds_target()"
   "mov.w %1,%0"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)

(define_insn "P32UMMpopnext_noeds_hi_16"
   [(set (match_operand:P32UMM 0 "pic30_mem_umm_operand"  "=R<>Q")
         (unspec:P32UMM [
           (match_operand:HI 1 "pic30_mode2_operand"  " R<>")
         ] UNSPEC_UNIFIED_POP))
   ]
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode) && (pic30_eds_target() == 0)"
   "mov.w %1,%0"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)

(define_expand "P32UMMpopnext_hi_16"
   [(set (match_operand:HI 0 "pic30_mem_umm_operand" "")
         (match_operand:HI 1 "pic30_mode2_operand"   ""))]
 ""
 "{
    rtx (*fn)(rtx,rtx);
    if (pic30_eds_target()) {
      fn = gen_P32UMMpopnext_eds_hi_16;
    } else {
      fn = gen_P32UMMpopnext_noeds_hi_16;
    }
    emit(
       fn(operands[0],operands[1])
    );
    DONE;
  }"
)

(define_insn "P32UMMwtr_<mode>_16"
   [(set (match_operand:SM16BIT   0 "pic30_mem_wtumm_operand" "=R,QS,U,T")
         (unspec:SM16BIT [
           (match_operand:SM16BIT 1 "pic30_register_operand" " r,r, r,r")
           (clobber
             (match_scratch:HI    2                         "=&r,&r,&r,&r"))
          ] UNSPEC_UNIFIED_WT))
    (clobber (reg:HI DSWPAG))
    (clobber (reg:CC_NZC CC_REG))
   ]
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "*
    { rtx lhs;
      rtx rhs;
      rtx addr = XEXP(operands[0],0);
      static char buffer[255];
      char *b = buffer;
      switch(which_alternative) {
        default: gcc_assert(0);
        case 0: if (pic30_eds_target()) {
                  return \"mov %T0,DSWPAG\;\"
                         \"rrnc %r0,%2\;\"
                         \"mov.w %1,[%2]\";
                } else {
                  return 
                         \"rrnc %r0,%2\;\"
                         \"mov.w %1,[%2]\";
                }
        case 1:
          /* QS */
          lhs = XEXP(addr,0);
          rhs = XEXP(addr,1);
          if (pic30_eds_target()) {
            b += sprintf(buffer,\"mov %%T0,DSWPAG\;\");
          }
          switch (GET_CODE(addr)) {
            default:  gcc_assert(0);
            case PLUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(b,
                               \"add w%d,w%d,%%2\;\"
                               \"rrnc %%2,%%2\;\"
                               \"mov.w %%1,[%%2]\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub %%2,#%d,%%2\;\"
                                 \"mov.w %%1,[%%2]\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add %%2,#%d,%%2\;\"
                                 \"mov.w %%1,[%%2]\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub #%d,%%2\;\"
                                 \"mov.w %%1,[%%2]\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add #%d,%%2\;\"
                                 \"mov.w %%1,[%%2]\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            case MINUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(b,
                               \"sub w%d,w%d,%%2\;\"
                               \"rrnc %%2,%%2\;\"
                               \"mov.w %%1,[%%2]\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add %%2,#%d,%%2\;\"
                                 \"mov.w %%1,[%%2]\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub %%2,#%d,%%2\;\"
                                 \"mov.w %%1,[%%2]\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add #%d,%%2\;\"
                                 \"mov.w %%1,[%%2]\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub #%d,%%2\;\"
                                 \"mov.w %%1,[%%2]\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            }
        case 3:
          /* T */
          if (pic30_eds_target()) {
            return \"mov #edspage(%0),%2\;\"
                   \"mov %2,DSWPAG\;\"
                   \"mov %1,%0\";
          } else {
            return \"mov %1,%0\";
          }
        case 2:
          /* U */
          return \"mov %1,%0\";
      }
    }"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)

(define_insn "P32UMMwtr_<mode>_16"
   [(set (match_operand:SM32BIT   0 "pic30_mem_wtumm_operand" "=R,QS,U,T")
         (unspec:SM32BIT [
           (match_operand:SM32BIT 1 "pic30_register_operand" " r,r, r,r")
           (clobber 
             (match_scratch:HI    2                         "=&r,&r,&r,&r"))
          ] UNSPEC_UNIFIED_WT))
    (clobber (reg:HI DSWPAG))
    (clobber (reg:CC_NZC CC_REG))
   ]
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "*
    { rtx lhs;
      rtx rhs;
      rtx addr = XEXP(operands[0],0);
      static char buffer[255];
      char *b = buffer;
      switch(which_alternative) {
        default: gcc_assert(0);
        case 0: if (pic30_eds_target()) {
                  return \"mov %T0,DSWPAG\;\"
                         \"rrnc %r0,%2\;\"
                         \"mov.d %1,[%2]\";
                } else {
                  return 
                         \"rrnc %r0,%2\;\"
                         \"mov.d %1,[%2]\";
                }
        case 1:
          /* QS */
          lhs = XEXP(addr,0);
          rhs = XEXP(addr,1);
          if (pic30_eds_target()) {
            b += sprintf(buffer,\"mov %%T0,DSWPAG\;\");
          }
          switch (GET_CODE(addr)) {
            default:  gcc_assert(0);
            case PLUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(b,
                               \"add w%d,w%d,%%2\;\"
                               \"rrnc %%2,%%2\;\"
                               \"mov.d %%1,[%%2]\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub %%2,#%d,%%2\;\"
                                 \"mov.d %%1,[%%2]\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add %%2,#%d,%%2\;\"
                                 \"mov.d %%1,[%%2]\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub #%d,%%2\;\"
                                 \"mov.d %%1,[%%2]\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add #%d,%%2\;\"
                                 \"mov.d %%1,[%%2]\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            case MINUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(b,
                               \"sub w%d,w%d,%%2\;\"
                               \"rrnc %%2,%%2\;\"
                               \"mov.d %%1,[%%2]\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add %%2,#%d,%%2\;\"
                                 \"mov.d %%1,[%%2]\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub %%2,#%d,%%2\;\"
                                 \"mov.d %%1,[%%2]\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add #%d,%%2\;\"
                                 \"mov.d %%1,[%%2]\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub #%d,%%2\;\"
                                 \"mov.d %%1,[%%2]\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            }
        case 3:
          /* T */
          if (pic30_eds_target()) {
            return \"mov #edspage(%0),%2\;\"
                   \"mov %2,DSWPAG\;\"
                   \"mov %1,%0\;\"
                   \"mov %d1,%0+2\";
          } else {
            return \"mov %1,%0\;\"
                   \"mov %d1,%0+2\";
          }
        case 2:
          /* U */                
          return \"mov %1,%0\;\"
                 \"mov %d1,%0+2\";
      }
    }"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)

(define_insn "P32UMMwtr_<mode>_16"
   [(set (match_operand:SM48BIT   0 "pic30_mem_wtumm_operand" "=R,QS,U,T")
         (unspec:SM48BIT [
           (match_operand:SM48BIT 1 "pic30_register_operand" " r,r, r,r")
           (clobber
             (match_scratch:HI    2                         "=&r,&r,&r,&r"))
          ] UNSPEC_UNIFIED_WT))
    (clobber (reg:HI DSWPAG))
    (clobber (reg:CC_NZC CC_REG))
   ]
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "*
    { rtx lhs;
      rtx rhs;
      rtx addr = XEXP(operands[0],0);
      static char buffer[255];
      char *b = buffer;
      switch(which_alternative) {
        default: gcc_assert(0);
        case 0: if (pic30_eds_target()) {
                  return \"mov %T0,DSWPAG\;\"
                         \"rrnc %r0,%2\;\"
                         \"mov.d %1,[%2++]\;\"
                         \"mov.w %t1,[%2]\";
                } else {
                  return 
                         \"rrnc %r0,%2\;\"
                         \"mov.d %1,[%2++]\;\"
                         \"mov.w %t1,[%2]\";
                }
        case 1:
          /* QS */
          lhs = XEXP(addr,0);
          rhs = XEXP(addr,1);
          if (pic30_eds_target()) {
            b += sprintf(buffer,\"mov %%T0,DSWPAG\;\");
          }
          switch (GET_CODE(addr)) {
            default:  gcc_assert(0);
            case PLUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(b,
                               \"add w%d,w%d,%%2\;\"
                               \"rrnc %%2,%%2\;\"
                               \"mov.d %%1,[%%2++]\;\"
                               \"mov.w %%t1,[%%2]\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub %%2,#%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.w %%t1,[%%2]\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add %%2,#%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.w %%t1,[%%2]\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub #%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.w %%t1,[%%2]\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add #%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.w %%t1,[%%2]\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            case MINUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(b,
                               \"sub w%d,w%d,%%2\;\"
                               \"rrnc %%2,%%2\;\"
                               \"mov.d %%1,[%%2++]\;\"
                               \"mov.w %%t1,[%%2]\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add %%2,#%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.w %%t1,[%%2]\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub %%2,#%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.w %%t1,[%%2]\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add #%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.w %%t1,[%%2]\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub #%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.w %%t1,[%%2]\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            }
        case 3:
          /* T */
          if (pic30_eds_target()) {
            return \"mov #edspage(%0),%2\;\"
                   \"mov %2,DSWPAG\;\"
                   \"mov %1,%0\;\"
                   \"mov %d1,%0+2\;\"
                   \"mov %t1,%0+4\";
          } else {
            return \"mov %1,%0\;\"
                   \"mov %d1,%0+2\;\"
                   \"mov %t1,%0+4\";
          }
        case 2:
          /* U */                
            return \"mov %1,%0\;\"
                   \"mov %d1,%0+2\;\"
                   \"mov %t1,%0+4\";

      }
    }"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)

(define_insn "P32UMMwtr_<mode>_16"
   [(set (match_operand:SM64BIT   0 "pic30_mem_wtumm_operand" "=R,QS,U,T")
         (unspec:SM64BIT [
           (match_operand:SM64BIT 1 "pic30_register_operand" " r,r, r,r")
           (clobber
             (match_scratch:HI    2                         "=&r,&r,&r,&r"))
          ] UNSPEC_UNIFIED_WT))
    (clobber (reg:HI DSWPAG))
    (clobber (reg:CC_NZC CC_REG))
   ]
   "(TARGET_EDS) && (TARGET_EDS_MODE == P32UMMmode)"
   "*
    { rtx lhs;
      rtx rhs;
      rtx addr = XEXP(operands[0],0);
      static char buffer[255];
      char *b = buffer;
      switch(which_alternative) {
        default: gcc_assert(0);
        case 0: if (pic30_eds_target()) {
                  return \"mov %T0,DSWPAG\;\"
                         \"rrnc %r0,%2\;\"
                         \"mov.d %1,[%2++]\;\"
                         \"mov.d %t1,[%2]\";
                } else {
                  return 
                         \"rrnc %r0,%2\;\"
                         \"mov.d %1,[%2++]\;\"
                         \"mov.d %t1,[%2]\";
                }
        case 1:
          /* QS */
          lhs = XEXP(addr,0);
          rhs = XEXP(addr,1);
          if (pic30_eds_target()) {
            b += sprintf(buffer,\"mov %%T0,DSWPAG\;\");
          }
          switch (GET_CODE(addr)) {
            default:  gcc_assert(0);
            case PLUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(b,
                               \"add w%d,w%d,%%2\;\"
                               \"rrnc %%2,%%2\;\"
                               \"mov.d %%1,[%%2++]\;\"
                               \"mov.d %%t1,[%%2]\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub %%2,#%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.d %%t1,[%%2]\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add %%2,#%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.d %%t1,[%%2]\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub #%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.d %%t1,[%%2]\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add #%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.d %%t1,[%%2]\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            case MINUS: 
              if (GET_CODE(rhs) == REG) {
                sprintf(b,
                               \"sub w%d,w%d,%%2\;\"
                               \"rrnc %%2,%%2\;\"
                               \"mov.d %%1,[%%2++]\;\"
                               \"mov.d %%t1,[%%2]\", REGNO(lhs), REGNO(rhs));
                return buffer;
              } else if (GET_CODE(rhs) == CONST_INT) {
                int val = INTVAL(rhs);
                if (satisfies_constraint_N(rhs)) {
                  // small negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add %%2,#%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.d %%t1,[%%2]\", REGNO(lhs), -val);
                } else if (satisfies_constraint_P(rhs)) {
                  // small positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub %%2,#%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.d %%t1,[%%2]\", REGNO(lhs), val);
                } else if (val < 0) {
                  // negative
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"add #%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.d %%t1,[%%2]\", REGNO(lhs), -val);
                } else {
                  // positive
                  sprintf(b,
                                 \"rrnc w%d,%%2\;\"
                                 \"sub #%d,%%2\;\"
                                 \"mov.d %%1,[%%2++]\;\"
                                 \"mov.d %%t1,[%%2]\", REGNO(lhs), val);
                }
                return buffer;
              }
              gcc_assert(0);
            }
        case 3:
          /* T */
          if (pic30_eds_target()) {
            return \"mov #edspage(%0),%2\;\"
                   \"mov %2,DSWPAG\;\"
                   \"mov %1,%0\;\"
                   \"mov %d1,%0+2\;\"
                   \"mov %t1,%0+4\;\"
                   \"mov %q1,%0+6\";
          } else {
            return \"mov %1,%0\;\"
                   \"mov %d1,%0+2\;\"
                   \"mov %t1,%0+4\;\"
                   \"mov %q1,%0+6\";
          }
        case 2:
          /* U */                
            return \"mov %1,%0\;\"
                   \"mov %d1,%0+2\;\"
                   \"mov %t1,%0+4\;\"
                   \"mov %q1,%0+6\";
      }
    }"
   [ 
     (set_attr "type" "defuse")
     (set_attr "cc" "clobber")
   ]
)



;; if unified is P32PEDS

(define_insn "copyfpP32PEDS_16"
  [(set (match_operand:P32PEDS  0 "pic30_register_operand" "=r")
        (uextend:P32PEDS
          (match_operand:HI 1 "register_operand" "r")))]
  "(TARGET_EDS && (TARGET_EDS_MODE == P32PEDSmode) && 
   (((pic30_frame_pointer_required() && REGNO(operands[1]) == FP_REGNO)) || 
    (REGNO(operands[1]) == SP_REGNO)))"
  "mov %1,%0\;mov #1,%d0"
)
  
(define_insn "fpcopyP32PEDS_16"
  [(set (match_operand:HI   0 "register_operand"      "=r")
        (utrunc:HI
          (match_operand:P32PEDS 1 "pic30_register_operand" "r")))]
  "(TARGET_EDS && (TARGET_EDS_MODE == P32PEDSmode) &&
    (((pic30_frame_pointer_required() && REGNO(operands[0]) == FP_REGNO)) || 
    (REGNO(operands[0]) == SP_REGNO)))"
  "mov %1,%0"
)

(define_insn "movqiP32PEDS_16"
  [(set (match_operand:QI 0 "pic30_move2_operand"    "=r,RSQ")
        (match_operand:QI 1 "pic30_register_operand"       "r,r"))]
  "TARGET_EDS"
  "*
   if (which_alternative == 0) {
     return \"mov.b %1,%0\";
   }
   if (pic30_ecore_target() || pic30_isav4_target()) {
     return \"movpag #1,DSWPAG\;mov.b %1,%0\";
   } else {
     return \"mov.b %1,%0\";
   }
  "
)

;; if unified is P3PEDS

(define_insn "copyfpP32EDS_16"
  [(set (match_operand:P32EDS  0 "pic30_register_operand" "=r")
        (uextend:P32EDS
          (match_operand:HI 1 "register_operand" "r")))]
  "(TARGET_EDS && (TARGET_EDS_MODE == P32EDSmode) && 
   (((pic30_frame_pointer_required() && REGNO(operands[1]) == FP_REGNO)) || 
    (REGNO(operands[1]) == SP_REGNO)))"
  "mov %1,%0\;mov #1,%d0"
)
  
(define_insn "fpcopyP32EDS_16"
  [(set (match_operand:HI   0 "register_operand"      "=r")
        (utrunc:HI
          (match_operand:P32EDS 1 "pic30_register_operand" "r")))]
  "(TARGET_EDS && (TARGET_EDS_MODE == P32EDSmode) &&
    (((pic30_frame_pointer_required() && REGNO(operands[0]) == FP_REGNO)) || 
    (REGNO(operands[0]) == SP_REGNO)))"
  "mov %1,%0"
)

;; if unified is SImode

(define_insn "copyfpP32UMM_16"
  [(set (match_operand:P32UMM  0 "pic30_register_operand" "=r")
        (uextend:P32UMM
          (match_operand:HI 1 "register_operand" "r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(TARGET_EDS && (TARGET_EDS_MODE == P32UMMmode) && 
   (((pic30_frame_pointer_required() && REGNO(operands[1]) == FP_REGNO)) || 
    (REGNO(operands[1]) == SP_REGNO)))"
  "rlnc %1,%0\;mov #1,%d0"
)
  
(define_insn "fpcopyP32UMM_16"
  [(set (match_operand:HI   0 "register_operand"      "=r")
        (utrunc:HI
          (match_operand:P32UMM 1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(TARGET_EDS && (TARGET_EDS_MODE == P32UMMmode) &&
    (((pic30_frame_pointer_required() && REGNO(operands[0]) == FP_REGNO)) || 
    (REGNO(operands[0]) == SP_REGNO)))"
  "rrnc %1,%0"
)

(define_insn "movqiP32PEDS2_16"
  [(set (match_operand:QI 0 "pic30_register_operand"      "=r,r")
        (match_operand:QI 1 "pic30_move2_operand"    " r,RSQ")
  )]
  "TARGET_EDS && (TARGET_EDS_MODE == P32PEDSmode)"
  "*
   if (which_alternative == 0) {
     return \"mov.b %1,%0\";
   }
   if (pic30_ecore_target() || pic30_isav4_target()) {
     return \"movpag #1,DSRPAG\;mov.b %1,%0\";
   } else {
     return \"mov.b %1,%0\";
   }
  "
)

(define_insn "movhiP32PEDS_16"
  [(set (match_operand:HI 0 "pic30_move2_operand"     "=r,RSQ")
        (match_operand:HI 1 "pic30_register_operand"       "r,r"))]
  "TARGET_EDS && (TARGET_EDS_MODE == P32PEDSmode)"
  "*
   if (which_alternative == 0) {
     return \"mov %1,%0\";
   }
   if (pic30_ecore_target() || pic30_isav4_target()) {
     return \"movpag #1,DSWPAG\;mov %1,%0\";
   } else {
     return \"mov %1,%0\";
   }
  "
)

(define_insn "movhiP32PEDS2_16"
  [(set (match_operand:HI 0 "pic30_register_operand"      "=r,r")
        (match_operand:HI 1 "pic30_move2_operand"    " r,RSQ")
  )]
  "TARGET_EDS && (TARGET_EDS_MODE == P32PEDSmode)"
  "*
   if (which_alternative == 0) {
     return \"mov %1,%0\";
   }
   if (pic30_ecore_target() || pic30_isav4_target()) {
     return \"movpag #1,DSRPAG\;mov %1,%0\";
   } else {
     return \"mov %1,%0\";
   }
  "
)

(define_insn "mov<mode>P32PEDS_16"
  [(set (match_operand:SM32BIT 0 "pic30_move2_operand"    "=r,R,Q,<>")
        (match_operand:SM32BIT 1 "pic30_register_operand" " r,r,r,r"))]
  "TARGET_EDS && (TARGET_EDS_MODE == P32PEDSmode)"
  "*
   if (which_alternative == 0) {
     return \"mov.d %1,%0\";
   }
   if (pic30_ecore_target() || pic30_isav4_target()) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 1: return \"movpag #1,DSWPAG\;mov.d %1,%0\";
       case 2: return \"movpag #1,DSWPAG\;mov %1,%0\;mov %d1,%Q0\";
       case 3: 
         if (GET_CODE(XEXP(operands[0],0)) == POST_INC) {
           return \"movpag #1,DSWPAG\;mov %1,%0\;mov %d1,%0\";
         } else {
           return \"movpag #1,DSWPAG\;mov %d1,%0\;mov %1,%0\";
         }
     }
   } else {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 1: return \"mov.d %1,%0\";
       case 2: return \"mov %1,%0\;mov %d1,%Q0\";
       case 3: 
         if (GET_CODE(XEXP(operands[0],0)) == POST_INC) {
           return \"mov %1,%0\;mov %d1,%0\";
         } else {
           return \"mov %d1,%0\;mov %1,%0\";
         }
     }
   }
  "
)

; not used
(define_insn "mov<mode>P32PEDS2_16"
  [(set (match_operand:SM32BIT 0 "pic30_register_operand" "=r,r,r,r")
        (match_operand:SM32BIT 1 "pic30_move2_operand"    " r,R,Q,<>")
  )]
  "TARGET_EDS && (TARGET_EDS_MODE == P32PEDSmode)"
  "*
   if (which_alternative == 0) {
     return \"mov.d %1,%0\";
   }
   if (pic30_ecore_target() || pic30_isav4_target()) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 1:
         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
           if (REGNO(XEXP(operands[1],0)) == REGNO(operands[0])) {
             return \"movpag #1,DSRPAG\;mov %Q1,%d0\;mov %1,%0\";
           } else {
             return \"movpag #1,DSRPAG\;mov %1,%0\;mov %Q1,%d0\";
           }
         } else {
           return \"movpag #1,DSWPAG\;mov.d %1,%0\";
         }
       case 2: {
         /* MEM ( PLUS ( reg,)) */
         rtx inner = XEXP(operands[1],0);
         if (REGNO(XEXP(inner,0)) == REGNO(operands[0])) {
           return \"movpag #1,DSRPAG\;mov %Q1,%d0\;mov %1,%0\";
         } else {
           return \"movpag #1,DSRPAG\;mov %1,%0\;mov %Q1,%d0\";
         }
       }
       case 3: {
         if (GET_CODE(XEXP(operands[1],0)) == POST_INC) {
           return \"movpag #1,DSRPAG\;mov %1,%0\;mov %1,%d0\";
         } else {
           return \"movpag #1,DSRPAG\;mov %1,%d0\;mov %1,%0\";
         }
       }
     }
   } else {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 1: 
         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
           if (REGNO(XEXP(operands[1],0)) == REGNO(operands[0])) {
             return \"mov %Q1,%d0\;mov %1,%0\";
           } else {
             return \"mov %1,%0\;mov %Q1,%d0\";
           }
         } else {
           return \"mov.d %1,%0\";
         }     
       case 2:  {
         /* MEM ( PLUS ( reg,)) */ 
         rtx inner = XEXP(operands[1],0);
         if (REGNO(XEXP(inner,0)) == REGNO(operands[0])) {
           return \"mov %Q1,%d0\;mov %1,%0\";
         } else {
           return \"mov %1,%0\;mov %Q1,%d0\";
         }
       }  
       case 3: {
         if (GET_CODE(XEXP(operands[1],0)) == POST_INC) {
           return \"mov %1,%0\;mov %1,%d0\";
         } else {
           return \"mov %1,%d0\;mov %1,%0\";
         }
       }
     }
   }
  "
)

(define_insn "movhi_P24PROGaddress_low_16"
  [(set (match_operand:HI 0 "pic30_register_operand"               "=r")
        (subreg:HI
          (match_operand:P24PROG 1 "pic30_symbolic_address_operand" "qs") 0))]
  "(!pic30_isa32_target())"
  "mov #tbloffset(%1),%0"
 [
  (set_attr "cc" "change0")
  (set_attr "type" "def")
  (set_attr "op_type" "movlit")
 ]
)

(define_insn "movp16pmp_lit_16"
  [(set (match_operand:P16PMP 0 "pic30_register_operand"          "=r")
        (match_operand:P16PMP 1 "immediate_operand"               "i"))]
  "(!pic30_isa32_target())"
  "mov #%1,%0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "movp32df_lit_16"
  [(set (match_operand:P32DF 0 "pic30_register_operand"           "=r")
        (match_operand:P32DF 1 "immediate_operand"                "i"))]
  "(!pic30_isa32_target())"
  "*
   { static char buffer[80];
     long i = INTVAL(operands[1]);

     if (pic30_symbolic_address_operand(operands[1],P32DFmode)) {
       sprintf(buffer,\"mov #packed_lo(%%1),%%0\;mov #packed_hi(%%1),%%d0\");
     } else {
       sprintf(buffer,\"mov #%ld,%%0\;mov #%ld,%%d0\",(i & 0xFFFF),
                      (i & 0xFFFF0000) >> 15);
     }
     return buffer;
   }"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)


(define_insn "movp32eds_lit_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand"          "=r")
        (match_operand:P32EDS 1 "immediate_operand"               "i"))]
  "(!pic30_isa32_target())"
  "*
   { static char buffer[80];
     long i = INTVAL(operands[1]);
   
     if (pic30_symbolic_address_operand(operands[1],P32EDSmode)) {
       sprintf(buffer,\"mov #edsoffset(%%1),%%0\;mov #edspage(%%1),%%d0\");
     } else {
       sprintf(buffer,\"mov #%ld,%%0\;mov #%ld,%%d0\",
                     (i & 0x7FFF) | (((i>>15) !=0) << 15),
                      i >> 15);
     }
     return buffer;
   }"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "movp32peds_lit_16"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand"          "=r")
        (match_operand:P32PEDS 1 "immediate_operand"               "i"))]
  "(!pic30_isa32_target())"
  "*
   { static char buffer[80];
     long i = INTVAL(operands[1]);

     if (pic30_symbolic_address_operand(operands[1],P32PEDSmode)) {
       sprintf(buffer,\"mov #edsoffset(%%1),%%0\;mov #edspage(%%1),%%d0\");
     } else {
       if (INTVAL(operands[1]) == 0) {
         sprintf(buffer,\"mul.uu %%0,#0,%%0\");
       } else {
         sprintf(buffer,\"mov #%ld,%%0\;mov #%ld,%%d0\",(i & 0x7FFF),
                         (i & 0xFF8000) >> 15);
       }
     }
     return buffer;
   }"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "movp24psv_lit_16"
  [(set (match_operand:P24PSV 0 "pic30_register_operand"          "=r")
        (match_operand:P24PSV 1 "immediate_operand"               "i"))]
  "(!pic30_isa32_target())"
  "* 
   { static char buffer[80];
     long i = INTVAL(operands[1]);

     if (pic30_symbolic_address_operand(operands[1],P24PSVmode)) {
       sprintf(buffer,\"mov #tbloffset(%%1),%%0\;mov #tblpage(%%1),%%d0\");
     } else {
       sprintf(buffer,\"mov #%ld,%%0\;mov #%ld,%%d0\",(i & 0xFFFF), 
                      (i & 0xFF0000) >> 16);
     }
     return buffer;
   }"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "movp24prog_lit_16"
  [(set (match_operand:P24PROG 0 "pic30_register_operand"          "=r")
        (match_operand:P24PROG 1 "immediate_operand"               "i"))]
  "(!pic30_isa32_target())"
  "*
   { static char buffer[80];
     long i = INTVAL(operands[1]);

     if (pic30_symbolic_address_operand(operands[1],P24PROGmode)) {
       sprintf(buffer,\"mov #tbloffset(%%1),%%0\;mov #tblpage(%%1),%%d0\");
     } else {
       sprintf(buffer,\"mov #%ld,%%0\;mov #%ld,%%d0\",(i & 0xFFFF),
                      (i & 0xFF0000) >> 16);
     }
     return buffer;
   }"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 32-bit integer moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Invalid move

(define_insn "*movsi_invalid_1_16"
  [(set (match_operand:SI 0 "pic30_register_operand"  "=r")
        (match_operand:SI 1 "pic30_code_operand" "g"))]
  "(!pic30_isa32_target())"
  "*
{
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
}

")
(define_insn "*movsi_invalid_2_16"
  [(set (match_operand:SI 0 "pic30_code_operand" "=g")
        (match_operand:SI 1 "pic30_register_operand"    "r"))]
  "(!pic30_isa32_target())"
  "*
{
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
}
")

(define_insn "*movsi_invalid_3_16"
  [(set (match_operand:SI     0 "register_operand" "")
        (mem:SI
          (plus:HI
            (reg:HI SPREG)
            (match_operand    1 "immediate_operand" ""))))]
  "(INTVAL(operands[1]) & 1)"
  "*
   {
     if (!warn_cast_align) {
       error(\"Odd offset to integer sized dereference;\n\"
             \"  suggest -Wcast-align to identify invalid type punning\");
     } else {
       error(\"Odd offset to integer sized dereference\");
     }
     return \"cannot generate instruction\";
   }
  "
)

(define_insn "*movsi_invalid_4_16"
  [(set
        (mem:SI
          (plus:SI
            (reg:HI SPREG)
            (match_operand    0 "immediate_operand" "")))
        (match_operand:SI     1 "general_operand" ""))
  ]
  "(INTVAL(operands[0]) & 1)"
  "*
{
     if (!warn_cast_align) {
       error(\"Odd offset to integer sized dereference;\n\"
             \"  suggest -Wcast-align to identify invalid type punning\");
     } else {
       error(\"Odd offset to integer sized dereference\");
     }
     return \"cannot generate instruction\";
}
  "
)

(define_insn "mov<mode>_const0_16"
  [(set (match_operand:GM32BIT 0 "pic30_move_operand" "=r,R,<>,U")
        (const_int 0))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   static const char *normal_patterns[] = {
     \"mul.uu %0,#0,%0\",
     \"clr %0\;mov %I0,%D0\",
     \"clr %0\;clr %0\",
     \"clr %0\;clr %0+2\"
   };

   static const char *psv_psv_patterns[] = {
     \"mul.uu %0,#0,%0\",
     \"clr %0\;nop\;mov %I0,%D0\",
     \"clr %0\;nop\;clr %0\"
     \"clr %0\;clr %0+2\"
   };

   if (pic30_psrd_psrd_errata(operands[0],NULL)) {
     pic30_rtx_nops++;
     if (pic30_pre_modify(operands[0])) {
       return \"add %r0,#4,%r0\;clr %I0\;nop\;clr %D0\";
     } else return psv_psv_patterns[which_alternative];
   } else {
     if (pic30_pre_modify(operands[0])) {
       return \"add %r0,#4,%r0\;clr %I0\;clr %D0\";
     } else return normal_patterns[which_alternative];
   }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,use,defuse,etc")
   (set_attr "op_type" "movlit")
  ]
)

(define_insn "movsi_const1_16"
  [(set (match_operand:SI 0 "pic30_mode2res_operand" "=r,R,<>")
	(const_int -1))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   
   static const char *normal_patterns[] = {
     \"setm %0\;setm %d0\",
     \"setm %I0\;setm %D0\",
     \"setm %0\;setm %0\"
   };

   static const char *psv_psv_patterns[] = {
     \"setm %0\;setm %d0\",
     \"setm %I0\;nop\;setm %D0\",
     \"setm %0\;nop\;setm %0\"
   };

   if (pic30_psrd_psrd_errata(operands[0],NULL)) {
     pic30_rtx_nops++;
   if (pic30_pre_modify(operands[0])) {
       return \"add %r0,#4,%r0\;setm %I0\;nop\;setm %D0\";
     } else return psv_psv_patterns[which_alternative];
   } else {
     if (pic30_pre_modify(operands[0])) {
     return \"add %r0,#4,%r0\;setm %I0\;setm %D0\";
   } else return normal_patterns[which_alternative];
   }

  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,use,use")
   (set_attr "op_type" "movlit")
  ]
)

(define_insn "movsi_const0sfr_16"
  [(set (match_operand:SI 0 "pic30_near_operand" "=U")
	(const_int 0))]
  "(!pic30_isa32_target())"
  "clr %0\;clr %0+2"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "movsi_const1sfr_16"
  [(set (match_operand:SI 0 "pic30_near_operand" "=U")
	(const_int -1))]
  "(!pic30_isa32_target())"
  "setm %0\;setm %0+2"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "etc")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "movsi_imm_16"
  [(set (match_operand:SI 0 "pic30_register_operand" "=r,r")
        (match_operand:SI 1 "immediate_operand" "O,i"))]
  "(!pic30_isa32_target())"
  "@
   mul.uu %0,#0,%0
   mov #%z1,%0\;mov #%y1,%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "movlit")
  ]
)

(define_insn "movaccsi_16"
  [(set (match_operand:SI 0 "pic30_register_operand"    "=r")
        (match_operand:SI 1 "pic30_accumulator_operand" " w"))]
  "(!pic30_isa32_target()) && pic30_integer_mac_support"
  "mov %m1L,%0\;mov %m1H,%d0"
  [
    (set_attr "op_type" "mov")
  ]
)

(define_insn "movsiacc_16"
  [(set (match_operand:SI 0 "pic30_accumulator_operand" "=w")
        (match_operand:SI 1 "pic30_register_operand"    " r"))]
  "(!pic30_isa32_target()) && pic30_integer_mac_support"
  "mov %1,%m0L\;mov %d1,%m0H"
  [
    (set_attr "op_type" "mov")
  ]
)

/*VRT: Need optimized fix for psrd psrd*/
(define_insn "mov<mode>_gen_16"
  [(set 
    (match_operand:GM32BIT 0 "pic30_move_operand" "=r,r,&r,r,R,R,R,>,>,Q,&r,<,r,T")
    (match_operand:GM32BIT 1 "pic30_move_operand"  "r,R, >,Q,r,0,R,r,>,r, <,r,T,r")
   )
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
        int idDst, idSrc;

	switch (which_alternative)
	{
        default: gcc_assert(0);
	case 0: /* r = r */
		return \"mov.d %1,%0\";
	case 1: /* r = R */
		if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
                  int src = REGNO(XEXP(operands[1],0));
                  int dst = REGNO(operands[0]);
                  if (src == dst) {
                    return \"mov %Q1,%d0\;mov %1,%0\";
                  } else {
                    return \"mov %1,%0\;mov %Q1,%d0\";
                  }
                } else {
		return \"mov.d %1,%0\";
                }
	case 2: /* r = > */
                if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
                  if (pic30_pre_modify(operands[1])) {
                    return \"add %r1,#4,%r1\;mov [%r1],%0\;mov [%r1+2],%d0\";
                  } else {
                    return \"mov %1,%0\;mov %1,%d0\";
                  }
                } else { 
                return \"mov.d %1,%0\";
                }
	case 3: /* r = Q */
		idDst = REGNO(operands[0]);
		idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
                if (pic30_psrd_psrd_errata(NULL,operands[1])) {
                  pic30_rtx_nops++;
		  if (idDst == idSrc)
                  {
                     return \"mov %Q1,%d0\;nop\;mov %1,%0\";
                  } else {
                     return \"mov %1,%0\;nop\;mov %Q1,%d0\";
                  }
                } else {
		  if (idDst == idSrc)
                  {
                     return \"mov %Q1,%d0\;mov %1,%0\";
                  } else {
                     return \"mov %1,%0\;mov %Q1,%d0\";
                  }
                }
	case 4: /* R = r */
 		return \"mov.d %1,%0\";
        case 5: /* R = 0 */
                return \"mov %1,%I0\;mov %1,%D0\";
        case 6: /* R = R */
                if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                  pic30_rtx_nops++;
                  return \"mov %I1,%I0\;nop\;mov %D1,%D0\";
                } else {
                  return \"mov %I1,%I0\;mov %D1,%D0\";
                }
	case 7: /* > = r */
                return \"mov.d %1,%0\";
	case 8: /* > = > */
                /* any pre-decrement cannot be done in 'pieces' */
                { int op0_pre,op1_pre;

                  op0_pre = pic30_pre_modify(operands[0]);
                  op1_pre = pic30_pre_modify(operands[1]);
                  if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                    pic30_rtx_nops++;
                    if (op0_pre && op1_pre) {
		      return \"add #4,%r1\;add #4,%r0\;\"
                             \"mov %I1,%I0\;nop\;mov %D1,%D0\";
                    } else if (op0_pre) {
                      return \"add #4,%r0\;mov %1,%I0\;nop\;mov %1,%D0\";
                    } else if (op1_pre) {
                      return \"add #4,%r1\;mov %I1,%0\;nop\;mov %D1,%0\";
                    } else return \"mov %1,%0\;nop\;mov %1,%0\";
                  } else {
                    if (op0_pre && op1_pre) {
		      return \"add #4,%r1\;add #4,%r0\;\"
                             \"mov %I1,%I0\;mov %D1,%D0\";
                    } else if (op0_pre) {
                      return \"add #4,%r0\;mov %1,%I0\;mov %1,%D0\";
                    } else if (op1_pre) {
                      return \"add #4,%r1\;mov %I1,%0\;mov %D1,%0\";
                    } else return \"mov %1,%0\;mov %1,%0\";
                  }
                }
	case 9: /* Q = r */
		return \"mov %1,%0\;mov %d1,%Q0\";
	case 10: /* r = < */
                if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
                  if (pic30_pre_modify(operands[1])) {
                    return \"sub %r1,#4,%r1\;mov [%r1],%0\;mov [%r1+2],%d0\";
                  } else {
                    return \"mov [%r1+2],%d0\;mov [%r1],%0\;sub %r1,#4,%r1\";
                  }
                } else {
                  return \"mov.d %1,%0\";
                }
	case 11: /* < = r */
                return \"mov.d %1,%0\";
	case 12: /* r = T */
               if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                  pic30_rtx_nops++;
		  return \"mov %1,%0\;nop\;mov %Q1,%d0\";
               } else return \"mov %1,%0\;mov %Q1,%d0\";
	case 13: /* T = r */
		return \"mov %1,%0\;mov %d1,%Q0\";
	}
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type"
             "def,defuse,defuse,use,use,use,use,use,use,use,use,defuse,def,etc")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "mov<mode>_gen_APSV_16"
  [(set 
    (match_operand:GM32BIT 0 "pic30_move_operand" "=r,r,&r,r,R,R,R,>,>,Q,&r,<,r,T")
    (unspec:GM32BIT [
      (match_operand:GM32BIT 1 "pic30_move_APSV_operand"  
                                                  "r,R, >,Q,r,0,R,r,>,r, <,r,T,r")
      (reg:HI PSVPAG)] UNSPECV_USEPSV))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
        int idDst, idSrc;

	switch (which_alternative)
	{
        default: gcc_assert(0);
	case 0: /* r = r */
		return \"mov.d %1,%0\";
	case 1: /* r = R */
                if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
                  int src = REGNO(XEXP(operands[1],0));
                  int dst = REGNO(operands[0]);
                  if (src == dst) {
                    return \"mov %Q1,%d0\;mov %1,%0\";
                  } else {
                    return \"mov %1,%0\;mov %Q1,%d0\";
                  }
                } else {
		return \"mov.d %1,%0\";
                }
        case 2: /* r = > */
                if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
                  if (pic30_pre_modify(operands[1])) {
                    return \"add %r1,#4,%r1\;mov [%r1],%0\;mov [%r1+2],%d0\";
                  } else {
                    return \"mov %1,%0\;mov %1,%d0\";
                  }
                } else {
                return \"mov.d %1,%0\";
                }
	case 3: /* r = Q */
		idDst = REGNO(operands[0]);
		idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
                if (pic30_psrd_psrd_errata(NULL,operands[1])) {
                  pic30_rtx_nops++;
		if (idDst == idSrc)
		{
                     return \"mov %Q1,%d0\;nop\;mov %1,%0\";
                  } else {
                     return \"mov %1,%0\;nop\;mov %Q1,%d0\";
                  }
                } else {
                  if (idDst == idSrc)
                  {
			return \"mov %Q1,%d0\;mov %1,%0\";
		} else {
			return \"mov %1,%0\;mov %Q1,%d0\";
		}
                }
	case 4: /* R = r */
		return \"mov.d %1,%0\";
        case 5: /* R = 0 */
                return \"mov %1,%I0\;mov %1,%D0\";
        case 6: /* R = R */
                if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                  pic30_rtx_nops++;
                  return \"mov %I1,%I0\;nop\;mov %D1,%D0\";
                } else {
                  return \"mov %I1,%I0\;mov %D1,%D0\";
                }
	case 7: /* > = r */
                return \"mov.d %1,%0\";
	case 8: /* > = > */
                /* any pre-decrement cannot be done in 'pieces' */
                { int op0_pre,op1_pre;

                  op0_pre = pic30_pre_modify(operands[0]);
                  op1_pre = pic30_pre_modify(operands[1]);
                  if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                    pic30_rtx_nops++;
                    if (op0_pre && op1_pre) {
                      return \"add #4,%r1\;add #4,%r0\;\"
                             \"mov %I1,%I0\;nop\;mov %D1,%D0\";
                    } else if (op0_pre) {
                      return \"add #4,%r0\;mov %1,%I0\;nop\;mov %1,%D0\";
                    } else if (op1_pre) {
                      return \"add #4,%r1\;mov %I1,%0\;nop\;mov %D1,%0\";
                    } else return \"mov %1,%0\;nop\;mov %1,%0\";
                  } else {
                    if (op0_pre && op1_pre) {
                      return \"add #4,%r1\;add #4,%r0\;\"
                             \"mov %I1,%I0\;mov %D1,%D0\";
                    } else if (op0_pre) {
                      return \"add #4,%r0\;mov %1,%I0\;mov %1,%D0\";
                    } else if (op1_pre) {
                      return \"add #4,%r1\;mov %I1,%0\;mov %D1,%0\";
                    } else return \"mov %1,%0\;mov %1,%0\";
                  }
                }
	case 9: /* Q = r */
		return \"mov %1,%0\;mov %d1,%Q0\";
	case 10: /* r = < */
                if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
                  if (pic30_pre_modify(operands[1])) {
                    return \"sub %r1,#4,%r1\;mov [%r1],%0\;mov [%r1+2],%d0\";
                  } else {
                    return \"mov [%r1],%0\;mov [%r1+2],%d0\;sub %r1,#4,%r1\";
                  }
                } else {
                return \"mov.d %1,%0\";
                }
	case 11: /* < = r */
                return \"mov.d %1,%0\";
	case 12: /* r = T */
               if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                  pic30_rtx_nops++;
		  return \"mov %1,%0\;nop\;mov %Q1,%d0\";
               } else return \"mov %1,%0\;mov %Q1,%d0\";
	case 13: /* T = r */
		return \"mov %1,%0\;mov %d1,%Q0\";
	}
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type"
             "def,defuse,defuse,def,use,use,use,use,use,use,defuse,use,def,etc")
   (set_attr "op_type" "mov")
  ]
)

(define_insn "movp32ext_lit_16"
  [(set (match_operand:P32EXT 0 "pic30_register_operand" "=r,r")
        (match_operand:P32EXT 1 "immediate_operand" "O,i"))]
  "(!pic30_isa32_target())"
  "@
   mul.uu %0,#0,%0
   mov #%z1,%0\;mov #%y1,%d0"
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "movlit")
  ]
)

; shift these up so that they are ready to be added
(define_insn "movp32umm_lit_16"
  [(set (match_operand:P32UMM 0 "pic30_register_operand" "=r,r")
        (match_operand:P32UMM 1 "pic30_immediate_operand" "O,i"))]
  ""
  "*
   {
     if (which_alternative == 0) { 
       return \"mul.uu %0,#0,%0\";
     } else {
       static char buffer[80];

       sprintf(buffer, 
               \"mov #%ld,%%0\;\"
               \"mov #%ld,%%d0\", 
               ((INTVAL(operands[1]) << 1) & 0xFFFF),
               ((INTVAL(operands[1]) >> 15) & 0xFFFF));
       return buffer;
     }
   }
  "
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "movlit")
  ]
)

(define_insn "*movsi_constnsfr_16"
  [(set (match_operand:SI 0 "pic30_near_operand" "=U")
        (match_operand:SI 1 "immediate_operand"   "i"))
	(clobber (match_scratch:HI 2             "=r"))]
  "(!pic30_isa32_target())"
  "*
{
     int imm = INTVAL(operands[1]);
     unsigned short msw, lsw;
     msw = (imm >> 16) & 0xffff;
     lsw = (imm) & 0xffff;
     if (msw == 0) {
       if (lsw == 0xffff) {
         return \"setm %0\;clr %0+2\";
       } else {
         return \"mov #%1,%2\;mov %2,%0\;clr %0+2\";
		}
     } else if (lsw == 0) {
       if (msw == 0xffff) {
         return \"setm %0+2\;clr %0\";
       } else {
         return \"mov #%y1,%2\;mov %2,%0+2\;clr %0\";
       }
     } else if (lsw == msw) {
       return \"mov #%z1,%2\;mov %2,%0\;mov %2,%0+2\";
     } else {
       return \"mov #%z1,%2\;mov %2,%0\;mov #%y1,%2\;mov %2,%0+2\";
     }
}"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc")
    (set_attr "op_type" "mov")
  ]
)

(define_expand "movsi_16"
  [(set (match_operand:SI 0 "pic30_general_operand" "")
        (match_operand:SI 1 "pic30_general_operand" ""))]
  "(!pic30_isa32_target())"
  "{
     rtx op;

     /* sometimes get here from emit_move_insn even though the rhs is
      * an add or something.  we need to handle it now that there are
      * potential clobbers of the CC
      *
      * pic30_emit_move_sequence may update operands */
     if (pic30_emit_move_sequence(operands, SImode)) DONE;

     op = operands[1];

     while (GET_CODE(op) == CONST) op = XEXP(op,0);
     switch (GET_CODE(op)) {
       default: gcc_assert(0);
       case PLUS: {
         rtx op1 = XEXP(op,0);
         rtx op2 = XEXP(op,1);
         if (GET_CODE(op1) != SYMBOL_REF) {
           if (!pic30_JMmath_operand(op1,HImode)) {
             op1 = force_reg(SImode,op1);
           }
           if (!pic30_JMmath_operand(op2,HImode)) {
             op2 = force_reg(SImode,op2);
           }
           emit(
             gen_addsi3_16(operands[0], op1, op2)
           );
           DONE;
         }
         /* handle SYMBOL_REF below */
       }
        /* FALLSTHROUGH */
       case CONST_INT:
         if (GET_CODE(op) == CONST_INT) {
           if (GET_CODE(operands[0]) == REG) {
             emit(
               gen_movsi_imm_16(operands[0],operands[1])
             );
             DONE;
           } else {
             if (pic30_mode2_operand(operands[0], GET_MODE(operands[0]))) {
               if (INTVAL(operands[1]) == 0) {
                 emit(
                   gen_movsi_const0_16(operands[0])
                 );
                 DONE;
               } else if (INTVAL(operands[1]) == -1) {
                 emit(
                   gen_movsi_const1_16(operands[0])
                 );
                 DONE;
               }
             } else if (pic30_near_operand(operands[0], GET_MODE(operands[0]))) {
               if (INTVAL(operands[1]) == 0) {
                 emit(
                   gen_movsi_const0sfr_16(operands[0])
                 );
                 DONE;
               } else if (INTVAL(operands[1]) == -1) {
                 emit(
                   gen_movsi_const1sfr_16(operands[0])
                 );
                 DONE;
               }
             } else if (can_create_pseudo_p()) {
               rtx r = force_reg(GET_MODE(operands[0]), op);
               emit(
                 gen_movsi_gen_16(operands[0],r)
               );
               DONE;
             }
           }
           break;
         }
         /* FALLSTHROUGH */
       case CONCATN:
       case CONCAT:
       case SUBREG:
       case REG:
       case LABEL_REF:
       case SYMBOL_REF:
       case MEM:
         if (pic30_reload_in_progress() ||
             (pic30_move_operand(operands[0],SImode) &&
              pic30_move_operand(operands[1],SImode))) {
           emit(
             gen_movsi_gen_16(operands[0],operands[1])
           );
           DONE;
         }
         break;
     }
   }"
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 64-bit integer moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Invalid move

(define_insn "*movdi_invalid_1_16"
  [(set (match_operand:DI 0 "pic30_register_operand"  "=r")
        (match_operand:DI 1 "pic30_code_operand" "g"))]
  "(!pic30_isa32_target())"
  "*
{
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
   }"
)

(define_insn "*movdi_invalid_2_16"
  [(set (match_operand:DI 0 "pic30_code_operand" "=g")
        (match_operand:DI 1 "pic30_register_operand"    "r"))]
  "(!pic30_isa32_target())"
  "*
{
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
}
")

(define_insn "*movdi_invalid_3_16"
  [(set (match_operand:DI     0 "register_operand" "")
        (mem:DI
          (plus:HI
            (reg:HI SPREG)
            (match_operand    1 "immediate_operand" ""))))]
  "(INTVAL(operands[1]) & 1)"
  "*
   {
     if (!warn_cast_align) {
       error(\"Odd offset to integer sized dereference;\n\"
             \"  suggest -Wcast-align to identify invalid type punning\");
     } else {
       error(\"Odd offset to integer sized dereference\");
     }
     return \"cannot generate instruction\";
   }
  "
)
   
(define_insn "*movdi_invalid_4_16"
  [(set
        (mem:DI
          (plus:DI
            (reg:HI SPREG)
            (match_operand    0 "immediate_operand" "")))
        (match_operand:DI     1 "general_operand" ""))
  ]
  "(INTVAL(operands[0]) & 1)"
  "*
{
     if (!warn_cast_align) {
       error(\"Odd offset to integer sized dereference;\n\"
             \"  suggest -Wcast-align to identify invalid type punning\");
     } else {
       error(\"Odd offset to integer sized dereference\");
     }
     return \"cannot generate instruction\";
}
  "
)

(define_insn "*movdi_rimm_16"
  [(set (match_operand:DI 0 "pic30_register_operand" "=r,r")
        (match_operand:DI 1 "immediate_operand" "O,i"))]
  "(!pic30_isa32_target())"
  "*
{
    REAL_VALUE_TYPE r;
    long l[4] = { 0 };

     switch (which_alternative) {
        case 0:
          return \"mul.uu %0,#0,%0\;\"
                 \"mul.uu %t0,#0,%t0\";
        default:
          if (GET_CODE(operands[1]) == CONST_DOUBLE)
          {
            r = *CONST_DOUBLE_REAL_VALUE(operands[1]);
            switch (GET_MODE(operands[1])) {
              case E_VOIDmode:
                /*
                ** Integer
                */
                if (sizeof(HOST_WIDE_INT) == 4) {
                  l[0] = CONST_DOUBLE_LOW(operands[1]);
                  l[1] = CONST_DOUBLE_HIGH(operands[1]);
                } else if (sizeof(HOST_WIDE_INT) == 8) {
                  l[0] = CONST_DOUBLE_LOW(operands[1]) & 0xFFFFFFFF;
                  l[1] = (CONST_DOUBLE_LOW(operands[1]) >> 32) & 0xFFFFFFFF;
                } else {
                  gcc_unreachable();
                }
 
                break;
              default:
                REAL_VALUE_TO_TARGET_LONG_DOUBLE(r, l);
                break;
            }
         } else {
            if (sizeof(HOST_WIDE_INT) == 4) {
              l[0] = INTVAL(operands[1]);
              l[1] = l[0] < 0 ? -1 : 0;
            } else if (sizeof(HOST_WIDE_INT) == 8) {
              l[0] = CONST_DOUBLE_LOW(operands[1]) & 0xFFFFFFFF;
              l[1] = (CONST_DOUBLE_LOW(operands[1]) >> 32) & 0xFFFFFFFF;
            } else {
              gcc_unreachable();
            }
          }
         if ((l[0] == 0) && (l[1] == 0)) {
            return \"mul.uu %0,#0,%0\;\"
                   \"mul.uu %t0,#0,%t0\;\";
         } else if (l[0] == 0) {
           return \"mul.uu %0,#0,%0\;\"
                   \"mov #%x1,%t0\;\"
                   \"mov #%w1,%q0\";
         } else if (l[1] == 0) {
            return \"mov #%z1,%0\;\"
                   \"mov #%y1,%d0\;\"
                   \"mul.uu %t0,#0,%t0\";
         }
         return \"mov #%z1,%0\;\"
                \"mov #%y1,%d0\;\"
                \"mov #%x1,%t0\;\"
                \"mov #%w1,%q0\";
	}
}"
  [
   (set_attr "cc" "unchanged")
   ; (set_attr "type" "def")
   (set_attr "type" "etc")
   (set_attr "op_type" "movlit")
  ]
)

(define_insn "mov<mode>_gen_16"
  [(set (match_operand:GM64BIT 0 "pic30_movedi_operand"
					"=r,r,&r,R,>,&r,<,TU,r,r,r,Q")
        (match_operand:GM64BIT 1 "pic30_movedi_operand" 
					 "r,R, >,r,r, <,r,r, T,U,Q,r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  int idSrc, idDst;
  char temp[64];
  char save[64];
  static char szInsn[64];

  szInsn[0] = 0;
  temp[0] = 0;
  save[0] = 0;

  switch (which_alternative) {
    case 0: /* r = r */
      idDst = REGNO(operands[0]);
      idSrc = REGNO(operands[1]);
      if (idDst <= idSrc) {
        return \"mov.d %1,%0\;mov.d %t1,%t0\";
      } else {
        return \"mov.d %t1,%t0\;mov.d %1,%0\";
      }
    case 1: /* r = R */
      idDst = REGNO(operands[0]);
      idSrc = REGNO(XEXP(operands[1],0));
      if (pic30_pp_modify_valid(0) == 0) {
        if ((idDst > idSrc) || ((idDst+4) <= idSrc)) {
          /*
           ** source & dest don't overlap
           */
          if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
            return \"mov.w %1,%0\;\" 
                   \"mov.w %Q1,%d0\;\"
                   \"mov.w %R1,%t0\;\"
                   \"mov.w %S1,%q0\";
          } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %I1,%0\;\" 
                   \"nop\;\"
                   \"mov.d %D1,%t0\";
          } else {
            return \"mov.d %I1,%0\;\" 
                   \"mov.d %D1,%t0\";
          }
        }
        if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
          switch (idDst + 4 - idSrc) {
            case 4:  /* idSrc == idDst+0 */
              return \"mov.w %Q1,%d0\;\"
                     \"mov.w %R1,%t0\;\"
                     \"mov.w %S1,%q0\;\"
                     \"mov.w %1,%0\";
            case 3:  /* idSrc == idDst+1 */
              return \"mov.w %1,%0\;\" 
                     \"mov.w %R1,%t0\;\"
                     \"mov.w %S1,%q0\;\"
                     \"mov.w %Q1,%d0\";
            case 2:  /* idSrc == idDst+2 */
              return \"mov.w %1,%0\;\" 
                     \"mov.w %Q1,%d0\;\"
                     \"mov.w %S1,%q0\;\"
                     \"mov.w %R1,%t0\";
            default: /* idSrc == idDst+3 */
              return \"mov.w %1,%0\;\" 
                     \"mov.w %Q1,%d0\;\"
                     \"mov.w %R1,%t0\;\"
                     \"mov.w %S1,%q0\";
          }
        }
        if ((idDst+2) > idSrc) {
          /*
           ** [wn] -> wn+2:wn+3:wn:wn+1
           */
          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %P1,%t0\;nop\;mov.d %p1,%0\";
          } else {
            return \"mov.d %P1,%t0\;mov.d %p1,%0\";
          }
        } else {
          /*
           ** [wn] -> wn-2:wn-1:wn:wn+1
           */
          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %I1,%0\;nop\;mov.d %1,%t0\";
          } else {
            return \"mov.d %I1,%0\;mov.d %1,%t0\";
          }
        } 
      } else { 
        if ((idDst > idSrc) || ((idDst + 3) <= idSrc)) {
          /*  don't significantly overlap */ 
         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
            return \"mov.w %1,%0\;\"   
                   \"mov.w %Q1,%d0\;\"
                   \"mov.w %R1,%t0\;\"
                   \"mov.w %S1,%q0\";
          } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %1,%0\;nop\;mov [%r1+4],%t0\;nop\;mov [%r1+6],%q0\";
          } else {
            return \"mov.d %1,%0\;mov [%r1+4],%t0\;mov [%r1+6],%q0\";
          }
        }
        /* idDst <= idSrc < idDst+3 */
        if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
        switch (idDst + 4 - idSrc) {
          case 4:  /* idSrc == idDst+0 */
              return \"mov.w %Q1,%d0\;\"
                     \"mov.w %R1,%t0\;\"
                     \"mov.w %S1,%q0\;\"
                     \"mov.w %1,%0\";
          case 3:  /* idSrc == idDst+1 */
              return \"mov.w %1,%0\;\"
                     \"mov.w %R1,%t0\;\"
                     \"mov.w %S1,%q0\;\"
                     \"mov.w %Q1,%d0\";
            case 2:  /* idSrc == idDst+2 */
              return \"mov.w %1,%0\;\"
                     \"mov.w %Q1,%d0\;\"
                     \"mov.w %S1,%q0\;\"
                     \"mov.w %R1,%t0\";
            default: /* idSrc == idDst+3 */
              return \"mov.w %1,%0\;\"
                     \"mov.w %Q1,%d0\;\"
                     \"mov.w %R1,%t0\;\"
                     \"mov.w %S1,%q0\";
           }
        }
        switch (idDst + 4 - idSrc) {
          case 4:  /* idSrc == idDst+0 */
          case 3:  /* idSrc == idDst+1 */
            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
              pic30_rtx_nops+=2;
              return \"mov.w [%r1+4],%t0\;\"
                     \"nop\;\"
                     \"mov.w [%r1+6],%q0\;\"
                     \"nop\;\"
                     \"mov.d %1,%0\";
            } else {
              return \"mov.w [%r1+4],%t0\;\"
                     \"mov.w [%r1+6],%q0\;\"
                     \"mov.d %1,%0\";
            }
          case 2:  /* idSrc == idDst+2 */
            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
              pic30_rtx_nops+=2;
              return \"mov.d %1,%0\;\"
                     \"nop\;\"
                     \"mov.w [%r1+6],%q0\;\"
                     \"nop\;\"
                     \"mov.w [%r1+4],%t0\";
            } else {
              return \"mov.d %1,%0\;mov [%r1+6],%q0\;mov [%r1+4],%t0\";
            }
          default: abort();
        }
      }
    case 2: /* r = > */
      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
        if (pic30_pre_modify(operands[1])) {
          return \"add %r1,#8,%r1\;\"
                 \"mov.w [%r1],%0\;\"
                 \"mov.w [%r1+2],%d0\;\"
                 \"mov.w [%r1+4],%t0\;\"
                 \"mov.w [%r1+6],%q0\";
        } else {
          return \"mov.w %1,%0\;\"
                 \"mov.w %1,%d0\;\"
                 \"mov.w %1,%t0\;\"
                 \"mov.w %1,%q0\";
        }
      } else {
        if (pic30_pre_modify(operands[1]))
          return \"add.w %r1,#8,%r1\;mov.d [%r1++],%0\;mov.d [%r1--],%t0\";
        else
          return \"mov.d %1,%0\;mov.d %1,%t0\";
      }
    case 3: /* R = r */
      return \"mov.d %1,%I0\;mov.d %t1,%D0\";
    case 4: /* > = r */
      if (pic30_pre_modify(operands[0])) {
        return \"add.w %r0,#8,%r0\;mov.d %1,%I0\;mov.d %t1,%D0\";
      } else return \"mov.d %1,%0\;mov.d %t1,%0\";
    case 5: /* r = < */
      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
        if (pic30_pre_modify(operands[1])) {
          return \"sub.w %r1,#8,%r1\;\"
                 \"mov.w [%r1],%0\;\"
                 \"mov.w [%r1+2],%d0\;\"
                 \"mov.w [%r1+4],%t0\;\"
                 \"mov.w [%r1+6],%q0\";
        } else {
          return \"mov.w [%r1],%0\;\"
                 \"mov.w [%r1+2],%d0\;\"
                 \"mov.w [%r1+4],%t0\;\"
                 \"mov.w [%r1+6],%q0\;\"
                 \"sub.w %r1,#8,%r1\";
        }
      } else {
        if (pic30_pre_modify(operands[1])) {
          return \"sub.w %r1,#8,%r1\;mov.d [%r1++],%0\;mov.d [%r1--],%t0\";
        } else {
          return \"mov.d [%r1++],%0\;mov.d [%r1--],%t0\;sub %r1,#8,%r1\";
        }
      }
    case 6: /* < = r */
      if (pic30_pre_modify(operands[1])) {
        return \"sub.w %r0,#8,%r0\;mov.d %1, [%r0++]\;mov.d %t1, [%r0--]\";
      } else {
        return \"mov.d %1,[%r0++]\;mov.d %t1,[%r0--]\;sub %r0,#8,%r0\";
      }
    case 7: /* TU = r */
      return \"mov.w %1,%0\;\"
             \"mov.w %d1,%Q0\;\"
             \"mov.w %t1,%R0\;\"
             \"mov.w %q1,%S0\";
    case 8: /* r = T */
      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
        /* nops not needed, we know that there is no precondition */
        return \"mov.w %1,%0\;\"
               \"mov.w %Q1,%d0\;\"
               \"mov.w %R1,%t0\;\"
               \"mov.w %S1,%q0\";
      } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
        pic30_rtx_nops++;
        return \"mov.w %1,%0\;\"
               \"nop\;\"
               \"mov.w %Q1,%d0\;\"
               \"nop\;\"
               \"mov.w %R1,%t0\;\"
               \"nop\;\"
               \"mov.w %S1,%q0\";
      } else {
        return \"mov.w %1,%0\;\"
               \"mov.w %Q1,%d0\;\"
               \"mov.w %R1,%t0\;\"
               \"mov.w %S1,%q0\";
      }
    case 9: /* r = U */
      return \"mov.w %1,%0\;\"
             \"mov.w %Q1,%d0\;\"
             \"mov.w %R1,%t0\;\"
             \"mov.w %S1,%q0\";
    case 10: /* r = Q */
      idDst = REGNO(operands[0]);
      idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
      strcpy(temp, \"mov.w %1,%0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      strcpy(temp, \"mov.w %Q1,%d0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      strcpy(temp, \"mov.w %R1,%t0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      strcpy(temp, \"mov.w %S1,%q0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      if (save[0]) {
        save[strlen(save)-2] = 0;
        strcat(szInsn, save);
      }
      return szInsn;
    case 11: /* Q = r */
      return \"mov.w %1,%0\;mov.w %d1,%Q0\;mov.w %t1,%R0\;mov.w %q1,%S0\";


    default: gcc_assert(0);
  }
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" 
             "etc,use,use,use,use,use,use,etc,etc,etc,use,use")
  ]
)

(define_insn "mov<mode>_gen_APSV_16"
  [(set (match_operand:GM64BIT 0 "pic30_movedi_operand"
					"=r,r,&r,R,>,&r,<,TU,r,r,r,Q")
        (unspec:GM64BIT [
          (match_operand:GM64BIT 1 "pic30_movedi_operand" 
					 "r,R, >,r,r, <,r,r, T,U,Q,r")
          (reg:HI PSVPAG)] 
         UNSPECV_USEPSV))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  int idSrc, idDst;
  char temp[64];
  char save[64];
  static char szInsn[64];

  szInsn[0] = 0;
  temp[0] = 0;
  save[0] = 0;

  switch (which_alternative) {
    case 0: /* r = r */
      idDst = REGNO(operands[0]);
      idSrc = REGNO(operands[1]);
      if (idDst <= idSrc) {
        return \"mov.d %1,%0\;mov.d %t1,%t0\";
      } else {
        return \"mov.d %t1,%t0\;mov.d %1,%0\";
      }
    case 1: /* r = R */
      idDst = REGNO(operands[0]);
      idSrc = REGNO(XEXP(operands[1],0));
      if (pic30_pp_modify_valid(0) == 0) {
        if ((idDst > idSrc) || ((idDst+4) <= idSrc)) {
          /*
           ** source & dest don't overlap
           */
          if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
            return \"mov %1,%0\;\" 
                   \"mov %Q1,%d0\;\"
                   \"mov %R1,%t0\;\"
                   \"mov %S1,%q0\";
          } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %I1,%0\;\" 
                   \"nop\;\"
                   \"mov.d %D1,%t0\";
          } else {
            return \"mov.d %I1,%0\;\" 
                   \"mov.d %D1,%t0\";
          }
        }
        if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
          switch (idDst + 4 - idSrc) {
            case 4:  /* idSrc == idDst+0 */
              return \"mov %Q1,%d0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %1,%0\";
            case 3:  /* idSrc == idDst+1 */
              return \"mov %1,%0\;\" 
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %Q1,%d0\";
            case 2:  /* idSrc == idDst+2 */
              return \"mov %1,%0\;\" 
                     \"mov %Q1,%d0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %R1,%t0\";
            default: /* idSrc == idDst+3 */
              return \"mov %1,%0\;\" 
                     \"mov %Q1,%d0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\";
          }
        }
        if ((idDst+2) > idSrc) {
          /*
           ** [wn] -> wn+2:wn+3:wn:wn+1
           */
          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %P1,%t0\;nop\;mov.d %p1,%0\";
          } else {
            return \"mov.d %P1,%t0\;mov.d %p1,%0\";
          }
        } else {
          /*
           ** [wn] -> wn-2:wn-1:wn:wn+1
           */
          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %I1,%0\;nop\;mov.d %1,%t0\";
          } else {
            return \"mov.d %I1,%0\;mov.d %1,%t0\";
          }
        } 
      } else { 
        if ((idDst > idSrc) || ((idDst + 3) <= idSrc)) {
          /*  don't significantly overlap */ 
         if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
            return \"mov %1,%0\;\"   
                   \"mov %Q1,%d0\;\"
                   \"mov %R1,%t0\;\"
                   \"mov %S1,%q0\";
          } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops++;
            return \"mov.d %1,%0\;nop\;mov [%r1+4],%t0\;nop\;mov [%r1+6],%q0\";
          } else {
            return \"mov.d %1,%0\;mov [%r1+4],%t0\;mov [%r1+6],%q0\";
          }
        }
        /* idDst <= idSrc < idDst+3 */
        if (pic30_psrd_psrd_errata_movd(NULL,operands[1])) {
        switch (idDst + 4 - idSrc) {
          case 4:  /* idSrc == idDst+0 */
              return \"mov %Q1,%d0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %1,%0\";
          case 3:  /* idSrc == idDst+1 */
              return \"mov %1,%0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %Q1,%d0\";
            case 2:  /* idSrc == idDst+2 */
              return \"mov %1,%0\;\"
                     \"mov %Q1,%d0\;\"
                     \"mov %S1,%q0\;\"
                     \"mov %R1,%t0\";
            default: /* idSrc == idDst+3 */
              return \"mov %1,%0\;\"
                     \"mov %Q1,%d0\;\"
                     \"mov %R1,%t0\;\"
                     \"mov %S1,%q0\";
           }
        }
        switch (idDst + 4 - idSrc) {
          case 4:  /* idSrc == idDst+0 */
          case 3:  /* idSrc == idDst+1 */
            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
              pic30_rtx_nops+=2;
              return \"mov [%r1+4],%t0\;\"
                     \"nop\;\"
                     \"mov [%r1+6],%q0\;\"
                     \"nop\;\"
                     \"mov.d %1,%0\";
            } else {
              return \"mov [%r1+4],%t0\;\"
                     \"mov [%r1+6],%q0\;\"
                     \"mov.d %1,%0\";
            }
          case 2:  /* idSrc == idDst+2 */
            if (pic30_psrd_psrd_errata(operands[1],NULL)) {
              pic30_rtx_nops+=2;
              return \"mov.d %1,%0\;\"
                     \"nop\;\"
                     \"mov [%r1+6],%q0\;\"
                     \"nop\;\"
                     \"mov [%r1+4],%t0\";
            } else {
              return \"mov.d %1,%0\;mov [%r1+6],%q0\;mov [%r1+4],%t0\";
            }
          default: abort();
        }
      }
    case 2: /* r = > */
      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
        if (pic30_pre_modify(operands[1])) {
          return \"add %r1,#8,%r1\;\"
                 \"mov [%r1],%0\;\"
                 \"mov [%r1+2],%d0\;\"
                 \"mov [%r1+4],%t0\;\"
                 \"mov [%r1+6],%q0\";
        } else {
          return \"mov %1,%0\;\"
                 \"mov %1,%d0\;\"
                 \"mov %1,%t0\;\"
                 \"mov %1,%q0\";
        }
      } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
        pic30_rtx_nops+=1;
        if (pic30_pre_modify(operands[1]))
          return \"add %r1,#8,%r1\;mov.d %I1,%0\;nop\;mov.d %D1,%t0\";
        else
          return \"mov.d %1,%0\;nop\;mov.d %1,%t0\";
      } else {
        if (pic30_pre_modify(operands[1]))
          return \"add %r1,#8,%r1\;mov.d %I1,%0\;mov.d %D1,%t0\";
        else
          return \"mov.d %1,%0\;mov.d %1,%t0\";
      }
    case 3: /* R = r */
      return \"mov.d %1,%I0\;mov.d %t1,%D0\";
    case 4: /* > = r */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#8,%r0\;mov.d %1,%I0\;mov.d %t1,%D0\";
      } else return \"mov.d %1,%0\;mov.d %t1,%0\";
    case 5: /* r = < */
      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
        if (pic30_pre_modify(operands[1])) {
          return \"sub %r1,#8,%r1\;\"
                 \"mov [%r1],%0\;\"
                 \"mov [%r1+2],%d0\;\"
                 \"mov [%r1+4],%t0\;\"
                 \"mov [%r1+6],%q0\";
        } else {
          return \"mov [%r1],%0\;\"
                 \"mov [%r1+2],%d0\;\"
                 \"mov [%r1+4],%t0\;\"
                 \"mov [%r1+6],%q0\;\"
                 \"sub %r1,#8,%r1\";
        }
      } else {
        if (pic30_pre_modify(operands[1])) {
          return \"sub %r1,#8,%r1\;mov.d [%r1++],%0\;mov.d [%r1--],%t0\";
        } else {
          return \"mov.d [%r1++],%0\;mov.d [%r1--],%t0\;sub %r1,#8,%r1\";
        }
      }
    case 6: /* < = r */
      return \"mov.d %t1,%0\;mov.d %1,%0\";
    case 7: /* TU = r */
      return \"mov %1,%0\;\"
             \"mov %d1,%Q0\;\"
             \"mov %t1,%R0\;\"
             \"mov %q1,%S0\";
    case 8: /* r = T */
      if (pic30_psrd_psrd_errata_movd(operands[1],NULL)) {
        /* nops not needed, we know that there is no precondition */
        return \"mov %1,%0\;\"
               \"mov %Q1,%d0\;\"
               \"mov %R1,%t0\;\"
               \"mov %S1,%q0\";
      } else if (pic30_psrd_psrd_errata(operands[1],NULL)) {
        pic30_rtx_nops++;
        return \"mov %1,%0\;\"
               \"nop\;\"
               \"mov %Q1,%d0\;\"
               \"nop\;\"
               \"mov %R1,%t0\;\"
               \"nop\;\"
               \"mov %S1,%q0\";
      } else {
        return \"mov %1,%0\;\"
               \"mov %Q1,%d0\;\"
               \"mov %R1,%t0\;\"
               \"mov %S1,%q0\";
      }
    case 9: /* r = U */
      return \"mov %1,%0\;\"
             \"mov %Q1,%d0\;\"
             \"mov %R1,%t0\;\"
             \"mov %S1,%q0\";
    case 10: /* r = Q */
      idDst = REGNO(operands[0]);
      idSrc = REGNO(XEXP(XEXP(operands[1],0),0));
      strcpy(temp, \"mov %1,%0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      strcpy(temp, \"mov %Q1,%d0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      strcpy(temp, \"mov %R1,%t0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      strcpy(temp, \"mov %S1,%q0\;\");
      if (idDst != idSrc)
        strcat(szInsn, temp);
      else
        strcat(save, temp);
      idDst++;
      if (save[0]) {
        save[strlen(save)-2] = 0;
        strcat(szInsn, save);
      }
      return szInsn;
    case 11: /* Q = r */
      return \"mov %1,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\";


    default: gcc_assert(0);
  }
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type"
             "def,use,use,use,use,use,use,etc,etc,etc,use,use")
;             "def,defuse,defuse,use,use,defuse,use,etc,def,def,defuse,use")
   (set_attr "op_type" "mov")
  ]
)

(define_expand "mov<mode>_16"
  [(set (match_operand:GM64BIT 0 "pic30_general_operand" "")
        (match_operand:GM64BIT 1 "pic30_general_operand" ""))]
  "(!pic30_isa32_target())"
  "
{
   if (pic30_emit_move_sequence(operands, <MODE>mode)) DONE;
   if (pic30_movedi_operand(operands[0],<MODE>mode) &&
       pic30_movedi_operand(operands[1],<MODE>mode)) {
     emit(
       gen_mov<mode>_gen_16(operands[0],operands[1])
     );
     DONE;
   }
}")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Single Float (32 bit) moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Invalid move

(define_insn "*movsf_invalid_1_16"
  [(set (match_operand:SF 0 "pic30_register_operand"  "=r")
        (match_operand:SF 1 "pic30_code_operand" "g"))]
  "(!pic30_isa32_target())"
  "*
{
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
}

")
(define_insn "*movsf_invalid_2_16"
  [(set (match_operand:SF 0 "pic30_code_operand" "=g")
        (match_operand:SF 1 "pic30_register_operand"    "r"))]
  "(!pic30_isa32_target())"
  "*
{
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
}
")


(define_insn "*movsf_rimm_16"
  [(set (match_operand:SF 0 "pic30_register_operand" "=r,r")
        (match_operand:SF 1 "immediate_operand" "G,i"))]
  "(!pic30_isa32_target())"
  "*
{
     switch (which_alternative) {
	case 0:
		return \"mul.uu %0,#0,%0\;\";
	default:
		return \"mov #%x1,%0\;mov #%w1,%d0\";
	}
}"
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "movlit")
  ]
)

(define_insn "*movsf_constnsfr_16"
  [(set (match_operand:SF 0 "pic30_near_operand" "=U,U")
        (match_operand:SF 1 "immediate_operand"   "G,i"))
	(clobber (match_scratch:HI 2             "=X,r"))]
  "(!pic30_isa32_target())"
  "*
   {
     REAL_VALUE_TYPE r;
     long l = 0;

     switch (which_alternative) {
       case 0:
         return \"clr %0\;clr %0+2\";
       default:
         r = *CONST_DOUBLE_REAL_VALUE(operands[1]);
         REAL_VALUE_TO_TARGET_SINGLE(r, l);
         if ((l & 0xFFFF) == 0) {
           return \"clr %0\;\"
                  \"mov #%w1,%2\;\"
                  \"mov %2,%0+2\";
         } else {
           return \"mov #%x1,%2\;\"
                  \"mov %2,%0\;\"
                  \"mov #%w1,%2\;\"
                  \"mov %2,%0+2\";
         }
     }
   }"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc")
    (set_attr "op_type" "mov")
  ]
)

(define_expand "movsf_16"
  [(set (match_operand:SF 0 "pic30_general_operand" "")
        (match_operand:SF 1 "pic30_general_operand" ""))
  ]
  "(!pic30_isa32_target())"
  "
   {
     if (pic30_emit_move_sequence(operands, SFmode)) DONE;
     if (pic30_move_operand(operands[0], SFmode) &&
         pic30_move_operand(operands[1], SFmode)) {
       emit(
         gen_movsf_gen_16(operands[0],operands[1])
       );
       DONE;
     }
   }"
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Double float (64 bit) moves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Invalid move

(define_insn "*movdf_invalid_1_16"
  [(set (match_operand:DF 0 "pic30_register_operand"  "=r")
        (match_operand:DF 1 "pic30_code_operand" "g"))]
  "(!pic30_isa32_target())"
  "*
   {
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
   }"
)

(define_insn "*movdf_invalid_2_16"
  [(set (match_operand:DF 0 "pic30_code_operand" "=g")
        (match_operand:DF 1 "pic30_register_operand"    "r"))]
  "(!pic30_isa32_target())"
  "*
   {
        error(\"invalid address space for operand\");
        return \"cannot generate instructions\";
   }"
)


(define_insn "*movdf_rimm_16"
  [(set (match_operand:DF 0 "pic30_register_operand" "=r,r")
        (match_operand:DF 1 "immediate_operand" "G,i"))]
  "(!pic30_isa32_target())"
  "*
   {
      REAL_VALUE_TYPE r;
      long l[4] = { 0 };

      switch (which_alternative) {
        case 0:
          return \"mul.uu %0,#0,%0\;\"
                 \"mul.uu %t0,#0,%t0\";
        default:
          r = *CONST_DOUBLE_REAL_VALUE(operands[1]);
          REAL_VALUE_TO_TARGET_DOUBLE(r, l);
          if (l[0] == 0) {
            return \"mul.uu %0,#0,%0\;\"
                   \"mov #%x1,%t0\;\"
                   \"mov #%w1,%q0\";
          } else {
            return \"mov #%z1,%0\;\"
                   \"mov #%y1,%d0\;\"
                   \"mov #%x1,%t0\;\"
                   \"mov #%w1,%q0\";
          }
      }
   }"
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "mov")
  ]
)

; can no longer split because of clobbers
(define_insn "movdf_rr_16"
  [(set (match_operand:DF 0 "pic30_register_operand" "=r")
        (match_operand:DF 1 "pic30_register_operand" " r"))]
  "(!pic30_isa32_target())"
  "mov.d %1,%0\;mov.d %t1,%t0"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

;; pointer conversions
;;

(define_insn "mov<mode>p32eds_16"
  [
   (set (match_operand:P32EDS  0 "pic30_register_operand" "=r,r")
        (unspec: P32EDS
          [
            (match_operand:TBLMODE 1 "pic30_register_operand" " 0,r") 
          ] UNSPECV_PSVCONVERT))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   btsts.c %0,#15\;rlc %d0,%d0
   mov %1,%0\;btsts.c %1,#15\;rlc %d1,%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mov<mode>p32peds_16"
  [
   (set (match_operand:P32PEDS 0 "pic30_register_operand" "=r,r")
        (unspec: P32PEDS
          [
            (match_operand:TBLMODE 1 "pic30_register_operand" " 0,r") 
          ] UNSPECV_PSVCONVERT))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   btsts.c %0,#15\;rlc %d0,%d0
   mov.d %2,%0\;btsts.c %1,#15\;rlc %d1,%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; add instructions 
;;
;; During the instruction canonicalization phase,
;; (minus x (const_int n)) is converted to (plus x (const_int -n)).
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; quarter integer
;;;;;;;;;;;;;;;;;;

(define_insn "*addqi3_incdec_DATA_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=r<>,R,r<>,R")
        (plus:QI 
           (match_operand:QI 1 "pic30_math_operand" "r, r,R<>,R<>")
           (match_operand:QI 2 "immediate_operand" "i,  i,i,  i")))
   (clobber (reg:CC CC_REG))]
 "(-2<=INTVAL(operands[2]))&&(INTVAL(operands[2])!=0)&&(INTVAL(operands[2])<=2)"
  "*
{
	switch (INTVAL(operands[2]))
	{
	case -2:
		return \"dec2.b %1,%0\";
	case -1:
		return \"dec.b %1,%0\";
	case 1:
		return \"inc.b %1,%0\";
	case 2:
		return \"inc2.b %1,%0\";
	default:
		gcc_assert(0);
		return \"nop\";
	}
}"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "defuse,use,defuse,use")
   (set_attr "op_type" "alu")
  ]
)

;; There is a potential register class issue here, if we cannot claim WREG
;;   then this pattern will fail.  But allowing a general reg seems to have
;;;  a slight negative impact on one particular applicaton - leaving the
;;   option open for now.  CAW

(define_insn "*addqi3_incdecsfr_16"
  [(set (match_operand:QI 0 "pic30_wreg_or_near_operand"   "=U,a")
        (plus:QI (match_operand:QI 1 "pic30_near_operand"  "%0,U")
                 (match_operand:QI 2 "immediate_operand"   " i,i")))
   (clobber (reg:CC CC_REG))
  ]
 "(-2<=INTVAL(operands[2]))&&(INTVAL(operands[2])!=0)&&(INTVAL(operands[2])<=2)"
  "*
{
  switch (INTVAL(operands[2])) {
    case -2: switch (which_alternative) {
               case 0: return \"dec2.b %0\";
               case 1: return \"dec2.b %1,WREG\";
               /* r,U,i */
               case 2: return \"mov #%1,%0\;dec2.b [%0],%0\";
             }
    case -1: switch (which_alternative) {
               case 0: return \"dec.b %0\";
               case 1: return \"dec.b %1,WREG\";
               case 2: return \"mov #%1,%0\;dec.b [%0],%0\";
             }
    case 1: switch (which_alternative) {
               case 0: return \"inc.b %0\";
               case 1: return \"inc.b %1,WREG\";
               case 2: return \"mov #%1,%0\;inc.b [%0],%0\";
             }
    case 2: switch (which_alternative) {
               case 0: return \"inc2.b %0\";
               case 1: return \"inc2.b %1,WREG\";
               case 2: return \"mov #%1,%0\;inc2.b [%0],%0\";
             }
    default: gcc_assert(0);
             return \"nop\";
  }
}"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "etc,def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "addqi3_DATA_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R, r<>,R,r<>,R,r<>,R,  r<>,R,r<>,R,r,r")
        (plus:QI 
           (match_operand:QI 1 "pic30_math_operand"
              "%r,  r,  r,r, r,  r,r,  r,R<>,R<>,N,  N,P,  P,0,J")
           (match_operand:QI 2 "pic30_mode1JN_operand"
              "r,  R<>,r,R<>,N,  N,P,  P,r,  r,  r,  r,r,  r,J,0")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add.b %1,%2,%0
   add.b %1,%2,%0
   add.b %1,%2,%0
   add.b %1,%2,%0
   sub.b %1,#%J2,%0
   sub.b %1,#%J2,%0
   add.b %1,#%2,%0
   add.b %1,#%2,%0
   add.b %2,%1,%0
   add.b %2,%1,%0
   sub.b %2,#%J1,%0
   sub.b %2,#%J1,%0
   add.b %2,#%1,%0
   add.b %2,#%1,%0
   add.b #%2,%0
   add.b #%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "defuse,defuse,use,use,defuse,use,defuse,use,defuse,use,defuse,use,defuse,use,def,def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "addqi3_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
               "=r<>,r<>,R,R,  r<>,R,r<>,R,r<>,R,  r<>,R,r<>,R,r,r")
        (plus:QI 
           (match_operand:QI 1 "pic30_math_APSV_operand"
               "%r,  r,  r,r,  r,  r,r,  r,R<>,R<>,N,  N,P,  P,0,J")
           (match_operand:QI 2 "pic30_mode1JN_APSV_operand"
               "r,   R<>,r,R<>,N,  N,P,  P,r,  r,  r,  r,r,  r,J,0")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add.b %1,%2,%0
   add.b %1,%2,%0
   add.b %1,%2,%0
   add.b %1,%2,%0
   sub.b %1,#%J2,%0
   sub.b %1,#%J2,%0
   add.b %1,#%2,%0
   add.b %1,#%2,%0
   add.b %2,%1,%0
   add.b %2,%1,%0
   sub.b %2,#%J1,%0
   sub.b %2,#%J1,%0
   add.b %2,#%1,%0
   add.b %2,#%1,%0
   add.b #%2,%0
   add.b #%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use,def,use,def,use,defuse,use,def,use,def,use,def,def")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "addqi3_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
               "=r<>,r<>,R,R,  r<>,R,r<>,R,r<>,R,  r<>,R,r<>,R,r,r")
        (plus:QI
           (match_operand:QI 1 "pic30_math_APSV_operand"
               "%r,  r,  r,r,  r,  r,r,  r,R<>,R<>,N,  N,P,  P,0,J")
           (match_operand:QI 2 "pic30_mode1JN_APSV_operand"
               "r,  R<>,r,R<>,N,  N,P,  P,r,  r,  r,  r,r,  r,J,0")))]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_math_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_mode1JN_operand(operands[2],GET_MODE(operands[2])))
    emit(gen_addqi3_DATA_16(operands[0],operands[1],operands[2]));
  else
    emit(gen_addqi3_APSV_16(operands[0],operands[1],operands[2]));
  DONE;
}")

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*addqi3_sfr0_16"
  [(set (match_operand:QI 0 "pic30_near_operand"         "=U")
        (plus:QI (match_dup 0)
                 (match_operand:QI 1 "pic30_wreg_operand" "a")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add.b %0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*addqi3_sfr1_16"
  [(set (match_operand:QI 0 "pic30_near_operand"         "=U")
        (plus:QI (match_operand:QI 1 "pic30_wreg_operand" "a")
                 (match_dup 0)))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add.b %0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn_and_split "*addqi3_sfr2_16"
  [(set (match_operand:QI 0 "pic30_register_operand"            "=a ,a, d")
        (plus:QI (match_operand:QI 1 "pic30_near_operand"       "%U ,U, U")
                 (match_operand:QI 2 "pic30_register_operand"   " a ,d, d")))
   (clobber (match_scratch:HI 3                                 "=X ,X,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add.b %1,WREG
   mov.b %2,w0\;add.b %1,WREG
   mov #%1,%3\;add.b %2,[%3],%0"
  "reload_completed && (!pic30_isa32_target())"
  [
   (const_int 0)
  ]
"
{
  if (!pic30_wreg_operand(operands[0], QImode) &&
      !pic30_wreg_operand(operands[2], QImode))
  {
  	rtx pop = gen_rtx_MEM(QImode, operands[3]);
	emit_insn(gen_movhi_address_16(operands[3], XEXP(operands[1],0)));
	emit_insn(gen_addqi3_16(operands[0], operands[2], pop));
  	DONE;
  }
  else
  {
  	FAIL;
  }
}
"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;
;; half integer
;;;;;;;;;;;;;;;
(define_insn "add<mode>3_16"
  [(set (match_operand:A16BITADD 0 "pic30_mode2_operand"
              "=r<>,R,  r<>,R,r<>,r<>,R,R,  r<>,R,r<>,R,R,r<>,R,  r<>,r<>,R,r<>,R,r,r,r,  !?r,!?r")
        (plus:A16BITADD 
           (match_operand:A16BITADD 1 "pic30_JMmath_operand"
              "%r<>,r<>,R,  R,r,  r,  r,r,  r,  r,r,  r,r,r,  R<>,R<>,N,  N,P,  P,0,J,NPJ,JM, r")
           (match_operand:A16BITADD 2 "pic30_JMmath_operand"
              "L,   L,  L,  L,r,  R<>,r,R<>,N,  N,P,  P,r,r,  r,  r,  r,  r,r,  r,J,0,NPJ,r,  JM")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   switch (which_alternative) {
     case  0:
     case  1:
     case  2:
     case  3:
       switch (INTVAL(operands[2])) {
         case -2:  return \"dec2.w %1,%0\";
         case -1:  return \"dec.w %1,%0\";
         case 1:  return \"inc.w %1,%0\";
         case 2:  return \"inc2.w %1,%0\";
         default: error(\"unknown L value: addhi3\");
                  return \"bad adhhi3\";
       }
       break;
     case  4: return \"add.w %1,%2,%0\";
     case  5: return \"add.w %1,%2,%0\";
     case  6: return \"add.w %1,%2,%0\";
     case  7: return \"add.w %1,%2,%0\";
     case  8: return \"sub.w %1,#%J2,%0\";
     case  9: return \"sub.w %1,#%J2,%0\";
     case 10: return \"add.w %1,#%2,%0\";
     case 11: return \"add.w %1,#%2,%0\";
     case 12: return \"add.w %2,%1,%0\";
     case 13: return \"add.w %2,%1,%0\";
     case 14: return \"add.w %2,%1,%0\";
     case 15: return \"add.w %2,%1,%0\";
     case 16: return \"sub.w %2,#%J1,%0\";
     case 17: return \"sub.w %2,#%J1,%0\";
     case 18: return \"add.w %2,#%1,%0\";
     case 19: return \"add.w %2,#%1,%0\";
     case 20: return \"add.w #%2,%0\";
     case 21: return \"add.w #%1,%0\";
     case 22: return \"mov.w #(%1+%2),%0\";
     case 23: if (REGNO(operands[0]) != REGNO(operands[2]))
                return \"mov.w #%1,%0\;add.w %0,%2,%0\";
              else {
                if (INTVAL(operands[1]) < 0)
                  return \"sub.w #%J1,%0\";
                else 
                  return \"add.w #%1,%0\";
              }
     case 24: if (REGNO(operands[0]) != REGNO(operands[1])) 
                return \"mov.w #%2,%0\;add.w %0,%1,%0\";
              else {
                if (INTVAL(operands[2]) < 0)
                  return \"sub.w #%J2,%0\";
                else 
                  return \"add.w #%2,%0\";
              }
     default: gcc_assert(0);
              return \"bad addhi3\";
   }
}"
  [
   (set_attr "cc" "math")
   (set_attr "type" 
              "def,use,defuse,use,def,defuse,use,use,def,use,def,use,use,def,use,defuse,def,use,def,use,def,def,def,def,def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "addcmp<mode>3_16"
  [(set (reg:CC_NZC CC_REG)
        (compare:CC_NZC
          (plus:A16BITADD 
             (match_operand:A16BITADD 1 "pic30_JMmath_operand"
                "%r<>,r<>,R,  R,r,  r,  r,r,  r,  r,r,  r,r,r,  R<>,R<>,N,  N,P,  P,0,J,NPJ,JM, r")
             (match_operand:A16BITADD 2 "pic30_JMmath_operand"
                "L,   L,  L,  L,r,  R<>,r,R<>,N,  N,P,  P,r,r,  r,  r,  r,  r,r,  r,J,0,NPJ,r,  JM"))
          (const_int 0)))
   (set (match_operand:A16BITADD 0 "pic30_mode2_operand"
              "=r<>,R,  r<>,R,r<>,r<>,R,R,  r<>,R,r<>,R,R,r<>,R,  r<>,r<>,R,r<>,R,r,r,r,  !?r,!?r")
        (plus:A16BITADD 
           (match_dup 1) (match_dup 2))
   )
  ]
  "(!pic30_isa32_target())"
  "*
{
   switch (which_alternative) {
     case  0:
     case  1:
     case  2:
     case  3:
       switch (INTVAL(operands[2])) {
         case -2:  return \"dec2.w %1,%0\";
         case -1:  return \"dec.w %1,%0\";
         case 1:  return \"inc.w %1,%0\";
         case 2:  return \"inc2.w %1,%0\";
         default: error(\"unknown L value: addhi3\");
                  return \"bad adhhi3\";
       }
       break;
     case  4: return \"add.w %1,%2,%0\";
     case  5: return \"add.w %1,%2,%0\";
     case  6: return \"add.w %1,%2,%0\";
     case  7: return \"add.w %1,%2,%0\";
     case  8: return \"sub.w %1,#%J2,%0\";
     case  9: return \"sub.w %1,#%J2,%0\";
     case 10: return \"add.w %1,#%2,%0\";
     case 11: return \"add.w %1,#%2,%0\";
     case 12: return \"add.w %2,%1,%0\";
     case 13: return \"add.w %2,%1,%0\";
     case 14: return \"add.w %2,%1,%0\";
     case 15: return \"add.w %2,%1,%0\";
     case 16: return \"sub.w %2,#%J1,%0\";
     case 17: return \"sub.w %2,#%J1,%0\";
     case 18: return \"add.w %2,#%1,%0\";
     case 19: return \"add.w %2,#%1,%0\";
     case 20: return \"add.w #%2,%0\";
     case 21: return \"add.w #%1,%0\";
     case 22: return \"mov.w #(%1+%2),%0\";
     case 23: if (REGNO(operands[0]) != REGNO(operands[2]))
                return \"mov.w #%1,%0\;add.w %0,%2,%0\";
              else {
                if (INTVAL(operands[1]) < 0)
                  return \"sub.w #%J1,%0\";
                else 
                  return \"add.w #%1,%0\";
              }
     case 24: if (REGNO(operands[0]) != REGNO(operands[1])) 
                return \"mov.w #%2,%0\;add.w %0,%1,%0\";
              else {
                if (INTVAL(operands[2]) < 0)
                  return \"sub.w #%J2,%0\";
                else 
                  return \"add.w #%2,%0\";
              }
     default: gcc_assert(0);
              return \"bad addhi3\";
   }
}"
  [
   (set_attr "cc" "math")
   (set_attr "type" 
              "def,use,defuse,use,def,defuse,use,use,def,use,def,use,use,def,use,defuse,def,use,def,use,def,def,def,def,def")
   (set_attr "op_type" "alu")
  ]
)

; this match_can cause issues iff operand 1 is dies in this instruction and
;   we decide to use it to reload operand 0 (CAW)
(define_insn "*addhi3_sfr0_16"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand"   "+U,r")
        (plus:HI (match_dup 0)
                 (match_operand:HI 1 "pic30_wreg_operand" "a,a")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add %0
   add %0,%1,%0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "etc,def")
    (set_attr "op_type" "alu")
  ]
)

; this match_can cause issues iff operand 1 is dies in this instruction and
;   we decide to use it to reload operand 0 (CAW)
(define_insn "*addhi3_sfr1_16"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand"   "+U,r")
        (plus:HI (match_operand:HI 1 "pic30_wreg_operand" "a,a")
                 (match_dup 0)))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add %0
   add %0,%1,%0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "etc,def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*addhi3_sfr2_16"
  [(set (match_operand:HI 0 "pic30_wreg_operand"          "=a")
        (plus:HI (match_operand:HI 1 "pic30_near_operand" "%U")
                 (match_operand:HI 2 "pic30_wreg_operand" " a")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add %1,WREG"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*addhi3_incdecsfr_16"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand"   "=U,a,d")
        (plus:HI (match_operand:HI 1 "pic30_near_operand" "%0,U,U")
                 (match_operand:HI 2 "immediate_operand"  " i,i,i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
 "(-2<=INTVAL(operands[2]))&&(INTVAL(operands[2])!=0)&&(INTVAL(operands[2])<=2)"
  "*
{
  switch (INTVAL(operands[2])) {
    case -2: switch (which_alternative) {
               case 0: return \"dec2 %0\";
               case 1: return \"dec2 %1,WREG\";
               case 2: return \"mov %1,%0\;dec2 %0,%0\";
               default: abort();
             }
    case -1: switch (which_alternative) {
               case 0: return \"dec %0\";
               case 1: return \"dec %1,WREG\";
               case 2: return \"mov %1,%0\;dec %0,%0\";
               default: abort();
             }
    case 1: switch (which_alternative) {
               case 0: return \"inc %0\";
               case 1: return \"inc %1,WREG\";
               case 2: return \"mov %1,%0\;inc %0,%0\";
               default: abort();
             }
    case 2: switch (which_alternative) {
               case 0: return \"inc2 %0\";
               case 1: return \"inc2 %1,WREG\";
               case 2: return \"mov %1,%0\;inc2 %0,%0\";
               default: abort();
             }
    default: gcc_assert(0);
  }
}"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "etc,def,def")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;
;; single integer
;;;;;;;;;;;;;;;;;

(define_insn "*addsihi3_16"
  [(set (match_operand:SI 0 "pic30_register_operand"      "=r")
        (plus:SI 
           (match_operand:SI 1 "pic30_register_operand"    "r")
           (zero_extend:SI 
              (match_operand:HI 2 "pic30_register_operand" "r"))))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add %1,%2,%0\;addc %d1,#0,%d0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

; any .w operation zero extends the result into the full register width

(define_insn "*addhisi3_ze_16"
  [(set (match_operand:SI 0 "pic30_mode2_operand"         "=r,>,>,R,R")
        (plus:SI 
           (zero_extend:SI 
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r,r"))
           (match_operand:SI 2 "pic30_mode2_operand"       "r,0,>,0,R")))
   (clobber (match_scratch:HI 3                           "=X,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add %1,%2,%0\;addc %d2,#0,%d0
   add %1,%s2,%0\;clr %3\;addc %3,%s2,%0
   add %1,%2,%0\;clr %3\;addc %3,%2,%0
   add %1,%2,%I0\;clr %3\;addc %3,%2,%D0
   add %1,%I2,%I0\;clr %3\;addc %3,%D2,%D0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*addhisi3_se_16"
  [(set (match_operand:SI 0 "pic30_mode2_operand"         "=r,>,>,R,R")
        (plus:SI
           (sign_extend:SI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r,r"))
           (match_operand:SI 2 "pic30_mode2_operand"       "r,0,>,0,R")))
   (clobber (match_scratch:HI 3                           "=&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   static const char *patterns[] = {
     \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%d2,%d0\",
     \"asr %1,#15,%3\;add %1,%s2,%0\;addc %3,%s2,%0\",
     \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%2,%0\",
     \"asr %1,#15,%3\;add %1,%2,%I0\;addc %3,%2,%D0\",
     \"asr %1,#15,%3\;add %1,%I2,%I0\;addc %3,%D2,%D0\"
   };

   static const char *psv_psv_patterns[] = {
     \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%d2,%d0\",
     \"asr %1,#15,%3\;add %1,%s2,%0\;addc %3,%s2,%0\",
     \"asr %1,#15,%3\;add %1,%2,%0\;nop\;addc %3,%2,%0\",
     \"asr %1,#15,%3\;add %1,%2,%I0\;addc %3,%2,%D0\",
     \"asr %1,#15,%3\;add %1,%I2,%I0\;nop\;addc %3,%D2,%D0\"
   };

   if (pic30_psrd_psrd_errata(NULL,operands[2])) {
     pic30_rtx_nops++;
    return psv_psv_patterns[which_alternative];
  } else {
    return patterns[which_alternative];
  }
 "
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*addsi3_imm_16"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r,r,r,r")
        (plus:SI (match_operand:SI 1 "pic30_register_operand" "%r,r,0,0")
                 (match_operand:SI 2 "pic30_JM_operand"       " P,N,J,M")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add %1,#%2,%0\;addc %d1,#0,%d0
   sub %1,#%J2,%0\;subb %d1,#0,%d0
   add #%2,%0\;addc #0,%d0
   sub #%J2,%0\;subb #0,%d0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*addsi3_immmsw_16"
  [(set (match_operand:SI          0 "pic30_register_operand" "=r,r")
        (plus:SI (match_operand:SI 1 "pic30_register_operand" "%0,r")
                 (match_operand:SI 2 "immediate_operand"      " i,i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((!pic30_isa32_target()) &&
    ((INTVAL(operands[2]) & 0x0000FFFF) == 0) && 
    (-31 < (INTVAL(operands[2]) >> 16)) && ((INTVAL(operands[2]) >> 16) < 31))"
  "*
{
  int i = INTVAL(operands[2]) >> 16;
  static char szInsn[48];
  switch (which_alternative)
  {
    default: gcc_assert(0);
    case 0:
      if (i < 0) sprintf(szInsn, \"sub %%d1,#%d,%%d0\", -i);
      else sprintf(szInsn, \"add %%d1,#%d,%%d0\", i);
      break;
    case 1:
      if (i < 0) sprintf(szInsn, \"sub %%1,#0,%%0\;subb %%d1,#%d,%%d0\",-i);
      else sprintf(szInsn, \"add %%1,#0,%%0\;addc %%d1,#%d,%%d0\", i);
      break;
  }
  return szInsn;
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "addsi3_errata_APSV_16"
 [(set (match_operand:SI 0 "pic30_rR_or_near_operand"        "=r,r,r,&r,r,r,r,r,R,R,R")
       (plus:SI 
         (match_operand:SI 1 "pic30_rR_or_near_APSV_operand" "%r,0,r, R,r,r,0,0,r,r,r")
         (match_operand:SI 2 "pic30_rR_or_JMNP_APSV_operand"  "r,r,0, r,P,N,J,M,r,0,R")
  ))
  (clobber (match_scratch:HI 3                               "=X,X,X,&r,X,X,X,X,X,X,&r")
  )
  (clobber (reg:CC_NZC CC_REG))
 ]
  "(!pic30_isa32_target()) && (pic30_errata_mask & psv_errata)"
  "*
{
  static const char *patterns[] = {
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%I1,%0\;mov %D1,%3\;addc %d2,%3,%d0\",
    \"add %1,#%2,%0\;addc %d1,#0,%d0\",
    \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
    \"add #%2,%0\;addc #%y2,%d0\",
    \"sub #%J2,%0\;subb #0,%d0\",
    \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
    \"add %1,%2,%0\;addc %d1,%P2,%D0\",
    \"add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\",
    0};

  static const char *psv_psv_patterns[] = {
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%I1,%0\;nop\;mov %D1,%3\;addc %d2,%3,%d0\",
    \"add %1,#%2,%0\;addc %d1,#0,%d0\",
    \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
    \"add #%2,%0\;addc #%y2,%d0\",
    \"sub #%J2,%0\;subb #0,%d0\",
    \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
    \"add %1,%2,%0\;addc %d1,%P2,%D0\",
    \"add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\",
    0};

  if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
    pic30_rtx_nops++;
    return psv_psv_patterns[which_alternative];
  } else {
    return patterns[which_alternative];
  }
}"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math,math") ; CAW
    (set_attr "type" "def,def,def,defuse,def,def,def,def,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addsi3_DATA_16"
 [(set (match_operand:SI   0 "pic30_rR_or_near_operand" "=r,r,r,&r,r,r,r,r,R,R,R")
       (plus:SI  
         (match_operand:SI 1 "pic30_rR_or_near_operand" "%r,0,r, R,r,r,0,0,r,r,r")
         (match_operand:SI 2 "pic30_rR_or_JMNP_operand"  "r,r,0, r,P,N,J,M,r,0,R")  ))
  (clobber (reg:CC_NZC CC_REG))
 ]
  "(!pic30_isa32_target())"
  "*
{
  static const char *patterns[] = {
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%I1,%0\;addc %d2,%D1,%d0\",
    \"add %1,#%2,%0\;addc %d1,#0,%d0\",
    \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
    \"add #%2,%0\;addc #%y2,%d0\",
    \"sub #%J2,%0\;subb #0,%d0\",
    \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
    \"add %1,%2,%0\;addc %d1,%P2,%D0\",
    \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
    0};

  static const char *psv_psv_patterns[] = {
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%I1,%0\;nop\;addc %d2,%D1,%d0\",
    \"add %1,#%2,%0\;addc %d1,#0,%d0\",
    \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
    \"add #%2,%0\;addc #%y2,%d0\",
    \"sub #%J2,%0\;subb #0,%d0\",
    \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
    \"add %1,%2,%0\;addc %d1,%P2,%D0\",
    \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
    0};

  if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
    pic30_rtx_nops++;
    return psv_psv_patterns[which_alternative];
  } else {
    return patterns[which_alternative];
  }
}"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math,math") ; CAW
    (set_attr "type" "def,def,def,defuse,def,def,def,def,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addsi3_noerrata_APSV_16"
 [(set (match_operand:SI   0 "pic30_rR_or_near_operand"      "=r,r,r,&r,r,r,r,r,R,R,R")
       (plus:SI  
         (match_operand:SI 1 "pic30_rR_or_near_APSV_operand" "%r,0,r, R,r,r,0,0,r,r,r")
         (match_operand:SI 2 "pic30_rR_or_JMNP_APSV_operand"  "r,r,0, r,P,N,J,M,r,0,R")  ))
  (clobber (reg:CC_NZC CC_REG))
 ]
  "(!pic30_isa32_target()) && (!(pic30_errata_mask & psv_errata))"
  "*
{
  static const char *patterns[] = {
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%I1,%0\;addc %d2,%D1,%d0\",
    \"add %1,#%2,%0\;addc %d1,#0,%d0\",
    \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
    \"add #%2,%0\;addc #%y2,%d0\",
    \"sub #%J2,%0\;subb #%0,%d0\",
    \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
    \"add %1,%2,%0\;addc %d1,%P2,%D0\",
    \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
    0};

  static const char *psv_psv_patterns[] = {
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%1,%0\;addc %d2,%d1,%d0\",
    \"add %2,%I1,%0\;nop\;addc %d2,%D1,%d0\",
    \"add %1,#%2,%0\;addc %d1,#0,%d0\",
    \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
    \"add #%2,%0\;addc #%y2,%d0\",
    \"sub #%J2,%0\;subb #%0,%d0\",
    \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
    \"add %1,%2,%0\;addc %d1,%P2,%D0\",
    \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
    0};

  if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
    pic30_rtx_nops++;
    return psv_psv_patterns[which_alternative];
  } else {
    return patterns[which_alternative];
  }
}"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math,math") ; CAW
    (set_attr "type" "def,def,def,defuse,def,def,def,def,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_expand "addsi3_16"
  [(set (match_operand:SI 0 "pic30_rR_or_near_operand" "")
        (plus:SI
          (match_operand:SI 1 "pic30_rR_or_near_APSV_operand" "")
          (match_operand:SI 2 "pic30_rR_or_JMNP_APSV_operand" "")))]
  "(!pic30_isa32_target())"
  "
{ 
  if (pic30_rR_or_near_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_rR_or_JMNP_operand(operands[2],GET_MODE(operands[2]))) {
    emit_insn(
      gen_addsi3_DATA_16(operands[0], operands[1], operands[2])
    );
  } else if (pic30_rR_or_near_APSV_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_rR_or_JMNP_APSV_operand(operands[2],GET_MODE(operands[2]))) {
    if (pic30_errata_mask & psv_errata) {
      emit_insn(
        gen_addsi3_errata_APSV_16(operands[0], operands[1], operands[2])
      );
    } else {
      emit_insn(
        gen_addsi3_noerrata_APSV_16(operands[0],operands[1], operands[2])
      );
    }
  } else {
    rtx reg1 = operands[1];
    rtx reg2 = operands[2];

    if (!pic30_register_operand(reg1,GET_MODE(reg1)))
      reg1 = force_reg(GET_MODE(reg1), reg1);
    if (!pic30_mode2mres_operand(reg2,GET_MODE(reg2)))
      reg2 = force_reg(GET_MODE(reg2), reg2);
    emit(
      gen_addsi3x_DATA_16(operands[0], reg1, reg2)
    );
  }
  DONE;
}")

(define_insn "addsi3x_DATA_16"
  [(set (match_operand:SI   0 "pic30_mode2mres_operand" "=r,&r,&r,R,R,R,>,>,>")
        (plus:SI 
          (match_operand:SI 1 "pic30_register_operand"  "%r, r, r,r,r,r,r,r,r")
          (match_operand:SI 2 "pic30_mode2mres_operand" " r, R, >,r,R,>,r,R,>"))
   )
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
        \"add %1,%2,%0\;addc %d1,%2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %1,%2,%I0\;addc %d1,%2,%D0\",
        \"add %1,%2,%0\;addc %d1,%d2,%0\",
        \"add %1,%I2,%0\;addc %d1,%D2,%0\",
        \"add %1,%2,%0\;addc %d1,%2,%0\",
        0};

     static const char *psv_psv_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
        \"add %1,%2,%0\;nop\;addc %d1,%2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %1,%2,%I0\;nop\;addc %d1,%2,%D0\",
        \"add %1,%2,%0\;addc %d1,%d2,%0\",
        \"add %1,%I2,%0\;nop\;addc %d1,%D2,%0\",
        \"add %1,%2,%0\;nop\;addc %d1,%2,%0\",
        0};

     static const char *pre_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
        \"add %r2,#4,%r2\;add %1,%I2,%0\;addc %d1,%D2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %r2,#4,%r2\;add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %r0,#4,%r0\;add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %1,%2,%0\;addc %d1,%2,%0\",  // alternative 8 not possible to use
        0};

     static const char *psv_psv_pre_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
        \"add %r2,#4,%r2\;add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %r2,#4,%r2\;add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %r0,#4,%r0\;add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %1,%2,%0\;addc %d1,%2,%0\",  // alternative 8 not possible to use
        0};

    if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
      pic30_rtx_nops++;
      if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
        return \"add %r0,#4,%r0\;\"
               \"add %r2,#4,%r2\;\"
               \"add %1,%I2,%I0\;\"
               \"nop\;\"
               \"addc %d1,%D2,%D0\";
      } else if (which_alternative == 8) {
        if (pic30_pre_modify(operands[0])) {
          return \"add %r0,#4,%r0\;\"
                 \"add %1,%2,%I0\;\"
                 \"nop\;\"
                 \"addc %d1,%2,%D0\";
        } if (pic30_pre_modify(operands[2])) {
          return \"add %r2,#4,%r2\;\"
                 \"add %1,%I2,%0\;\"
                 \"nop\;\"
                 \"addc %d1,%D2,%0\";
        }
      } else if (pic30_pre_modify(operands[0]) || 
                 pic30_pre_modify(operands[2])) {
        return psv_psv_pre_patterns[which_alternative];
      } 
      return psv_psv_patterns[which_alternative];
    } else {
      if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
        return \"add %r0,#4,%r0\;\"
               \"add %r2,#4,%r2\;\"
               \"add %1,%I2,%I0\;\"
               \"addc %d1,%D2,%D0\";
      } else if (which_alternative == 8) {
        if (pic30_pre_modify(operands[0])) {
          return \"add %r0,#4,%r0\;\"
                 \"add %1,%2,%I0\;\"
                 \"addc %d1,%2,%D0\";
        } if (pic30_pre_modify(operands[2])) {
          return \"add %r2,#4,%r2\;\"
                 \"add %1,%I2,%0\;\"
                 \"addc %d1,%D2,%0\";
        }
      } else if (pic30_pre_modify(operands[0]) || 
		 pic30_pre_modify(operands[2])) {
        return pre_patterns[which_alternative];
      } 
      return patterns[which_alternative];
    }
  }"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addsi3x_noerrata_APSV_16"
  [(set (match_operand:SI   0 "pic30_mode2mres_operand"     "=r,&r,&r,R,R,R,>,>,>")
        (plus:SI 
          (match_operand:SI 1 "pic30_register_operand"      "%r, r, r,r,r,r,r,r,r")
          (match_operand:SI 2 "pic30_mode2mres_APSV_operand" "r, R, >,r,R,>,r,R,>")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!(pic30_errata_mask & psv_errata)) && (!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
        \"add %1,%2,%0\;addc %d1,%2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %1,%2,%I0\;addc %d1,%2,%D0\",
        \"add %1,%2,%0\;addc %d1,%d2,%0\",
        \"add %1,%I2,%0\;addc %d1,%D2,%0\",
        \"add %1,%2,%0\;addc %d1,%2,%0\",
        0};

     static const char *psv_psv_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
        \"add %1,%2,%0\;nop\;addc %d1,%2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %1,%2,%I0\;nop\;addc %d1,%2,%D0\",
        \"add %1,%2,%0\;addc %d1,%d2,%0\",
        \"add %1,%I2,%0\;nop\;addc %d1,%D2,%0\",
        \"add %1,%2,%0\;nop\;addc %d1,%2,%0\",
        0};

     static const char *pre_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
        \"add %r2,#4,%r2\;add %1,%I2,%0\;addc %d1,%D2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %r2,#4,%r2\;add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %r0,#4,%r0\;add %1,%I2,%I0\;addc %d1,%D2,%D0\",
        \"add %1,%2,%0\;addc %d1,%2,%0\",  // alternative 8 not possible to use
        0};

     static const char *psv_psv_pre_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
        \"add %r2,#4,%r2\;add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %r2,#4,%r2\;add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %r0,#4,%r0\;add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
        \"add %1,%2,%0\;addc %d1,%2,%0\",  // alternative 8 not possible to use
        0};

    if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
      pic30_rtx_nops++;
      if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
        return \"add %r0,#4,%r0\;\"
               \"add %r2,#4,%r2\;\"
               \"add %1,%I2,%I0\;\"
               \"nop\;\"
               \"addc %d1,%D2,%D0\";
      } else if (which_alternative == 8) {
        if (pic30_pre_modify(operands[0])) {
          return \"add %r0,#4,%r0\;\"
                 \"add %1,%2,%I0\;\"
                 \"nop\;\"
                 \"addc %d1,%2,%D0\";
        } if (pic30_pre_modify(operands[2])) {
          return \"add %r2,#4,%r2\;\"
                 \"add %1,%I2,%0\;\"
                 \"nop\;\"
                 \"addc %d1,%D2,%0\";
        }
      } else if (pic30_pre_modify(operands[0]) || 
                 pic30_pre_modify(operands[2])) {
        return psv_psv_pre_patterns[which_alternative];
      } 
      return psv_psv_patterns[which_alternative];
    } else {
      if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
        return \"add %r0,#4,%r0\;\"
               \"add %r2,#4,%r2\;\"
               \"add %1,%I2,%I0\;\"
               \"addc %d1,%D2,%D0\";
      } else if (which_alternative == 8) {
        if (pic30_pre_modify(operands[0])) {
          return \"add %r0,#4,%r0\;\"
                 \"add %1,%2,%I0\;\"
                 \"addc %d1,%2,%D0\";
        } if (pic30_pre_modify(operands[2])) {
          return \"add %r2,#4,%r2\;\"
                 \"add %1,%I2,%0\;\"
                 \"addc %d1,%D2,%0\";
        }
      } else if (pic30_pre_modify(operands[0]) || 
		 pic30_pre_modify(operands[2])) {
        return pre_patterns[which_alternative];
      } 
      return patterns[which_alternative];
    }
  }"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addsi3x_errata_APSV_16"
  [(set 
    (match_operand:SI   0 "pic30_mode2mres_operand"      "=r,&r,&r,R,R,R,>,>,>")
    (plus:SI 
      (match_operand:SI 1 "pic30_register_operand"       "%r, r, r,r,r,r,r,r,r")
      (match_operand:SI 2 "pic30_mode2mres_APSV_operand" " r, R, >,r,R,>,r,R,>")
    )
   )
   (clobber (match_scratch:HI 3                     "=X,&r,&r,X,&r,&r,X,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(pic30_errata_mask & psv_errata) && (!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;mov %D2,%3\;addc %d1,%3,%d0\",
        \"add %1,%2,%0\;mov %2,%3\;addc %d1,%3,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %1,%2,%I0\;mov %2,%3\;addc %d1,%3,%D0\",
        \"add %1,%2,%0\;addc %d1,%d2,%0\",
        \"add %1,%I2,%0\;mov %D2,%3\;addc %d1,%3,%0\",
        \"add %1,%2,%0\;mov %2,%3\;addc %d1,%3,%0\",
        0};

     static const char *psv_psv_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;nop\;mov %D2,%3\;addc %d1,%3,%d0\",
        \"add %1,%2,%0\;nop\;mov %2,%3\;addc %d1,%3,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %1,%2,%I0\;nop\;mov %2,%3\;addc %d1,%3,%D0\",
        \"add %1,%2,%0\;addc %d1,%d2,%0\",
        \"add %1,%I2,%0\;nop\;mov %D2,%3\;addc %d1,%3,%0\",
        \"add %1,%2,%0\;nop\;mov %2,%3\;addc %d1,%3,%0\",
        0};

     static const char *pre_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;mov %D2,%3\;addc %d1,%3,%d0\",
        \"add %r2,#4,%r2\;add %1,%I2,%0\;mov %D2,%3\;addc %d1,%3,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %r2,#4,%r2\;add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %r0,#4,%r0\;add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %1,%2,%0\;mov %2,%3\;addc %d1,%3,%0\", // alternative 8 not possible to use
        0};

     static const char *psv_psv_pre_patterns[] = {
        \"add %1,%2,%0\;addc %d1,%d2,%d0\",
        \"add %1,%I2,%0\;nop\;mov %D2,%3\;addc %d1,%3,%d0\",
        \"add %r2,#4,%r2\;add %1,%I2,%0\;nop\;mov %D2,%3\;addc %d1,%3,%d0\",
        \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %r2,#4,%r2\;add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%d2,%D0\",
        \"add %r0,#4,%r0\;add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\",
        \"add %1,%2,%0\;mov %2,%3\;addc %d1,%3,%0\", // alternative 8 not possible to use
        0};

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
         return \"add %r0,#4,%r0\;\"
                \"add %r2,#4,%r2\;\"
                \"add %1,%I2,%I0\;\"
                \"nop\;\"
                \"mov %D2,%3\;\"
                \"addc %d1,%3,%D0\";
       } else if (which_alternative == 8) {
         if (pic30_pre_modify(operands[0])) {
           return \"add %r0,#4,%r0\;\"
                  \"add %1,%2,%I0\;\"
                  \"mov %2,%3\;\"
                  \"addc %d1,%3,%D0\";
         } else if (pic30_pre_modify(operands[2])) {
           return \"add %r2,#4,%r2\;\"
                  \"add %1,%I2,%0\;\"
                  \"mov %D2,%3\;\"
                  \"addc %d1,%3,%0\";
         }
       } else if (pic30_pre_modify(operands[0]) || 
                  pic30_pre_modify(operands[2])) {
         return psv_psv_pre_patterns[which_alternative];
       } 
       return psv_psv_patterns[which_alternative];
     } else {
       if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
         return \"add %r0,#4,%r0\;\"
                \"add %r2,#4,%r2\;\"
                \"add %1,%I2,%I0\;\"
                \"mov %D2,%3\;\"
                \"addc %d1,%3,%D0\";
       } else if (which_alternative == 8) {
         if (pic30_pre_modify(operands[0])) {
           return \"add %r0,#4,%r0\;\"
                  \"add %1,%2,%I0\;\"
                  \"mov %2,%3\;\"
                  \"addc %d1,%3,%D0\";
         } else if (pic30_pre_modify(operands[2])) {
           return \"add %r2,#4,%r2\;\"
                  \"add %1,%I2,%0\;\"
                  \"mov %D2,%3\;\"
                  \"addc %d1,%3,%0\";
         }
       } else if (pic30_pre_modify(operands[0]) || 
                  pic30_pre_modify(operands[2])) {
         return pre_patterns[which_alternative];
       } 
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;
;; P32DF integer
;;;;;;;;;;;;;;;;;

(define_insn "*addp32dfhi3_16"
  [(set (match_operand:P32DF    0 "pic30_register_operand" "=r")
        (plus:P32DF 
           (match_operand:P32DF 1 "pic30_register_operand"  "r")
           (zero_extend:P32DF 
              (match_operand:HI 2 "pic30_register_operand"  "r"))))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add %1,%2,%0\;addc %d1,#0,%d0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*addhip32df3_16"
  [(set (match_operand:P32DF    0 "pic30_register_operand" "=r")
        (plus:P32DF 
           (zero_extend:P32DF 
              (match_operand:HI 1 "pic30_register_operand"  "r"))
           (match_operand:P32DF 2 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add %2,%1,%0\;addc %d2,#0,%d0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*addp32df3_imm_16"
  [(set (match_operand:P32DF 0 "pic30_register_operand"          "=r,r,r,r")
        (plus:P32DF (match_operand:SI 1 "pic30_register_operand" "%r,r,0,0")
                 (match_operand:P32DF 2 "pic30_JM_operand"       " P,N,J,M")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add %1,#%2,%0\;addc %d1,#0,%d0
   sub %1,#%J2,%0\;subb %d1,#0,%d0
   add #%2,%0\;addc #0,%d0
   sub %0,#%J2\;subb %d0,#0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*addp32df3_immmsw_16"
  [(set (match_operand:P32DF          0 "pic30_register_operand" "=r,r")
        (plus:P32DF (match_operand:SI 1 "pic30_register_operand" "%0,r")
                 (match_operand:P32DF 2 "immediate_operand"      " i,i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && 
   ((INTVAL(operands[2]) & 0x0000FFFF) == 0) && 
   (-31 < (INTVAL(operands[2]) >> 16)) && ((INTVAL(operands[2]) >> 16) < 31)"
  "*
   {
     int i = INTVAL(operands[2]) >> 16;
     static char szInsn[48];
     switch (which_alternative)
     {
       default: gcc_assert(0);
       case 0:
         if (i < 0) sprintf(szInsn, \"sub %%d1,#%d,%%d0\", -i);
         else sprintf(szInsn, \"add %%d1,#%d,%%d0\", i);
         break;
       case 1:
         if (i < 0) sprintf(szInsn, \"sub %%1,#0,%%0\;subb %%d1,#%d,%%d0\",-i);
         else sprintf(szInsn, \"add %%1,#0,%%0\;addc %%d1,#%d,%%d0\", i);
         break;
     }
     return szInsn;
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "addp32df3_errata_APSV_16"
 [(set (match_operand:P32DF 0 "pic30_rR_or_near_operand"        "=r,r,r,&r,r,r,r,R,R,R")
       (plus:P32DF 
         (match_operand:P32DF 1 "pic30_rR_or_near_APSV_operand" "%r,0,r, R,r,r,0,r,r,r")
         (match_operand:P32DF 2 "pic30_rR_or_JN_APSV_operand"    "r,r,0, r,P,N,J,r,0,R")
  ))
  (clobber (match_scratch:HI 3                         "=X,X,X,&r,X,X,X,X,X,&r")
  )
  (clobber (reg:CC_NZC CC_REG))
 ]
  "(!pic30_isa32_target()) && (pic30_errata_mask & psv_errata)"
  "*
   {
     static const char *patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;mov %D1,%3\;addc %d2,%3,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;nop\;mov %D1,%3\;addc %d2,%3,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
  }"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addp32df3_DATA_16"
 [(set (match_operand:P32DF   0 "pic30_rR_or_near_operand" "=r,r,r,&r,r,r,r,R,R,R")
       (plus:P32DF  
         (match_operand:P32DF 1 "pic30_rR_or_near_operand" "%r,0,r, R,r,r,0,r,r,r")
         (match_operand:P32DF 2 "pic30_rR_or_JN_operand"    "r,r,0, r,P,N,J,r,0,R")  ))
  (clobber (reg:CC_NZC CC_REG))
 ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;nop\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addp32df3_noerrata_APSV_16"
 [(set (match_operand:P32DF   0 "pic30_rR_or_near_operand"      "=r,r,r,&r,r,r,r,R,R,R")
       (plus:P32DF  
         (match_operand:P32DF 1 "pic30_rR_or_near_APSV_operand" "%r,0,r, R,r,r,0,r,r,r")
         (match_operand:P32DF 2 "pic30_rR_or_JN_APSV_operand"    "r,r,0, r,P,N,J,r,0,R")  ))
  (clobber (reg:CC_NZC CC_REG))
 ]
  "(!pic30_isa32_target()) && (!(pic30_errata_mask & psv_errata))"
  "*
   {
     static const char *patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;nop\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_expand "addp32df3_16"
  [(set (match_operand:P32DF 0 "pic30_rR_or_near_operand" "")
        (plus:P32DF
          (match_operand:P32DF 1 "pic30_rR_or_near_APSV_operand" "")
          (match_operand:P32DF 2 "pic30_rR_or_JN_APSV_operand" "")))]
  "(!pic30_isa32_target())"
  "
{ 
  if (pic30_rR_or_near_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_rR_or_JN_APSV_operand(operands[2],GET_MODE(operands[2]))) {
    emit_insn(
      gen_addp32df3_DATA_16(operands[0], operands[1], operands[2])
    );
  } else if (pic30_errata_mask & psv_errata) {
    emit_insn(
      gen_addp32df3_errata_APSV_16(operands[0], operands[1], operands[2])
    );
  } else {
    emit_insn(
      gen_addp32df3_noerrata_APSV_16(operands[0], operands[1], operands[2])
    );
  }
  DONE;
}")

(define_insn "addp32df3x_DATA_16"
  [(set (match_operand:P32DF   0 "pic30_mode2mres_operand" "=r,&r,&r,R,R,R,>,>,>")
        (plus:P32DF 
          (match_operand:P32DF 1 "pic30_register_operand"  "%r, r, r,r,r,r,r,r,r")
          (match_operand:P32DF 2 "pic30_mode2mres_operand" " r, R, >,r,R,>,r,R,>")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%d2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
       \"add %1,%2,%I0\;nop\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%d2,%d0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addp32df3x_noerrata_APSV_16"
  [(set (match_operand:P32DF   0 "pic30_mode2mres_operand"     "=r,&r,&r,R,R,R,>,>,>")
        (plus:P32DF 
          (match_operand:P32DF 1 "pic30_register_operand"      "%r, r, r,r,r,r,r,r,r")
          (match_operand:P32DF 2 "pic30_mode2mres_APSV_operand" "r, R, >,r,R,>,r,R,>")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && (!(pic30_errata_mask & psv_errata))"
  "*
   {
     static const char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%d2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\",
       \"add %1,%2,%I0\;nop\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;nop\;addc %d1,%D2,%d0\",
       \"add %1,%2,%0\;nop\;addc %d1,%d2,%d0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addp32df3x_errata_APSV_16"
  [(set (match_operand:P32DF   0 "pic30_mode2mres_operand"      "=r,&r,&r,R,R,R,>,>,>")
        (plus:P32DF 
          (match_operand:P32DF 1 "pic30_register_operand"       "%r, r, r,r,r,r,r,r,r")
          (match_operand:P32DF 2 "pic30_mode2mres_APSV_operand" " r, R, >,r,R,>,r,R,>")
   ))
   (clobber (match_scratch:HI 3                                 "=X,&r,&r,X,&r,&r,X,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && (pic30_errata_mask & psv_errata)"
  "*
   {
     static const char *patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;mov %D2,%3\;addc %d1,%3,%d0\",
       \"add %1,%2,%0\;mov %d2,%3\;addc %d1,%3,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\",
       \"add %1,%2,%I0\;mov %d2,%3\;addc %d1,%3,%D0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;mov %D2,%3\;addc %d1,%3,%d0\",
       \"add %1,%2,%0\;mov %d2,%3\;addc %d1,%3,%d0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;nop\;mov %D2,%3\;addc %d1,%3,%d0\",
       \"add %1,%2,%0\;nop\;mov %d2,%3\;addc %d1,%3,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\",
       \"add %1,%2,%I0\;nop\;mov %d2,%3\;addc %d1,%3,%D0\",
       \"add %1,%2,%0\;addc %d1,%d2,%d0\",
       \"add %1,%I2,%0\;nop\;mov %D2,%3\;addc %d1,%3,%d0\",
       \"add %1,%2,%0\;nop\;mov %d2,%3\;addc %d1,%3,%d0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,defuse,use,use,use,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

;; P32EXT

(define_insn "addp32ext3_imm_16"
  [(set (match_operand:P32EXT 0 "pic30_register_operand"          "=r,r,r,r")
        (plus:P32EXT 
                 (match_operand:P32EXT 1 "pic30_register_operand" "%r,r,0,0")
                 (match_operand:P32EXT 2 "pic30_JM_operand"       " P,N,J,M")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add %1,#%2,%0\;addc %d1,#0,%d0
   sub %1,#%J2,%0\;subb %d1,#0,%d0
   add #%2,%0\;addc #0,%d0
   sub %0,#%J2\;subb %d0,#0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "addp32ext3_errata_APSV_16"
 [(set (match_operand:P32EXT   0 "pic30_rR_or_near_operand"  "=r,r,r,&r,r,r,r,R,R,R")
   (plus:P32EXT
     (match_operand:P32EXT 1 "pic30_rR_or_near_APSV_operand" "%r,0,r, R,r,r,0,r,r,r")
     (match_operand:P32EXT 2 "pic30_rR_or_JN_APSV_operand"    "r,r,0, r,P,N,J,r,0,R")
  ))
  (clobber (match_scratch:HI 3                         "=X,X,X,&r,X,X,X,X,X,&r")
  )
  (clobber (reg:CC_NZC CC_REG))
 ]
  "(!pic30_isa32_target()) && (pic30_errata_mask & psv_errata)"
  "*
   {
     static const char *patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;mov %D1,%3\;addc %d2,%3,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;mov %D2,%3\;addc %d1,%3,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;nop\;mov %D1,%3\;addc %d2,%3,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;nop\;mov %D2,%3\;addc %d1,%3,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addp32ext3_DATA_16"
 [(set (match_operand:P32EXT   0 "pic30_rR_or_near_operand" "=r,r,r,&r,r,r,r,R,R,R")
       (plus:P32EXT
         (match_operand:P32EXT 1 "pic30_rR_or_near_operand" "%r,0,r, R,r,r,0,r,r,r")
         (match_operand:P32EXT 2 "pic30_rR_or_JN_operand"    "r,r,0, r,P,N,J,r,0,R")  ))
  (clobber (reg:CC_NZC CC_REG))
 ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;nop\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "addp32ext3_noerrata_APSV_16"
 [(set (match_operand:P32EXT   0 "pic30_rR_or_near_operand"      "=r,r,r,&r,r,r,r,R,R,R")
       (plus:P32EXT
         (match_operand:P32EXT 1 "pic30_rR_or_near_APSV_operand" "%r,0,r, R,r,r,0,r,r,r")
         (match_operand:P32EXT 2 "pic30_rR_or_JN_APSV_operand"    "r,r,0, r,P,N,J,r,0,R")  ))
  (clobber (reg:CC_NZC CC_REG))
 ]
  "(!pic30_isa32_target()) && (!(pic30_errata_mask & psv_errata))"
  "*
   {
     static const char *patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;addc %d1,%D2,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%1,%0\;addc %d2,%d1,%d0\",
       \"add %2,%I1,%0\;nop\;addc %d2,%D1,%d0\",
       \"add %1,#%2,%0\;addc %d1,#0,%d0\",
       \"sub %1,#%J2,%0\;subb %d1,#0,%d0\",
       \"add #%2,%0\;addc #%y2,%d0\",
       \"add %1,%2,%I0\;addc %d1,%d2,%D0\",
       \"add %1,%2,%0\;addc %d1,%P2,%D0\",
       \"add %1,%I2,%I0\;nop\;addc %d1,%D2,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math,math,math,math,math,math,math,math,math,math")
    (set_attr "type" "def,def,def,defuse,def,def,def,use,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_expand "addp32ext3_16"
  [(set (match_operand:P32EXT 0 "pic30_rR_or_near_operand" "")
        (plus:P32EXT
          (match_operand:P32EXT 1 "pic30_rR_or_near_APSV_operand" "")
          (match_operand:P32EXT 2 "pic30_rR_or_JN_APSV_operand" "")))]
  "(!pic30_isa32_target())"
  "
{
  rtx op2 = operands[2];

  if (!pic30_rR_or_JN_APSV_operand(op2,P32EXTmode)) {
    op2 = force_reg(P32EXTmode,op2);
  }
  if (pic30_rR_or_near_operand(operands[1],GET_MODE(operands[1]))) {
    emit_insn(
      gen_addp32ext3_DATA_16(operands[0], operands[1], op2)
    );
  } else if (pic30_errata_mask & psv_errata) {
    emit_insn(
      gen_addp32ext3_errata_APSV_16(operands[0], operands[1], op2)
    );
  } else {
    emit_insn(
      gen_addp32ext3_noerrata_APSV_16(operands[0], operands[1], op2)
   );
  }
  DONE;
}")

;; P32EDS

(define_insn "cmpp32eds_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:P32EDS 0 "pic30_mode2_operand"
                                "r,r,r, R,<>,r")
                 (match_operand:P32EDS 1 "pic30_mode1PN_UMM_operand"
                                "r,R,<>,r,r, PN")))
  ]
  ""
  "*
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0:  return \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\";
     case 1:  return \"sub %0,%I1,[w15]\;subb %d0,%D1,[w15]\";
     case 2:  return \"sub %0,%1,[w15]\;subb %d0,%1,[w15]\";
     case 3:  return \"subr %1,%I0,[w15]\;subbr %1,%D0,[w15]\";
     case 4:  return \"subr %1,%0,[w15]\;subbr %1,%0,[w15]\";
     case 5:
              if (INTVAL(operands[1]) >= 0) {
                return \"sub %0,#%1,[w15]\;subb %d0,#0,[w15]\";
              } else {
                return \"add %0,#%J1,[w15]\;addc %d0,#0,[w15]\";
              }
   }"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,use,use,etc")
  ]
)


;; P32UMM

(define_insn "cmpp32umm_16"
  [(set (reg:CC CC_REG)
        (compare (match_operand:P32UMM 0 "pic30_mode2_operand"
                                "r,r,r, R,<>,r")
                 (match_operand:P32UMM 1 "pic30_mode1PN_UMM_operand"
                                "r,R,<>,r,r, h")))
  ]
  ""
  "*
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0:  return \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\";
     case 1:  return \"sub %0,%I1,[w15]\;subb %d0,%D1,[w15]\";
     case 2:  return \"sub %0,%1,[w15]\;subb %d0,%1,[w15]\";
     case 3:  return \"subr %1,%I0,[w15]\;subbr %1,%D0,[w15]\";
     case 4:  return \"subr %1,%0,[w15]\;subbr %1,%0,[w15]\";
     case 5:  
              if (INTVAL(operands[1]) >= 0) {
                return \"sub %0,#(%1*2),[w15]\;subb %d0,#0,[w15]\";
              } else {
                return \"add %0,#(%J1*2),[w15]\;addc %d0,#0,[w15]\";
              }
   }"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,use,use,etc")
  ]
)

(define_insn "addp32umm_lit_16"
  [(set (match_operand:P32UMM   0 "pic30_register_operand" "=r,r")
        (plus: P32UMM
          (match_operand:P32UMM 1 "pic30_register_operand" " 0,0")
          (match_operand:P32UMM 2 "pic30_OJM_operand"      " PJ,M")))
   (clobber (match_scratch:HI   3                          "=X,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "*
   if (INTVAL(operands[2]) >= 0) {
     if (INTVAL(operands[2]) <= 255) {
       return \"add #(%2*2),%0\;\"
              \"btsc _SR,#0\;\"
              \"bset %0,#0\;\"
              \"addc #0,%d0\";
     } else {
       return \"add #%2,%0\;\"
              \"addc #0,%d0\;\"
              \"add #%2,%0\;\"
              \"addc #0,%d0\;\"
              \"cp0 %d0\;\"
              \"btss _SR,#1\;\"
              \"bset %0,#0\";
     }
   } else {
     if (INTVAL(operands[2]) >= -255) {
       return \"sub #(%J2*2),%0\;\"
              \"and.b #0,%3\;\"
              \"subb #0,%d0\;\"
              \"bsw.z %0,%3\";
     } else {
       return \"sub #%J2,%0\;\"
              \"subb #0,%d0\;\"
              \"sub #%J2,%0\;\"
              \"and.b #0,%3\;\" 
              \"subb #0,%d0\;\"
              \"bsw.z %0,%3\";
     }
  }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)  

; (CAW) below, and.b #0,xx will clear the low bits and set Z flag

(define_insn "addp32umm3hi_r_16"
  [(set (match_operand: P32UMM   0 "pic30_register_operand" "=&r,&r")
        (plus: P32UMM
          (match_operand:P32UMM  1 "pic30_register_operand" "%r,  0")
          (subreg:P32UMM
            (match_operand:HI    2 "pic30_mode2_operand"    " r,  R") 0)))
   (clobber (match_scratch:SI    3                          "=&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "@
   asr %2,#15,%d3\;sl %2,%3\;add %3,%1,%0\;and.b #0,%3\;addc %d3,%d1,%d0\;bsw.z %0,%3
   mov %2,%d3\;asr %d3,#15,%d3\;sl %2,%3\;add %3,%1,%0\;and.b #0,%3\;addc %d3,%d1,%d0\;bsw.z %0,%3"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "addp32umm3hi_rnc_16"
  [(set (match_operand: P32UMM   0 "pic30_register_operand" "=&r,&r")
        (plus: P32UMM
          (match_operand:P32UMM  1 "pic30_register_operand" "%r,  0")
          (subreg:P32UMM
            (match_operand:HI    2 "pic30_mode2_operand"    " r,  R") 0)))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "@
   asr %2,#15,%d0\;sl %2,%0\;add %0,%1,%0\;addc %d0,%d1,%d0\;bclr %0,#0\;cp0 %d0\;btss _SR,#1\;bset %0,#0
   mov %2,%0\;asr %0,#15,%d0\;sl %0,%0\;add %0,%1,%0\;addc %d0,%d1,%d0\;bclr %0,#0\;cp0 %d0\;btss _SR,#1\;bset %0,#0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "addp32umm3si_r_16"
  [(set (match_operand: P32UMM   0 "pic30_register_operand" "=&r,&r")
        (plus: P32UMM
          (match_operand:P32UMM  1 "pic30_register_operand" "%r,  0")
          (subreg:P32UMM
            (match_operand:SI    2 "pic30_mode2_operand"    "r,   R") 0)))
   (clobber (match_scratch:HI    3                          "=&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "@
   sl %2,%3\;add %3,%1,%0\;and.b #0,%3\;addc %d2,%d1,%d0\;bsw.z %0,%3
   sl %I2,%3\;add %3,%1,%0\;and.b #0,%3\;addc %d1,%D2,%d0\;bsw.z %0,%3"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "addp32umm3_r_16"
  [(set (match_operand: P32UMM   0 "pic30_register_operand" "=r,&r")
        (plus: P32UMM
          (match_operand:P32UMM  1 "pic30_register_operand" "%r, 0")
          (match_operand:P32UMM  2 "pic30_mode2_operand"    "r,  R")))
   (clobber (match_scratch:HI    3                         "=&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ] 
  ""
  "@
   add %1,%2,%0\;and.b #0,%3\;addc %d1,%d2,%d0\;bsw.z %0,%3
   add %1,%I2,%0\;and.b #0,%3\;addc %d1,%D2,%d0\;bsw.z %0,%3"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "addp32umm3_rnc_16"
  [(set (match_operand: P32UMM   0 "pic30_register_operand" "=r,&r")
        (plus: P32UMM
          (match_operand:P32UMM  1 "pic30_register_operand" "%r, 0")
          (match_operand:P32UMM  2 "pic30_mode2_operand"    "r,  R")))
   (clobber (reg:CC_NZC CC_REG))
  ] 
  ""
  "@
   add %1,%2,%0\;addc %d1,%d2,%d0\;bclr %0,#0\;cp0 %d0\;btss _SR,#1\;bset %0,#0
   add %1,%I2,%0\;addc %d1,%D2,%d0\;bclr %0,#0\;cp0 %d0\;btss _SR,#1\;bset %0,#0"
  [
    (set_attr "type" "def")
  ]
)

(define_expand "addp32umm3_16"
  [(set (match_operand:P32UMM    0 "pic30_register_operand" "")
        (plus: P32UMM 
           (match_operand:P32UMM 1 "pic30_register_operand" "")
           (match_operand:P32UMM 2 "pic30_mode1i_operand" "")))]
  ""
  "{
   if (GET_CODE(operands[2]) == CONST_INT) {
     rtx new_val = operands[2];
     if (pic30_OJM_operand(new_val, HImode)) {
       emit_insn(gen_addp32umm_lit_16(operand0,operand1,operand2));
       DONE;
     } else {
       /* load the immediate separately */
 
       emit_insn(gen_movp32umm_lit_16(operand0, new_val));
       emit_insn(gen_addp32umm3_rnc_16(operand0, operand1, operand0));
       DONE;
     }
   }
   emit_insn(gen_addp32umm3_rnc_16(operand0, operand1, operand2));
   DONE;
}")

;;;;;;;;;;;;;;;;;
;; double integer
;;;;;;;;;;;;;;;;;

(define_insn "*adddi3_imm_16"
  [(set (match_operand:DI          0 "pic30_register_operand" "=r,r,r,r")
        (plus:DI (match_operand:DI 1 "pic30_register_operand" "%r,r,0,0")
                 (match_operand:DI 2 "pic30_JM_operand"       " P,N,J,M")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add %1,#%2,%0\;addc %d1,#0,%d0\;addc %t1,#0,%t0\;addc %q1,#0,%q0
   sub %1,#%J2,%0\;subb %d1,#0,%d0\;subb %t1,#0,%t0\;subb %q1,#0,%q0
   add #%2,%0\;addc #%y2,%d0\;addc #%x2,%t0\;addc #%w2,%q0
   sub %0,#%J2\;subb %d0,#0\;subb %t0,#0\;subb %q0,#0"
  [
   (set_attr "cc" "math") ; CAW
   ; (set_attr "type" "def")
   (set_attr "type" "etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*addhidi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (sign_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%d2,%d0\;\"
                              \"addc %3,%t2,%t0\;addc %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%d2,%0\;\"
                              \"addc %3,%t2,%0\;addc %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;add %1,%s2,%0\;addc %3,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%2,%0\;\"
                              \"addc %3,%2,%0\;addc %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%2,%d0\;\"
                              \"addc %3,%2,%t0\;addc %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;add %1,%2,%I0\;addc %3,%d2,%I0\;\"
                              \"addc %3,%t2,%I0\;addc %3,%q2,%s0\",

     /* R,r,0 */          \"asr %1,#15,%3\;add %1,%2,%I0\;addc %3,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"asr %1,#15,%3\;add %1,%I2,%I0\;addc %3,%I2,%I0\;\"
                              \"addc %3,%I2,%I0\;addc %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;add %1,%I2,%0\;addc %3,%I2,%d0\;\"
                              \"addc %3,%I2,%t0\;addc %3,%2,%q0\",
   };

   const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%d2,%d0\;\"
                              \"addc %3,%t2,%t0\;addc %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;add %1,%2,%0\;addc %3,%d2,%0\;\"
                              \"addc %3,%t2,%0\;addc %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;add %1,%s2,%0\;addc %3,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;add %1,%2,%I0\;addc %3,%d2,%I0\;\"
                              \"addc %3,%t2,%I0\;addc %3,%q2,%s0\",

     /* R,r,0 */          \"asr %1,#15,%3\;add %1,%2,%I0\;addc %3,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"asr %1,#15,%3\;\"
                          \"add %1,%I2,%I0\;\"
                          \"\nop\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"\nop\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"\nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;\"
                          \"add %1,%I2,%0\;\"
                          \"\nop\;\"
                          \"addc %3,%I2,%d0\;\"
                          \"\nop\;\"
                          \"addc %3,%I2,%t0\;\"
                          \"\nop\;\"
                          \"addc %3,%2,%q0\",
   };
 
  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber") ; CAW
     ; (set_attr "type" "def")
     (set_attr "type" "etc")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*addhidi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (zero_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d2,#0,%d0\;\"
                              \"addc %t2,#0,%t0\;addc %q2,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d2,#0,%0\;\"
                              \"addc %t2,#0,%0\;addc %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;add %1,%s2,%0\;addc %3,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;add %1,%2,%0\;addc %3,%2,%0\;\"
                              \"addc %3,%2,%0\;addc %3,%2,%0\",

     /* r,r,> */          \"clr %3\;add %1,%2,%0\;addc %3,%2,%d0\;\"
                              \"addc %3,%2,%t0\;addc %3,%2,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d2,#0,%I0\;\"
                              \"addc %t2,#0,%I0\;addc %q2,#0,%s0\",

     /* R,r,0 */          \"clr %3\;add %1,%2,%I0\;addc %3,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"clr %3\;add %1,%I2,%I0\;addc %3,%I2,%I0\;\"
                              \"addc %3,%I2,%I0\;addc %3,%2,%0\",

     /* r,r,R */          \"clr %3\;add %1,%I2,%0\;addc %3,%I2,%d0\;\"
                              \"addc %3,%I2,%t0\;addc %3,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d2,#0,%d0\;\"
                              \"addc %t2,#0,%t0\;addc %q2,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d2,#0,%0\;\"
                              \"addc %t2,#0,%0\;addc %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;add %1,%s2,%0\;addc %3,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,> */          \"clr %3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d2,#0,%I0\;\"
                              \"addc %t2,#0,%I0\;addc %q2,#0,%s0\",

     /* R,r,0 */          \"clr %3\;add %1,%2,%I0\;addc %3,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"clr %3\;\"
                          \"add %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,R */          \"clr %3\;\"
                          \"add %1,%I2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber") ; CAW
     (set_attr "type" "etc")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*addsidi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (sign_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r,r,r,r,r,r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>,>,r,0,R,R")))
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %3,%t2,%t0\;addc %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %3,%t2,%0\;addc %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;add %1,%s2,%0\;addc %d1,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;add %1,%2,%0\;addc %d1,%2,%0\;\"
                              \"addc %3,%2,%0\;addc %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;add %1,%2,%0\;addc %d1,%2,%d0\;\"
                              \"addc %3,%2,%t0\;addc %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %3,%t2,%I0\;addc %3,%q2,%s0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;add %1,%2,%I0\;addc %d1,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"asr %d1,#15,%3\;add %1,%I2,%I0\;addc %d1,%I2,%I0\;\"
                              \"addc %3,%I2,%I0\;addc %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;add %1,%I2,%0\;addc %d1,%I2,%d0\;\"
                              \"addc %3,%I2,%t0\;addc %3,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %3,%t2,%t0\;addc %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %3,%t2,%0\;addc %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;add %1,%s2,%0\;addc %d1,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %3,%t2,%I0\;addc %3,%q2,%s0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;add %1,%2,%I0\;addc %d1,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"asr %d1,#15,%3\;\"
                          \"add %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;\"
                          \"add %1,%I2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "etc")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*addsidi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (zero_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %t2,#0,%t0\;addc %q2,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %t2,#0,%0\;addc %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;add %1,%s2,%0\;addc %d1,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;add %1,%2,%0\;addc %d1,%2,%0\;\"
                              \"addc %3,%2,%0\;addc %3,%2,%0\",

     /* r,r,> */          \"clr %3\;add %1,%2,%0\;addc %d1,%2,%d0\;\"
                              \"addc %3,%2,%t0\;addc %3,%2,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %t2,#0,%I0\;addc %q2,#0,%s0\",

     /* R,r,0 */          \"clr %3\;add %1,%2,%I0\;addc %d1,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"clr %3\;add %1,%I2,%I0\;addc %d1,%I2,%I0\;\"
                              \"addc %3,%I2,%I0\;addc %3,%2,%0\",

     /* r,r,R */          \"clr %3\;add %1,%I2,%0\;addc %d1,%I2,%d0\;\"
                              \"addc %3,%I2,%t0\;addc %3,%2,%q0\",
  };

   const char *psv_psv_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %t2,#0,%t0\;addc %q2,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %t2,#0,%0\;addc %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;add %1,%s2,%0\;addc %d1,%s2,%0\;\"
                              \"addc %3,%s2,%0\;addc %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,> */          \"clr %3\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %t2,#0,%I0\;addc %q2,#0,%s0\",

     /* R,r,0 */          \"clr %3\;add %1,%2,%I0\;addc %d1,%2,%I0\;\"
                              \"addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"clr %3\;\"
                          \"add %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,R */          \"clr %3\;\"
                          \"add %1,%I2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }
  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "etc")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*adddihi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;add %1,%2,%0\;addc %d1,%3,%d0\;\"
                              \"addc %t1,%3,%t0\;addc %q1,%3,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;add %1,%2,%0\;addc %d1,%3,%0\;\"
                              \"addc %t1,%3,%0\;addc %q1,%3,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;add %2,%s1,%0\;addc %3,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;add %2,%1,%0\;addc %3,%1,%0\;\"
                              \"addc %3,%1,%0\;addc %3,%2,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;add %2,%1,%0\;addc %3,%1,%d0\;\"
                              \"addc %3,%1,%t0\;addc %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;add %1,%2,%I0\;addc %d1,%3,%I0\;\"
                              \"addc %t1,%3,%I0\;addc %q1,%3,%s0\",

     /* R,0,r */          \"asr %2,#15,%3\;add %2,%1,%I0\;addc %3,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%s0\",

     /* R,R,r */          \"asr %2,#15,%3\;add %2,%I1,%I0\;addc %3,%I1,%I0\;\"
                              \"addc %3,%I1,%I0\;addc %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;add %2,%I1,%0\;addc %3,%I1,%d0\;\"
                              \"addc %3,%I1,%t0\;addc %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;add %1,%2,%0\;addc %d1,%3,%d0\;\"
                              \"addc %t1,%3,%t0\;addc %q1,%3,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;add %1,%2,%0\;addc %d1,%3,%0\;\"
                              \"addc %t1,%3,%0\;addc %q1,%3,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;add %2,%s1,%0\;addc %3,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;add %1,%2,%I0\;addc %d1,%3,%I0\;\"
                              \"addc %t1,%3,%I0\;addc %q1,%3,%s0\",

     /* R,0,r */          \"asr %2,#15,%3\;add %2,%1,%I0\;addc %3,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%s0\",

     /* R,R,r */          \"asr %2,#15,%3\;\"
                          \"add %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;\"
                          \"add %2,%I1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "etc")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*adddihi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,#0,%d0\;\"
                              \"addc %t1,#0,%t0\;addc q1,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,#0,%0\;\"
                              \"addc %t1,#0,%0\;addc %q1,#0,%0\",

     /* >,0,r */          \"clr %3\;add %s1,%2,%0\;addc %3,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"clr %3\;add %2,%1,%0\;addc %3,%1,%0\;\"
                              \"addc %3,%1,%0\;addc %3,%1,%0\",

     /* r,>,r */          \"clr %3\;add %2,%1,%0\;addc %3,%1,%d0\;\"
                              \"addc %3,%1,%t0\;addc %3,%1,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,#0,%I0\;\"
                              \"addc %t1,#0,%I0\;addc %q1,#0,%0\",

     /* R,0,r */          \"clr %3\;add %2,%1,%I0\;addc %3,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%0\",

     /* R,R,r */          \"clr %3\;add %2,%I1,%I0\;addc %3,%I1,%I0\;\"
                              \"addc %3,%I1,%I0\;addc %3,%1,%0\",

     /* r,R,r */          \"clr %3\;add %2,%I1,%0\;addc %3,%I1,%d0\;\"
                              \"addc %3,%I1,%t0\;addc %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,#0,%d0\;\"
                              \"addc %t1,#0,%t0\;addc q1,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,#0,%0\;\"
                              \"addc %t1,#0,%0\;addc %q1,#0,%0\",

     /* >,0,r */          \"clr %3\;add %s1,%2,%0\;addc %3,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"clr %3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,>,r */          \"clr %3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,#0,%I0\;\"
                              \"addc %t1,#0,%I0\;addc %q1,#0,%0\",

     /* R,0,r */          \"clr %3\;add %2,%1,%I0\;addc %3,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%0\",

     /* R,R,r */          \"clr %3\;\"
                          \"add %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,R,r */          \"clr %3\;\"
                          \"add %2,%I1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "etc")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*adddisi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (match_operand:SI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %3,%t1,%t0\;addc %3,%q1,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %3,%t1,%0\;addc %3,%q1,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;add %2,%s1,%0\;addc %d2,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;add %2,%1,%0\;addc %d2,%1,%0\;\"
                              \"addc %3,%1,%0\;addc %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;add %2,%1,%0\;addc %d2,%1,%d0\;\"
                              \"addc %3,%1,%t0\;addc %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;add %2,%1,%I0\;addc %d2,%d1,%I0\;\"
                              \"addc %3,%t1,%I0\;addc %3,%q1,%s0\",

     /* R,0,r */          \"asr %d2,#15,%3\;add %2,%1,%I0\;addc %d2,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%s0\",

     /* R,R,r */          \"asr %d2,#15,%3\;add %2,%I1,%I0\;addc %d2,%I1,%I0\;\"
                              \"addc %3,%I1,%I0\;addc %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;add %2,%I1,%0\;addc %d2,%I1,%d0\;\"
                              \"addc %3,%I1,%t0\;addc %3,%1,%q0\",
  };

   const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %3,%t1,%t0\;addc %3,%q1,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %3,%t1,%0\;addc %3,%q1,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;add %2,%s1,%0\;addc %d2,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %d2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;add %2,%1,%I0\;addc %d2,%d1,%I0\;\"
                              \"addc %3,%t1,%I0\;addc %3,%q1,%s0\",

     /* R,0,r */          \"asr %d2,#15,%3\;add %2,%1,%I0\;addc %d2,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%s0\",

     /* R,R,r */          \"asr %d2,#15,%3\;\"
                          \"add %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;\"
                          \"add %2,%I1,%0\;\"
                          \"nop\;\"
                          \"addc %d2,%I1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "etc")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*adddisi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %t1,#0,%t0\;addc %q1,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %t1,#0,%0\;addc %q1,#0,%0\",

     /* >,0,r */          \"clr %3\;add %2,%s1,%0\;addc %d2,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"clr %3\;add %2,%1,%0\;addc %d2,%1,%0\;\"
                              \"addc %3,%1,%0\;addc %3,%1,%0\",

     /* r,>,r */          \"clr %3\;add %2,%1,%0\;addc %d2,%1,%d0\;\"
                              \"addc %3,%1,%t0\;addc %3,%1,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %t1,#0,%I0\;addc %q1,#0,%s0\",

     /* R,0,r */          \"clr %3\;add %2,%1,%I0\;addc %d2,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%s0\",

     /* R,R,r */          \"clr %3\;add %2,%I1,%I0\;addc %d2,%I1,%I0\;\"
                              \"addc %3,%I1,%I0\;addc %3,%1,%0\",

     /* r,R,r */          \"clr %3\;add %2,%I1,%0\;addc %d2,%I1,%d0\;\"
                              \"addc %3,%I1,%t0\;addc %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %t1,#0,%t0\;addc %q1,#0,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %t1,#0,%0\;addc %q1,#0,%0\",

     /* >,0,r */          \"clr %3\;add %2,%s1,%0\;addc %d2,%s1,%0\;\"
                              \"addc %3,%s1,%0\;addc %3,%s1,%0\",

     /* >,>,r */          \"clr %3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %d2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,>,r */          \"clr %3\;\"
                          \"add %2,%1,%0\;\"
                          \"nop\;\"
                          \"addc %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %t1,#0,%I0\;addc %q1,#0,%s0\",

     /* R,0,r */          \"clr %3\;add %2,%1,%I0\;addc %d2,%1,%I0\;\"
                              \"addc %3,%1,%I0\;addc %3,%1,%s0\",

     /* R,R,r */          \"clr %3\;\"
                          \"add %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%0\",

     /* r,R,r */          \"clr %3\;\"
                          \"add %2,%I1,%0\;\"
                          \"nop\;\"
                          \"addc %d2,%I1,%d0\;\"
                          \"nop\;\"
                          \"addc %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%1,%q0\",
  };


  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "etc")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "addsidi3_hi_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (ashift:DI
             (match_operand:DI 1 "pic30_register_operand"    " r,r,r,r, r,r,r,r, r")
             (const_int 32))
           (match_operand:DI 2 "pic30_DI_mode2_operand"      " r,r,0,>, >,r,0,R, R")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"mov.d %2,%0\;add %1,%t2,%t0\;addc %d1,%q2,%q0\",

     /* >,r,r */          \"mov.d %2,%0\;add %1,%t2,%0\;addc %d1,%q2,%0\",

     /* >,r,0 */          \"add %r0,#4,%r0\;add %1,%s2,%0\;addc %d1,%s2,%0\",

     /* >,r,> */          \"mov %2,%0\;mov %2,%0\;\"
                              \"add %1,%2,%0\;addc %d1,%2,%0\",

     /* r,r,> */          \"mov.d %2,%0\;add %1,%2,%t0\;addc %d1,%2,%q0\",

     /* R,r,r */          \"mov.d %2,%I0\;add %1,%t2,%I0\;addc %d1,%q2,%0\",

     /* R,r,0 */          \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%2,%0\",

     /* R,r,R */          \"mov %I2,%I0\;mov %I2,%I0\;\"
                              \"add %1,%I2,%I0\;addc %d1,%2,%0\",

     /* r,r,R */          \"mov.d %I2,%0\;add %1,%I2,%t0\;addc %d1,%2,%q0\",
  };

   const char *psv_psv_patterns[] = {
     /* r,r,r */          \"mov.d %2,%0\;add %1,%t2,%t0\;addc %d1,%q2,%q0\",

     /* >,r,r */          \"mov.d %2,%0\;add %1,%t2,%0\;addc %d1,%q2,%0\",

     /* >,r,0 */          \"add %r0,#4,%r0\;add %1,%s2,%0\;nop\;addc %d1,%s2,%0\",

     /* >,r,> */          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%0\",

     /* r,r,> */          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%d0\;\"
                          \"nop\;\"
                          \"add %1,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%q0\",

     /* R,r,r */          \"mov.d %2,%I0\;\"
                          \"add %1,%t2,%I0\;\"
                          \"addc %d1,%q2,%0\",

     /* R,r,0 */          \"add %r0,#4,%r0\;\"
                          \"addc %1,%2,%I0\;\"
                          \"addc %d1,%2,%0\",

     /* R,r,R */          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"add %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%0\",

     /* r,r,R */          \"mov %I2,%0\;\"
                          \"nop\;\"
                          \"mov %I2,%d0\;\"
                          \"nop\;\"
                          \"add %1,%I2,%t0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     ; (set_attr "type" "def,use,use,use,defuse,use,use,use,defuse")
     (set_attr "type" "etc,use,use,use,use,use,use,use,use")
  ]
)


(define_insn "addsidi3_hi2_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"        "=r,>,>,>,&r,R,R,R,&r,r")
        (plus:DI
           (mult:DI
             (match_operand:DI 1 "pic30_register_operand"    "r,r,r,r, r,r,r,r, r,r")
             (const_int 4294967296))
           (match_operand:DI 2 "pic30_DI_mode2k_operand"     "r,r,0,>, >,r,0,R, R,Q")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"mov.d %2,%0\;add %1,%t2,%t0\;addc %d1,%q2,%q0\",

     /* >,r,r */          \"mov.d %2,%0\;add %1,%t2,%0\;addc %d1,%q2,%0\",

     /* >,r,0 */          \"add %r0,#4,%r0\;add %1,%s2,%0\;addc %d1,%s2,%0\",

     /* >,r,> */          \"mov %2,%0\;mov %2,%0\;\"
                              \"add %1,%2,%0\;addc %d1,%2,%0\",

     /* r,r,> */          \"mov.d %2,%0\;add %1,%2,%t0\;addc %d1,%2,%q0\",

     /* R,r,r */          \"mov.d %2,%I0\;add %1,%t2,%I0\;addc %d1,%q2,%0\",

     /* R,r,0 */          \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%2,%0\",

     /* R,r,R */          \"mov %I2,%I0\;mov %I2,%I0\;\"
                              \"add %1,%I2,%I0\;addc %d1,%2,%0\",

     /* r,r,R */          \"mov.d %I2,%0\;add %1,%I2,%t0\;addc %d1,%2,%q0\",

     /* r,r,Q */          \"\", /* placeholder, actual insn is below */

  };

   const char *psv_psv_patterns[] = {
     /* r,r,r */          \"mov.d %2,%0\;add %1,%t2,%t0\;addc %d1,%q2,%q0\",

     /* >,r,r */          \"mov.d %2,%0\;add %1,%t2,%0\;addc %d1,%q2,%0\",

     /* >,r,0 */          \"add %r0,#4,%r0\;add %1,%s2,%0\;nop\;addc %d1,%s2,%0\",

     /* >,r,> */          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%0\",

     /* r,r,> */          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%d0\;\"
                          \"nop\;\"
                          \"add %1,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%q0\",

     /* R,r,r */          \"mov.d %2,%I0\;\"
                          \"add %1,%t2,%I0\;\"
                          \"addc %d1,%q2,%0\",

     /* R,r,0 */          \"add %r0,#4,%r0\;\"
                          \"addc %1,%2,%I0\;\"
                          \"addc %d1,%2,%0\",

     /* R,r,R */          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"add %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%0\",

     /* r,r,R */          \"mov %I2,%0\;\"
                          \"nop\;\"
                          \"mov %I2,%d0\;\"
                          \"nop\;\"
                          \"add %1,%I2,%t0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%q0\",

     /* r,r,Q */          \"\", /* placeholder, actual insn below */
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  int index_value;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 9:  /* r,r,Q */

              index_value = INTVAL(XEXP(XEXP(operands[2],0),1));
              if (pic30_psrd_psrd_errata(NULL,operands[2])) {
                if (index_value < 0) {
                  return \"mov %r2,%q0\;\"
                         \"sub #%i2,%q0\;\"
                         \"mov.d [%q0++],%0\;\"
                         \"nop\;\"
                         \"add %1,[%q0++],%t0\;\"
                         \"nop\;\"
                         \"addc %d1,[%q0],%q0\;\"
                         \"nop\" ;
                } else {
                  return \"mov %r2,%q0\;\"
                         \"add #%i2,%q0\;\"
                         \"mov.d [%q0++],%0\;\"
                         \"nop\;\"
                         \"add %1,[%q0++],%t0\;\"
                         \"nop\;\"
                         \"addc %d1,[%q0],%q0\;\"
                         \"nop\" ;
                }
              } else {
                if (index_value < 0) {
                  return \"mov %r2,%q0\;\"
                         \"sub #%i2,%q0\;\"
                         \"mov.d [%q0++],%0\;\"
                         \"add %1,[%q0++],%t0\;\"
                         \"addc %d1,[%q0],%q0\" ;
                } else {
                  return \"mov %r2,%q0\;\"
                         \"add #%i2,%q0\;\"
                         \"mov.d [%q0++],%0\;\"
                         \"add %1,[%q0++],%t0\;\"
                         \"addc %d1,[%q0],%q0\" ;
                }
              }
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber,clobber")
     ; (set_attr "type" "def,use,use,use,defuse,use,use,use,defuse,etc")
     (set_attr "type" "etc,use,use,use,use,use,use,use,use,etc")
  ]
)

(define_insn "addsidi3_hi3_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (lshiftrt:DI
             (match_operand:DI 1 "pic30_register_operand"     "r,r,r,r, r,r,r,r, r")
             (const_int 32))
           (match_operand:DI   2 "pic30_DI_mode2_operand"     "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI  3                             "=X,X,r,r, r,X,r,r, r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"add %t1,%2,%0\;addc %q1,%d2,%d0\;\"
                             \"addc %t2,#0,%t0\;addc %q2,#0,%q0\",

     /* >,r,r */          \"add %t1,%2,%0\;addc %q1,%d2,%0\;\"
                             \"addc %t2,#0,%0\;addc %q2,#0,%0\",

     /* >,r,0 */          \"add %t1,%s2,%0\;addc %q1,%s2,%0\;\"
                             \"clr %3\;addc %3,%s0,%0\;addc %3,%s0,%0\",

     /* >,r,> */          \"add %t1,%2,%0\;addc %q1,%2,%0\;\"
                             \"clr %3\;addc %3,%2,%0\;addc %3,%2,%0\",

     /* r,r,> */          \"add %t1,%2,%0\;addc %q1,%2,%d0\;\"
                             \"clr %3\;addc %3,%2,%t0\;addc %3,%2,%q0\",

     /* R,r,r */          \"add %t1,%2,%I0\;addc %q1,%d2,%I0\;\"
                             \"addc %t2,#0,%I0\;addc %q2,#0,%0\",

     /* R,r,0 */          \"add %t1,%2,%I0\;addc %q1,%2,%I0\;\"
                             \"clr %3\;addc %3,%2,%I0\;addc %3,%2,%s0\",

     /* R,r,R */          \"add %t1,%I2,%I0\;addc %q1,%I2,%I0\;\"
                             \"clr %3\;addc %3,%I2,%I0\;addc %3,%s2,%s0\",

     /* r,r,R */          \"add %t1,%I2,%0\;addc %q1,%I2,%d0\;\"
                             \"clr %3\;addc %3,%I2,%t0\;addc %3,%s2,%q0\",
  };

   const char *psv_psv_patterns[] = {
     /* r,r,r */          \"add %t1,%2,%0\;addc %q1,%d2,%d0\;\"
                             \"addc %t2,#0,%t0\;addc %q2,#0,%q0\",

     /* >,r,r */          \"add %t1,%2,%0\;addc %q1,%d2,%0\;\"
                             \"addc %t2,#0,%0\;addc %q2,#0,%0\",

     /* >,r,0 */          \"add %t1,%s2,%0\;addc %q1,%s2,%0\;\"
                             \"clr %3\;addc %3,%s0,%0\;addc %3,%s0,%0\",

     /* >,r,> */          \"add %t1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %q1,%2,%0\;\"
                          \"clr %3\;\"
                          \"addc %3,%2,%0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,> */          \"add %t1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %q1,%2,%d0\;\"
                          \"clr %3\;\"
                          \"addc %3,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",

     /* R,r,r */          \"add %t1,%2,%I0\;\"
                          \"addc %q1,%d2,%I0\;\"
                          \"addc %t2,#0,%I0\;\"
                          \"addc %q2,#0,%s0\",

     /* R,r,0 */          \"add %t1,%2,%I0\;\"
                          \"addc %q1,%2,%I0\;\"
                          \"clr %3\;\"
                          \"addc %3,%2,%I0\;\"
                          \"addc %3,%2,%s0\",

     /* R,r,R */          \"add %t1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %q1,%I2,%I0\;\"
                          \"clr %3\;\"
                          \"addc %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%0\",

     /* r,r,R */          \"add %t1,%I2,%0\;\"
                          \"nop\;\"
                          \"addc %q1,%I2,%d0\;\"
                          \"clr %3\;\"
                          \"addc %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"addc %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     ; (set_attr "type" "def,use,use,use,defuse,use,use,use,defuse")
     (set_attr "type" "etc,use,use,use,use,use,use,use,use")
  ]
)

(define_insn "addsidi3_hi2s_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"        "=r,>,>,>,&r,R,R,R,&r,&r,&r")
        (plus:DI
           (mult:DI
             (match_operand:DI 1 "pic30_DI_mode2k_operand"   "r,r,r,r, r,r,r,r, r, r, Q")
             (const_int 4294967296))
           (match_operand:DI 2 "pic30_DI_mode2k_operand"     "r,r,0,>, >,r,0,R, R, Q, r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"mov.d %2,%0\;add %1,%t2,%t0\;addc %d1,%q2,%q0\",

     /* >,r,r */          \"mov.d %2,%0\;add %1,%t2,%0\;addc %d1,%q2,%0\",

     /* >,r,0 */          \"add %r0,#4,%r0\;add %1,%s2,%0\;addc %d1,%s2,%0\",

     /* >,r,> */          \"mov %2,%0\;mov %2,%0\;\"
                              \"add %1,%2,%0\;addc %d1,%2,%0\",

     /* r,r,> */          \"mov.d %2,%0\;add %1,%2,%t0\;addc %d1,%2,%q0\",

     /* R,r,r */          \"mov.d %2,%I0\;add %1,%t2,%I0\;addc %d1,%q2,%0\",

     /* R,r,0 */          \"add %r0,#4,%r0\;add %1,%2,%I0\;addc %d1,%2,%0\",

     /* R,r,R */          \"mov %I2,%I0\;mov %I2,%I0\;\"
                              \"add %1,%I2,%I0\;addc %d1,%2,%0\",

     /* r,r,R */          \"mov.d %I2,%0\;add %1,%I2,%t0\;addc %d1,%2,%q0\",

     /* r,r,Q */          \"\", /* placeholder, actual insn below */
     /* r,Q,r */          \"\", /* placeholder, actual insn below */

  };

   const char *psv_psv_patterns[] = {
     /* r,r,r */          \"mov.d %2,%0\;add %1,%t2,%t0\;addc %d1,%q2,%q0\",

     /* >,r,r */          \"mov.d %2,%0\;add %1,%t2,%0\;addc %d1,%q2,%0\",

     /* >,r,0 */          \"add %r0,#4,%r0\;add %1,%s2,%0\;nop\;addc %d1,%s2,%0\",

     /* >,r,> */          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%0\",

     /* r,r,> */          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%d0\;\"
                          \"nop\;\"
                          \"add %1,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%q0\",

     /* R,r,r */          \"mov.d %2,%I0\;\"
                          \"add %1,%t2,%I0\;\"
                          \"addc %d1,%q2,%0\",

     /* R,r,0 */          \"add %r0,#4,%r0\;\"
                          \"addc %1,%2,%I0\;\"
                          \"addc %d1,%2,%0\",

     /* R,r,R */          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"add %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%0\",

     /* r,r,R */          \"mov %I2,%0\;\"
                          \"nop\;\"
                          \"mov %I2,%d0\;\"
                          \"nop\;\"
                          \"add %1,%I2,%t0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%q0\",

     /* r,r,Q */          \"\", /* placeholder, actual insn below */

     /* r,Q,r */          \"\", /* placeholder, actual insn below */

  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  int index_value;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 9:  /* r,r,Q */

              index_value = INTVAL(XEXP(XEXP(operands[2],0),1));
              if (pic30_psrd_psrd_errata(NULL,operands[2])) {
                if (index_value < 0) {
                  return \"mov %r2,%q0\;\"
                         \"sub #%i2,%q0\;\"
                         \"mov.d [%q0++],%0\;\"
                         \"nop\;\"
                         \"add %1,[%q0++],%t0\;\"
                         \"nop\;\"
                         \"addc %d1,[%q0],%q0\;\"
                         \"nop\" ;
                } else {
                  return \"mov %r2,%q0\;\"
                         \"add #%i2,%q0\;\"
                         \"mov.d [%q0++],%0\;\"
                         \"nop\;\"
                         \"add %1,[%q0++],%t0\;\"
                         \"nop\;\"
                         \"addc %d1,[%q0],%q0\;\"
                         \"nop\" ;
                }
              } else {
                if (index_value < 0) {
                  return \"mov %r2,%q0\;\"
                         \"sub #%i2,%q0\;\"
                         \"mov.d [%q0++],%0\;\"
                         \"add %1,[%q0++],%t0\;\"
                         \"addc %d1,[%q0],%q0\" ;
                } else {
                  return \"mov %r2,%q0\;\"
                         \"add #%i2,%q0\;\"
                         \"mov.d [%q0++],%0\;\"
                         \"add %1,[%q0++],%t0\;\"
                         \"addc %d1,[%q0],%q0\" ;
                }
              }

     case 10:  /* r,Q,r */

              index_value = INTVAL(XEXP(XEXP(operands[1],0),1));
              if (pic30_psrd_psrd_errata(NULL,operands[1])) {
                if (index_value < 0) {
                  return \"mov %r1,%q0\;\"
                         \"sub #%i1,%q0\;\"
                         \"mov.d [%q0++],%0\;\"
                         \"nop\;\"
                         \"add %t2,[%q0++],%t0\;\"
                         \"nop\;\"
                         \"addc %q2,[%q0],%q0\;\"
                         \"nop\" ;
                } else {
                  return \"mov %r1,%q0\;\"
                         \"add #%i1,%q0\;\"
                         \"mov.d [%q0++],%0\;\"
                         \"nop\;\"
                         \"add %t2,[%q0++],%t0\;\"
                         \"nop\;\"
                         \"addc %q2,[%q0],%q0\;\"
                         \"nop\" ;
                }
              } else {
                if (index_value < 0) {
                  return \"mov %r1,%q0\;\"
                         \"sub #%i1,%q0\;\"
                         \"mov.d [%q0++],%0\;\"
                         \"add %t2,[%q0++],%t0\;\"
                         \"addc %q2,[%q0],%q0\" ;
                } else {
                  return \"mov %r1,%q0\;\"
                         \"add #%i1,%q0\;\"
                         \"mov.d [%q0++],%0\;\"
                         \"add %t2,[%q0++],%t0\;\"
                         \"addc %q2,[%q0],%q0\" ;
                }
              }
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber,clobber,clobber")
     ; (set_attr "type" "def,use,use,use,defuse,use,use,use,defuse,etc,etc")
     (set_attr "type" "etc,use,use,use,use,use,use,use,use,etc,etc")
  ]
)

; In this case it ought to be + since its a input and output
;
;(define_insn "adddi3_dup_16"
;  [(set (match_operand:DI 0 "pic30_register_operand"         "+r")
;        (plus:DI
;           (match_dup 0)
;           (match_dup 0)))
;  ]
;  ""
;  "add %0,%0,%0\;addc %d0,%d0,%d0\;addc %t0,%t0,%t0\;addc %q0,%q0,%q0"
;)

(define_insn "adddi3_dup_16"
  [(set (match_operand:DI 0 "pic30_register_operand"         "=r")
        (plus:DI
           (match_operand:DI 1 "pic30_register_operand"      " r")
           (match_dup 1)))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "add.w %1,%1,%0\;addc.w %d1,%d1,%d0\;addc.w %t1,%t1,%t0\;addc.w %q1,%q1,%q0"
  [
    (set_attr "cc" "math") ; CAW
  ]

)

(define_insn "adddi3_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (plus:DI
           (match_operand:DI 1 "pic30_register_operand"       "r,r,r,r, r,r,r,r, r")
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %t1,%t2,%t0\;addc %q1,%q2,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %t1,%t2,%0\;addc %q1,%q2,%0\",

     /* >,r,0 */          \"add %1,%s2,%0\;addc %d1,%s2,%0\;\"
                              \"addc %t1,%s2,%0\;addc %q1,%s2,%0\",

     /* >,r,> */          \"add %1,%2,%0\;addc %d1,%2,%0\;\"
                              \"addc %t1,%2,%0\;addc %q1,%2,%0\",

     /* r,r,> */          \"add %1,%2,%0\;addc %d1,%2,%d0\;\"
                              \"addc %t1,%2,%t0\;addc %q1,%2,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;addc %d1,%d2,%I0\;\"
                              \"addc %t1,%t2,%I0\;addc %q1,%q2,%s0\",

     /* R,r,0 */          \"add %1,%2,%I0\;addc %d1,%2,%I0\;\"
                              \"addc %t1,%2,%I0\;addc %q1,%2,%s0\",

     /* R,r,R */          \"add %1,%I2,%I0\;addc %d1,%I2,%I0\;\"
                              \"addc %t1,%I2,%I0\;addc %q1,%2,%0\",

     /* r,r,R */          \"add %1,%I2,%0\;addc %d1,%I2,%d0\;\"
                              \"addc %t1,%I2,%t0\;addc %q1,%2,%q0\",
  };

   const char *psv_psv_patterns[] = {
     /* r,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%d0\;\"
                              \"addc %t1,%t2,%t0\;addc %q1,%q2,%q0\",

     /* >,r,r */          \"add %1,%2,%0\;addc %d1,%d2,%0\;\"
                              \"addc %t1,%t2,%0\;addc %q1,%q2,%0\",

     /* >,r,0 */          \"add %1,%s2,%0\;addc %d1,%s2,%0\;\"
                              \"addc %t1,%s2,%0\;addc %q1,%s2,%0\",

     /* >,r,> */          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %t1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %q1,%2,%0\",

     /* r,r,> */          \"add %1,%2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"addc %t1,%2,%t0\;\"
                          \"nop\;\"
                          \"addc %q1,%2,%q0\",

     /* R,r,r */          \"add %1,%2,%I0\;\"
                          \"addc %d1,%d2,%I0\;\"
                          \"addc %t1,%t2,%I0\;\"
                          \"addc %q1,%q2,%s0\",

     /* R,r,0 */          \"add %1,%2,%I0\;\"
                          \"addc %d1,%2,%I0\;\"
                          \"addc %t1,%2,%I0\;\"
                          \"addc %q1,%2,%s0\",

     /* R,r,R */          \"add %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %t1,%I2,%I0\;\"
                          \"nop\;\"
                          \"addc %q1,%2,%0\",

     /* r,r,R */          \"add %1,%I2,%0\;\"
                          \"nop\;\"
                          \"addc %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"addc %t1,%I2,%t0\;\"
                          \"nop\;\"
                          \"addc %q1,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     ; (set_attr "type" "def,use,use,use,defuse,use,use,use,defuse")
     (set_attr "type" "etc,use,use,use,use,use,use,use,use")
     (set_attr "op_type" "alu")
  ]
)

;;;;;;;;
;; float
;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; subtract instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; quarter integer
;;;;;;;;;;;;;;;;;;

(define_insn "*subqi3_imm_16"
  [(set (match_operand:QI 0 "pic30_register_operand"          "=r,r")
        (minus:QI (match_operand:QI 1 "pic30_register_operand" "0,0")
                  (match_operand:QI 2 "pic30_JM_operand"       "J,M")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sub.b %0,#%2
   add.b #%J2,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "subqi3_DATA_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"     "=r<>,r<>,R,R,  r<>,R,r<>,R")
        (minus:QI 
          (match_operand:QI 1 "pic30_register_operand" "r,  r,  r,r,  r,  r,r,  r")
          (match_operand:QI 2 "pic30_mode1PN_operand"  "r,  R<>,r,R<>,N,  N,P,  P")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sub.b %1,%2,%0
   sub.b %1,%2,%0
   sub.b %1,%2,%0
   sub.b %1,%2,%0
   add.b %1,#%J2,%0
   add.b %1,#%J2,%0
   sub.b %1,#%2,%0
   sub.b %1,#%2,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use,def,use,def,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "subqi3_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=r<>,r<>,R,R,  r<>,R,r<>,R")
        (minus:QI 
           (match_operand:QI 1 "pic30_register_operand" "r,r,r,r,r,r,r,r")
           (match_operand:QI 2 "pic30_mode1PN_APSV_operand" 
                               "r,R<>,r,R<>,N,N,P,P")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sub.b %1,%2,%0
   sub.b %1,%2,%0
   sub.b %1,%2,%0
   sub.b %1,%2,%0
   add.b %1,#%J2,%0
   add.b %1,#%J2,%0
   sub.b %1,#%2,%0
   sub.b %1,#%2,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use,def,use,def,use")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "subqi3_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=r<>,r<>,R,R,  r<>,R,r<>,R")
        (minus:QI 
           (match_operand:QI 1 "pic30_register_operand" "r,r,r,r,r,r,r,r")
           (match_operand:QI 2 "pic30_mode1PN_APSV_operand" 
                               "r,R<>,r,R<>,N,N,P,P")))]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode1PN_operand(operands[2],GET_MODE(operands[2])))
    emit(
      gen_subqi3_DATA_16(operands[0],operands[1],operands[2])
    );
  else
    emit(
      gen_subqi3_APSV_16(operands[0],operands[1],operands[2])
    );
  DONE;
}")

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*subqi3_sfr0_16"
  [(set (match_operand:QI 0 "pic30_near_operand"          "=U")
        (minus:QI (match_dup 0)
                  (match_operand:QI 1 "pic30_wreg_operand" "a")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sub.b %0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

;
; pattern 3 could cause a RAW stall, but not the TLCD ECC issue
;   since U won't match a FLASH page
;
(define_insn "*subqi3_sfr1_16"
  [(set (match_operand:QI 0 "pic30_register_operand"             "=a,a,d")
        (minus:QI (match_operand:QI 1 "pic30_near_operand"       " U,U,U")
                  (match_operand:QI 2 "pic30_register_operand"   " a,d,d")))
   (clobber (match_scratch:QI 3                                  "=X,X,&r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sub.b %1,WREG
   mov.b %2,w0\;sub.b %1,WREG
   mov #%1,%3\;subr.b %2,[%3],%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;
;; half integer
;;;;;;;;;;;;;;;

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "*subhi3_imm_16"
  [(set (match_operand:HI 0 "pic30_register_operand"    "=r,r")
        (minus:HI (match_dup 0)
                  (match_operand:HI 1 "pic30_JM_operand" "J,M")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sub #%1,%0
   add #%J1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "subhi3_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
             "=r<>,R,r<>,R,  r<>,R,r<>,R,  r<>,R,r<>,R,r<>,R")
        (minus:HI 
           (match_operand:HI 1 "pic30_mode1P_operand"
              "r,  r,r,  r,  r,  r,R<>,R<>,r,  r,r,  r,P,  P")
           (match_operand:HI 2 "pic30_mode1PN_operand"
              "r,  r,R<>,R<>,r,  r,r,  r,  N,  N,P,  P,r,  r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sub %1,%2,%0
   sub %1,%2,%0
   sub %1,%2,%0
   sub %1,%2,%0
   subr %2,%1,%0
   subr %2,%1,%0
   subr %2,%1,%0
   subr %2,%1,%0
   add %1,#%J2,%0
   add %1,#%J2,%0
   sub %1,#%2,%0
   sub %1,#%2,%0
   subr %2,#%1,%0
   subr %2,#%1,%0"
  [
     (set_attr "cc" "math") ; CAW
     (set_attr "type"
  	 "def,use,defuse,use,def,use,defuse,use,def,use,def,use,def,use")
     (set_attr "op_type" "alu")
  ])

(define_insn "subhi3_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
             "=r<>,R,r<>,R,  r<>,R,r<>,R,  r<>,R,r<>,R,r<>,R")
        (minus:HI 
           (match_operand:HI 1 "pic30_mode1P_APSV_operand"
              "r,  r,r,  r,  r,  r,R<>,R<>,r,  r,r,  r,P,  P")
           (match_operand:HI 2 "pic30_mode1PN_APSV_operand"
              "r,  r,R<>,R<>,r,  r,r,  r,  N,  N,P,  P,r,  r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sub %1,%2,%0
   sub %1,%2,%0
   sub %1,%2,%0
   sub %1,%2,%0
   subr %2,%1,%0
   subr %2,%1,%0
   subr %2,%1,%0
   subr %2,%1,%0
   add %1,#%J2,%0
   add %1,#%J2,%0
   sub %1,#%2,%0
   sub %1,#%2,%0
   subr %2,#%1,%0
   subr %2,#%1,%0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type"
  	 "def,use,defuse,use,def,use,defuse,use,def,use,def,use,def,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "subp16apsv3_16"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand"
             "=r<>,R,r<>,R,  r<>,R,r<>,R,  r<>,R,r<>,R,r<>,R")
        (minus:P16APSV 
           (match_operand:P16APSV 1 "pic30_mode1P_operand"
              "r,  r,r,  r,  r,  r,R<>,R<>,r,  r,r,  r,P,  P")
           (match_operand:P16APSV 2 "pic30_mode1PN_operand"
              "r,  r,R<>,R<>,r,  r,r,  r,  N,  N,P,  P,r,  r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sub %1,%2,%0
   sub %1,%2,%0
   sub %1,%2,%0
   sub %1,%2,%0
   subr %2,%1,%0
   subr %2,%1,%0
   subr %2,%1,%0
   subr %2,%1,%0
   add %1,#%J2,%0
   add %1,#%J2,%0
   sub %1,#%2,%0
   sub %1,#%2,%0
   subr %2,#%1,%0
   subr %2,#%1,%0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type"
  	 "def,use,defuse,use,def,use,defuse,use,def,use,def,use,def,use")
    (set_attr "op_type" "alu")
  ]
)

(define_expand "subhi3_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,R,r<>,R,  r<>,R,r<>,R,  r<>,R,r<>,R,r<>,R")
        (minus:HI
           (match_operand:HI 1 "pic30_mode1P_APSV_operand"
              "r,  r,r,  r,  r,  r,R<>,R<>,r,  r,r,  r,P,  P")
           (match_operand:HI 2 "pic30_mode1PN_APSV_operand"
              "r,  r,R<>,R<>,r,  r,r,  r,  N,  N,P,  P,r,  r")))]
  "(!pic30_isa32_target())"
  "
  {
    if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_mode1PN_operand(operands[2],GET_MODE(operands[2]))) {
      emit(
        gen_subhi3_DATA_16(operands[0],operands[1],operands[2])
      );
    } else {
      emit(
        gen_subhi3_APSV_16(operands[0],operands[1],operands[2])
      );
    }
    DONE;
  }"
)

; this match_can cause issues iff operand 1 is dies in this instruction and
;   we decide to use it to reload operand 0 (CAW)
(define_insn "subhi3_sfr0_16"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand"    "+U,r")
        (minus:HI (match_dup 0)
                  (match_operand:HI 1 "pic30_wreg_operand" "a,a")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sub %0
   sub %0,%1,%0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "etc,def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn_and_split "*subhi3_sfr1_16"
  [(set (match_operand:HI 0 "pic30_register_operand"             "=a ,a, d")
        (minus:HI (match_operand:HI 1 "pic30_near_operand"       " U ,U, U")
                  (match_operand:HI 2 "pic30_register_operand"   " a ,d, d")))
   (clobber (match_scratch:HI 3                                  "=X ,X,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && (0)"
  "@
   sub %1,WREG
   mov %2,w0\;sub %1,WREG
   mov #%1,%3\;subr %2,[%3],%0"
  "reload_completed && (!pic30_isa32_target())"
  [
   (set (match_dup 3) (match_dup 1))
   (set (match_dup 0) (minus:HI (match_dup 3) (match_dup 2)))
  ]
"
{
  if (!pic30_wreg_operand(operands[0], HImode) &&
      !pic30_wreg_operand(operands[2], HImode))
  {
  }
  else
  {
  	FAIL;
  }
}
"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;
;; single integer
;;;;;;;;;;;;;;;;;

(define_insn "*subsihi3_16"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r")
        (minus:SI 
          (match_operand:SI 1 "pic30_register_operand" "r")
          (zero_extend:SI (match_operand:HI 2 "pic30_register_operand" "r"))))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sub %1,%2,%0\;subb %d1,#0,%d0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "subsip32eds3_16"
  [(set(match_operand:SI         0 "pic30_register_operand" "=&r")
       (minus:SI
         (zero_extend:SI
           (match_operand:P32EDS 1 "pic30_register_operand" "r"))
         (zero_extend:SI
           (match_operand:P32EDS 2 "pic30_register_operand" "r"))))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sl %1,%0\;sl %2,%d0\;sub %0,%d0,%0\;subb %d1,%d2,%d0\;asr %d0,%d0\;rrc %0,%0"
)

(define_insn "subsi_p32eds_16"
  [(set(match_operand:SI                 0 "pic30_register_operand" "=&r")
       (minus:SI
         (subreg:SI(match_operand:P32EDS 1 "pic30_register_operand" "r") 0)
         (subreg:SI(match_operand:P32EDS 2 "pic30_register_operand" "r") 0)))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sl %1,%0\;sl %2,%d0\;sub %0,%d0,%0\;subb %d1,%d2,%d0\;asr %d0,%d0\;rrc %0,%0"
)

(define_insn "*subsi3_imm0_16"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r,r")
        (minus:SI (match_operand:SI 1 "pic30_register_operand" "r,r")
                  (match_operand:SI 2 "pic30_PN_operand"       "N,P")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add %1,#%J2,%0\;addc %d1,#0,%d0
   sub %1,#%2,%0\;subb %d1,#0,%d0"
  [
   (set_attr "cc" "math")  ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*subsi3_imm1_16"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r")
        (minus:SI (match_operand:SI 1 "pic30_P_operand"        "P")
                  (match_operand:SI 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "subr %2,#%1,%0\;subbr %d2,#0,%d0"
  [
   (set_attr "cc" "math")  ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*subsi3_imm2_16"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r,r")
        (minus:SI (match_operand:SI 1 "pic30_register_operand" "0,0")
                  (match_operand:SI 2 "pic30_JM_operand"       "J,M")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sub %0,#%2\;subb %d0,#0
   add #%J2,%0\;addc #0,%d0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "subsi3_errata_16"
  [(set (match_operand:SI   0 "pic30_reg_or_R_operand" "=r,r,r,&r,R,R,R,&r,R,R")
        (minus:SI 
          (match_operand:SI 1 "pic30_reg_or_R_operand" " r,0,r, r,r,r,r, R,0,R")
          (match_operand:SI 2 "pic30_reg_or_R_operand" " r,r,0, R,r,0,R, r,r,r")
   ))
   (clobber (match_scratch:HI 3                       "=X,X,X,&r,X,&r,&r,X,X,X")
   )
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && (pic30_errata_mask & psv_errata)"
  "*
   {
     static const char *patterns[] = {
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%I2,%0\;mov %D2,%3\;subb %d1,%3,%d0\",
       \"sub %1,%2,%I0\;subb %d1,%d2,%D0\",
       \"sub %1,%2,%I0\;mov %2,%3\;subb %d1,%3,%D0\",
       \"sub %1,%I2,%I0\;mov %D2,%3\;subb %d1,%3,%D0\",
       \"subr %2,%I1,%0\;subbr %d2,%D1,%d0\",
       \"subr %2,%1,%I0\;subbr %d2,%1,%D0\",
       \"subr %2,%I1,%I0\;subbr %d2,%D1,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%I2,%0\;nop\;mov %D2,%3\;subb %d1,%3,%d0\",
       \"sub %1,%2,%I0\;subb %d1,%d2,%D0\",
       \"sub %1,%2,%I0\;mov %2,%3\;subb %d1,%3,%D0\",
       \"sub %1,%I2,%I0\;nop\;mov %D2,%3\;subb %d1,%3,%D0\",
       \"subr %2,%I1,%0\;nop\;subbr %d2,%D1,%d0\",
       \"subr %2,%1,%I0\;subbr %d2,%1,%D0\",
       \"subr %2,%I1,%I0\;nop\;subbr %d2,%D1,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "def,def,def,defuse,use,use,use,defuse,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "subsi3_noerrata_16"
  [(set (match_operand:SI   0 "pic30_reg_or_R_operand" "=r,r,r,&r,R,R,R,&r,R,R")
        (minus:SI 
          (match_operand:SI 1 "pic30_reg_or_R_operand" "r,0,r, r,r,r,r,  R,0,R")
          (match_operand:SI 2 "pic30_reg_or_R_operand" "r,r,0, R,r,0,R, r,r,r")
   ))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     static const char *patterns[] = {
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%I2,%0\;subb %d1,%D2,%d0\",
       \"sub %1,%2,%I0\;subb %d1,%d2,%D0\",
       \"sub %1,%2,%I0\;subb %d1,%2,%D0\",
       \"sub %1,%I2,%I0\;subb %d1,%D2,%D0\",
       \"subr %2,%I1,%0\;subbr %d2,%D1,%d0\",
       \"subr %2,%1,%I0\;subbr %d2,%1,%D0\",
       \"subr %2,%I1,%I0\;subbr %d2,%D1,%D0\"
     };

     static const char *psv_psv_patterns[] = {
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%2,%0\;subb %d1,%d2,%d0\",
       \"sub %1,%I2,%0\;nop\;subb %d1,%D2,%d0\",
       \"sub %1,%2,%I0\;subb %d1,%d2,%D0\",
       \"sub %1,%2,%I0\;subb %d1,%2,%D0\",
       \"sub %1,%I2,%I0\;nop\;subb %d1,%D2,%D0\",
       \"subr %2,%I1,%0\;nop\;subbr %d2,%D1,%d0\",
       \"subr %2,%1,%I0\;subbr %d2,%1,%D0\",
       \"subr %2,%I1,%I0\;nop\;subbr %d2,%D1,%D0\"
     };

     if (pic30_psrd_psrd_errata(operands[1],operands[2])) {
       pic30_rtx_nops++;
       return psv_psv_patterns[which_alternative];
     } else {
       return patterns[which_alternative];
     }
   }"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "def,def,def,defuse,use,use,use,defuse,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_expand "subsi3_16"
  [(set (match_operand:SI   0 "pic30_reg_or_R_operand" "")
        (minus:SI 
          (match_operand:SI 1 "pic30_reg_or_R_operand" "")
          (match_operand:SI 2 "pic30_reg_or_R_operand" "")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (!pic30_reg_or_R_operand(operands[0],SImode)) {
    operands[0] = force_reg(SImode,operands[0]);
  }
  if (!pic30_reg_or_R_operand(operands[1],SImode)) {
    operands[1] = force_reg(SImode,operands[1]);
  }
  if (!pic30_reg_or_R_operand(operands[2],SImode)) {
    operands[2] = force_reg(SImode,operands[2]);
  }

  if (pic30_errata_mask & psv_errata) {
    emit(
      gen_subsi3_errata_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_subsi3_noerrata_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

;;;;;;;;;;;;;;;;;
;; double integer
;;;;;;;;;;;;;;;;;

(define_insn "*subdi3_imm_16"
  [(set (match_operand:DI 0 "pic30_register_operand"           "=r,r")
        (minus:DI (match_operand:DI 1 "pic30_register_operand" " 0,0")
                  (match_operand:DI 2 "pic30_JM_operand"       " J,M")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sub %0,#%2\;subb %d0,#0\;subb %t0,#0\;subb %q0,#0
   add #%J2,%0\;addc #0,%d0\;addc #0,%t0\;addc #0,%q0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*subhidi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (sign_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                  "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;sub %1,%2,%0\;subb %3,%d2,%d0\;\"
                              \"subb %3,%t2,%t0\;subb %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;sub %1,%2,%0\;subb %3,%d2,%0\;\"
                              \"subb %3,%t2,%0\;subb %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;sub %1,%s2,%0\;subb %3,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;sub %1,%2,%0\;subb %3,%2,%0\;\"
                              \"subb %3,%2,%0\;subb %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;sub %1,%2,%0\;subb %3,%2,%d0\;\"
                              \"subb %3,%2,%t0\;subb %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;sub %1,%2,%I0\;subb %3,%d2,%I0\;\"
                              \"subb %3,%t2,%I0\;subb %3,%q2,%0\",

     /* R,r,0 */          \"asr %1,#15,%3\;sub %1,%2,%I0\;subb %3,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"asr %1,#15,%3\;sub %1,%I2,%I0\;subb %3,%I2,%I0\;\"
                              \"subb %3,%I2,%I0\;subb %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;sub %1,%I2,%0\;subb %3,%I2,%d0\;\"
                              \"subb %3,%I2,%t0\;subb %3,%2,%q0\",
  };

   const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;sub %1,%2,%0\;subb %3,%d2,%d0\;\"
                              \"subb %3,%t2,%t0\;subb %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;sub %1,%2,%0\;subb %3,%d2,%0\;\"
                              \"subb %3,%t2,%0\;subb %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;sub %1,%s2,%0\;subb %3,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;sub %1,%2,%I0\;subb %3,%d2,%I0\;\"
                              \"subb %3,%t2,%I0\;subb %3,%q2,%0\",

     /* R,r,0 */          \"asr %1,#15,%3\;sub %1,%2,%I0\;subb %3,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"asr %1,#15,%3\;\"
                          \"sub %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;\"
                          \"sub %1,%I2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*subhidi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (zero_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subbr %d2,#0,%d0\;\"
                              \"subbr %t2,#0,%t0\;subbr %q2,#0,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subbr %d2,#0,%0\;\"
                              \"subbr %t2,#0,%0\;subbr %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;sub %1,%s2,%0\;subb %3,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;sub %1,%2,%0\;subb %3,%2,%0\;\"
                              \"subb %3,%2,%0\;subb %3,%2,%0\",

     /* r,r,> */          \"clr %3\;sub %1,%2,%0\;subb %3,%2,%d0\;\"
                              \"subb %3,%2,%t0\;subb %3,%2,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subbr %d2,#0,%I0\;\"
                              \"subbr %t2,#0,%I0\;subbr %q2,#0,%0\",

     /* R,r,0 */          \"clr %3\;sub %1,%2,%I0\;subb %3,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"clr %3\;sub %1,%I2,%I0\;subb %3,%I2,%I0\;\"
                              \"subb %3,%I2,%I0\;subb %3,%2,%0\",

     /* r,r,R */          \"clr %3\;sub %1,%I2,%0\;subb %3,%I2,%d0\;\"
                              \"subb %3,%I2,%t0\;subb %3,%2,%q0\",
  };

   const char *psv_psv_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subbr %d2,#0,%d0\;\"
                              \"subbr %t2,#0,%t0\;subbr %q2,#0,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subbr %d2,#0,%0\;\"
                              \"subbr %t2,#0,%0\;subbr %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;sub %1,%s2,%0\;subb %3,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,> */          \"clr %3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subbr %d2,#0,%I0\;\"
                              \"subbr %t2,#0,%I0\;subbr %q2,#0,%0\",

     /* R,r,0 */          \"clr %3\;sub %1,%2,%I0\;subb %3,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"clr %3\;\"
                          \"sub %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,R */          \"clr %3\;\"
                          \"sub %1,%I2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*subsidi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (sign_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                  "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subb %3,%t2,%t0\;subb %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subb %3,%t2,%0\;subb %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;sub %1,%s2,%0\;subb %d1,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;sub %1,%2,%0\;subb %d1,%2,%0\;\"
                              \"subb %3,%2,%0\;subb %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;sub %1,%2,%0\;subb %d1,%2,%d0\;\"
                              \"subb %3,%2,%t0\;subb %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subb %3,%t2,%I0\;subb %3,%q2,%s0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;sub %1,%2,%I0\;subb %d1,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"asr %d1,#15,%3\;sub %1,%I2,%I0\;subb %d1,%I2,%I0\;\"
                              \"subb %3,%I2,%I0\;subb %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;sub %1,%I2,%0\;subb %d1,%I2,%d0\;\"
                              \"subb %3,%I2,%t0\;subb %3,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subb %3,%t2,%t0\;subb %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subb %3,%t2,%0\;subb %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;sub %1,%s2,%0\;subb %d1,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subb %3,%t2,%I0\;subb %3,%q2,%s0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;sub %1,%2,%I0\;subb %d1,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"asr %d1,#15,%3\;\"
                          \"sub %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;\"
                          \"sub %1,%I2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",
  };


  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }  

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*subsidi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (zero_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subbr %t2,#0,%t0\;subbr %q2,#0,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subbr %t2,#0,%0\;subbr %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;sub %1,%s2,%0\;subb %d1,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;sub %1,%2,%0\;subb %d1,%2,%0\;\"
                              \"subb %3,%2,%0\;subb %3,%2,%0\",

     /* r,r,> */          \"clr %3\;sub %1,%2,%0\;subb %d1,%2,%d0\;\"
                              \"subb %3,%2,%t0\;subb %3,%2,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subbr %t2,#0,%I0\;subbr %q2,#0,%0\",

     /* R,r,0 */          \"clr %3\;sub %1,%2,%I0\;subb %d1,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"clr %3\;sub %1,%I2,%I0\;subb %d1,%I2,%I0\;\"
                              \"subb %3,%I2,%I0\;subb %3,%2,%0\",

     /* r,r,R */          \"clr %3\;sub %1,%I2,%0\;subb %d1,%I2,%d0\;\"
                              \"subb %3,%I2,%t0\;subb %3,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subbr %t2,#0,%t0\;subbr %q2,#0,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subbr %t2,#0,%0\;subbr %q2,#0,%0\",

     /* >,r,0 */          \"clr %3\;sub %1,%s2,%0\;subb %d1,%s2,%0\;\"
                              \"subb %3,%s2,%0\;subb %3,%s2,%0\",

     /* >,r,> */          \"clr %3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,> */          \"clr %3\;\"
                          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subbr %t2,#0,%I0\;subbr %q2,#0,%0\",

     /* R,r,0 */          \"clr %3\;sub %1,%2,%I0\;subb %d1,%2,%I0\;\"
                              \"subb %3,%2,%I0\;subb %3,%2,%0\",

     /* R,r,R */          \"clr %3\;\"
                          \"sub %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%0\",

     /* r,r,R */          \"clr %3\;\"
                          \"sub %1,%I2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"subb %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"subb %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*subdihi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
))
   (clobber (match_scratch:HI 3                  "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;sub %1,%2,%0\;subb %d1,%3,%d0\;\"
                              \"subb %t1,%3,%t0\;subb %q1,%3,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;sub %1,%2,%0\;subb %d1,%3,%0\;\"
                              \"subb %t1,%3,%0\;subb %q1,%3,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;subr %2,%s1,%0\;subbr %3,%s1,%0\;\"
                              \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;subr %2,%1,%0\;subbr %3,%1,%0\;\"
                              \"subbr %3,%1,%0\;subbr %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;subr %2,%1,%0\;subbr %3,%1,%d0\;\"
                              \"subbr %3,%1,%t0\;subbr %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;sub %2,%1,%I0\;subbr %3,%d1,%I0\;\"
                              \"subbr %3,%t1,%I0\;subbr %3,%q1,%0\",

     /* R,0,r */          \"asr %2,#15,%3\;subr %2,%1,%I0\;subbr %3,%1,%I0\;\"
                              \"subbr %3,%1,%I0\;subbr %3,%1,%0\",

     /* R,R,r */          \"asr %2,#15,%3\;subr %2,%I1,%I0\;subbr %3,%I1,%I0\;\"
                              \"subbr %3,%I1,%I0\;subbr %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;subr %2,%I1,%0\;subbr %3,%I1,%d0\;\"
                              \"subbr %3,%I1,%t0\;subbr %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;sub %1,%2,%0\;subb %d1,%3,%d0\;\"
                              \"subb %t1,%3,%t0\;subb %q1,%3,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;sub %1,%2,%0\;subb %d1,%3,%0\;\"
                              \"subb %t1,%3,%0\;subb %q1,%3,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;subr %2,%s1,%0\;subbr %3,%s1,%0\;\"
                              \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;sub %2,%1,%I0\;subbr %3,%d1,%I0\;\"
                              \"subbr %3,%t1,%I0\;subbr %3,%q1,%0\",

     /* R,0,r */          \"asr %2,#15,%3\;subr %2,%1,%I0\;subbr %3,%1,%I0\;\"
                              \"subbr %3,%1,%I0\;subbr %3,%1,%0\",

     /* R,R,r */          \"asr %2,#15,%3\;\"
                          \"subr %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;\"
                          \"subr %2,%I1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*subdihi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
))
   (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,#0,%d0\;\"
                            \"subb %t1,#0,%t0\;subb %q1,#0,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,#0,%0\;\"
                            \"subb %t1,#0,%0\;subb %q1,#0,%0\",

     /* >,0,r */          \"clr %3\;subr %2,%s1,%0\;subbr %3,%s1,%0\;\"
                            \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",

     /* >,>,r */          \"clr %3\;subr %2,%1,%0\;subbr %3,%1,%0\;\"
                            \"subbr %3,%1,%0\;subbr %3,%1,%0\",

     /* r,>,r */          \"clr %3\;subr %2,%1,%0\;subbr %3,%1,%d0\;\"
                            \"subbr %3,%1,%t0\;subbr %3,%1,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subbr %d1,#0,%I0\;\"
                            \"subbr %t1,#0,%I0\;subbr %q1,#0,%0\",

     /* R,0,r */          \"clr %3\;subr %2,%1,%I0\;subbr %3,%1,%I0\;\"
                            \"subbr %3,%1,%I0\;subbr %3,%1,%0\",

     /* R,R,r */          \"clr %3\;subr %2,%I1,%I0\;subbr %3,%I1,%I0\;\"
                            \"subbr %3,%I1,%I0\;subbr %3,%1,%0\",

     /* r,R,r */          \"clr %3\;subr %2,%I1,%0\;subbr %3,%I1,%d0\;\"
                              \"subbr %3,%I1,%t0\;subbr %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,#0,%d0\;\"
                            \"subb %t1,#0,%t0\;subb %q1,#0,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,#0,%0\;\"
                            \"subb %t1,#0,%0\;subb %q1,#0,%0\",

     /* >,0,r */          \"clr %3\;subr %2,%s1,%0\;subbr %3,%s1,%0\;\"
                            \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",

     /* >,>,r */          \"clr %3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",

     /* r,>,r */          \"clr %3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subbr %d1,#0,%I0\;\"
                            \"subbr %t1,#0,%I0\;subbr %q1,#0,%0\",

     /* R,0,r */          \"clr %3\;subr %2,%1,%I0\;subbr %3,%1,%I0\;\"
                            \"subbr %3,%1,%I0\;subbr %3,%1,%0\",

     /* R,R,r */          \"clr %3\;\"
                          \"subr %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",

     /* r,R,r */          \"clr %3\;\"
                          \"subr %2,%I1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",
  };


  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*subdisi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
))
   (clobber (match_scratch:HI 3                  "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                             \"subb %t1,%3,%t0\;subb %q1,%3,%q0\",
             
     /* >,r,r */          \"asr %d2,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                             \"subb %t1,%3,%0\;subb %q1,%3,%0\",
             
     /* >,0,r */          \"asr %d2,#15,%3\;subr %2,%s1,%0\;subbr %d2,%s1,%0\;\"
                             \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",
             
     /* >,>,r */          \"asr %d2,#15,%3\;subr %2,%1,%0\;subbr %d2,%1,%0\;\"
                             \"subbr %3,%1,%0\;subbr %3,%1,%0\",
             
     /* r,>,r */          \"asr %d2,#15,%3\;subr %2,%1,%0\;subbr %d2,%1,%d0\;\"
                             \"subbr %3,%1,%t0\;subbr %3,%1,%q0\",
             
     /* R,r,r */          \"asr %d2,#15,%3\;sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                             \"subb %t1,%3,%I0\;subb %q1,%3,%s0\",
             
     /* R,0,r */          \"asr %d2,#15,%3\;subr %2,%1,%I0\;subbr %d2,%1,%I0\;\"
                             \"subbr %3,%1,%I0\;subbr %3,%1,%0\",
             
     /* R,R,r */          \"asr %d2,#15,%3\;subr %2,%I1,%I0\;subbr %d2,%I1,%I0\;\"
                             \"subbr %3,%I1,%I0\;subbr %3,%1,%0\",
             
     /* r,R,r */          \"asr %d2,#15,%3\;subr %2,%I1,%0\;subbr %d2,%I1,%d0\;\"
                              \"subbr %3,%I1,%t0\;subbr %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                             \"subb %t1,%3,%t0\;subb %q1,%3,%q0\",
             
     /* >,r,r */          \"asr %d2,#15,%3\;sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                             \"subb %t1,%3,%0\;subb %q1,%3,%0\",
             
     /* >,0,r */          \"asr %d2,#15,%3\;subr %2,%s1,%0\;subbr %d2,%s1,%0\;\"
                             \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",
             
     /* >,>,r */          \"asr %d2,#15,%3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %d2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",
             
     /* r,>,r */          \"asr %d2,#15,%3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",
             
     /* R,r,r */          \"asr %d2,#15,%3\;sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                             \"subb %t1,%3,%I0\;subb %q1,%3,%s0\",
             
     /* R,0,r */          \"asr %d2,#15,%3\;subr %2,%1,%I0\;subbr %d2,%1,%I0\;\"
                             \"subbr %3,%1,%I0\;subbr %3,%1,%0\",
             
     /* R,R,r */          \"asr %d2,#15,%3\;\"
                          \"subr %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",
             
     /* r,R,r */          \"asr %d2,#15,%3\;\"
                          \"subr %2,%I1,%0\;\"
                          \"nop\;\"
                          \"subbr %d2,%I1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }  

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*subdisi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
))
   (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subb %t1,#0,%t0\;subb %q1,#0,%q0\",
             
     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subb %t1,#0,%0\;subb %q1,#0,%s0\",
             
     /* >,0,r */          \"clr %3\;subr %2,%s1,%0\;subbr %d2,%s1,%0\;\"
                              \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",
             
     /* >,>,r */          \"clr %3\;subr %2,%1,%0\;subbr %d2,%1,%0\;\"
                              \"subbr %3,%1,%0\;subbr %3,%1,%0\",
             
     /* r,>,r */          \"clr %3\;subr %2,%1,%0\;subbr %d2,%1,%d0\;\"
                              \"subbr %3,%1,%t0\;subbr %3,%1,%q0\",
             
     /* R,r,r */          \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subb %t1,#0,%I0\;subb %q1,#0,%0\",
             
     /* R,0,r */          \"clr %3\;subr %2,%1,%I0\;subbr %d2,%1,%I0\;\"
                              \"subbr %3,%1,%I0\;subbr %3,%1,%0\",
             
     /* R,R,r */          \"clr %3\;subr %2,%I1,%I0\;subbr %d2,%I1,%I0\;\"
                              \"subbr %3,%I1,%I0\;subbr %3,%1,%0\",
             
     /* r,R,r */          \"clr %3\;subr %2,%I1,%0\;subbr %d2,%I1,%d0\;\"
                              \"subbr %3,%I1,%t0\;subbr %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subb %t1,#0,%t0\;subb %q1,#0,%q0\",
             
     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subb %t1,#0,%0\;subb %q1,#0,%s0\",
             
     /* >,0,r */          \"clr %3\;subr %2,%s1,%0\;subbr %d2,%s1,%0\;\"
                              \"subbr %3,%s1,%0\;subbr %3,%s1,%0\",
             
     /* >,>,r */          \"clr %3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %d2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",
             
     /* r,>,r */          \"clr %3\;\"
                          \"subr %2,%1,%0\;\"
                          \"nop\;\"
                          \"subbr %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",
             
     /* R,r,r */          \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subb %t1,#0,%I0\;subb %q1,#0,%0\",
             
     /* R,0,r */          \"clr %3\;subr %2,%1,%I0\;subbr %d2,%1,%I0\;\"
                              \"subbr %3,%1,%I0\;subbr %3,%1,%0\",
             
     /* R,R,r */          \"clr %3\;\"
                          \"subr %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%0\",
             
     /* r,R,r */          \"clr %3\;\"
                          \"subr %2,%I1,%0\;\"
                          \"nop\;\"
                          \"subbr %d2,%I1,%d0\;\"
                          \"nop\;\"
                          \"subbr %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"subbr %3,%1,%q0\",
  };


  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "subdi3_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (minus:DI
           (match_operand:DI 1 "pic30_register_operand"    "r,r,r,r, r,r,r,r, r")
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subb %t1,%t2,%t0\;subb %q1,%q2,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subb %t1,%t2,%0\;subb %q1,%q2,%0\",

     /* >,r,0 */          \"sub %1,%s2,%0\;subb %d1,%s2,%0\;\"
                              \"subb %t1,%s2,%0\;subb %q1,%s2,%0\",

     /* >,r,> */          \"sub %1,%2,%0\;subb %d1,%2,%0\;\"
                              \"subb %t1,%2,%0\;subb %q1,%2,%0\",

     /* r,r,> */          \"sub %1,%2,%0\;subb %d1,%2,%d0\;\"
                              \"subb %t1,%2,%t0\;subb %q1,%2,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subb %t1,%t2,%I0\;subb %q1,%q2,%0\",

     /* R,r,0 */          \"sub %1,%2,%I0\;subb %d1,%2,%I0\;\"
                              \"subb %t1,%2,%I0\;subb %q1,%2,%0\",

     /* R,r,R */          \"sub %1,%I2,%I0\;subb %d1,%I2,%I0\;\"
                              \"subb %t1,%I2,%I0\;subb %q1,%2,%0\",

     /* r,r,R */          \"sub %1,%I2,%0\;subb %d1,%I2,%d0\;\"
                              \"subb %t1,%I2,%t0\;subb %q1,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%d0\;\"
                              \"subb %t1,%t2,%t0\;subb %q1,%q2,%q0\",

     /* >,r,r */          \"sub %1,%2,%0\;subb %d1,%d2,%0\;\"
                              \"subb %t1,%t2,%0\;subb %q1,%q2,%0\",

     /* >,r,0 */          \"sub %1,%s2,%0\;subb %d1,%s2,%0\;\"
                              \"subb %t1,%s2,%0\;subb %q1,%s2,%0\",

     /* >,r,> */          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %t1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %q1,%2,%0\",

     /* r,r,> */          \"sub %1,%2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"subb %t1,%2,%t0\;\"
                          \"nop\;\"
                          \"subb %q1,%2,%q0\",

     /* R,r,r */          \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;\"
                              \"subb %t1,%t2,%I0\;subb %q1,%q2,%0\",

     /* R,r,0 */          \"sub %1,%2,%I0\;subb %d1,%2,%I0\;\"
                              \"subb %t1,%2,%I0\;subb %q1,%2,%0\",

     /* R,r,R */          \"sub %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %t1,%I2,%I0\;\"
                          \"nop\;\"
                          \"subb %q1,%2,%0\",

     /* r,r,R */          \"sub %1,%I2,%0\;\"
                          \"nop\;\"
                          \"subb %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"subb %t1,%I2,%t0\;\"
                          \"nop\;\"
                          \"subb %q1,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; multiply instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 16-bit product

;; 8 x 8 => 16 (unsigned)

(define_insn "umulqihi3gen_16"
  [(set (match_operand:HI     0 "pic30_creg_operand"       "=c,c")
        (mult:HI 
          (zero_extend:HI 
            (match_operand:QI 1 "pic30_wreg_operand"       "%a,a"))
          (zero_extend:HI 
            (match_operand:QI 2 "pic30_reg_or_near_operand" "r,U"))))]
  "(!pic30_isa32_target())"
  "@
   mul.b %m2
   mul.b %2"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "umulqihi3imm_16"
  [(set (match_operand:HI 0 "pic30_creg_operand" "=c")
        (mult:HI 
          (zero_extend:HI (match_operand:QI 1 "pic30_wreg_operand" "%a"))
          (match_operand:HI 2 "immediate_operand" "i")))
  ]
; Ensure the operand fits in a byte
  "(((INTVAL(operands[2])) & 0xFF) == (INTVAL(operands[2])))"
  "mov.b #%2,%0\;mul.b %m0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "umulqihi3pow2_16"
  [(set (match_operand:HI 0 "pic30_register_operand"                   "=r")
        (mult:HI 
          (zero_extend:HI (match_operand:QI 1 "pic30_register_operand" "%r"))
          (match_operand:HI 2 "immediate_operand"                       "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1))"
  "ze %1,%0\;sl %0,#%b2,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;; 16 x 16 => 16

;; this expansion is helpful in constant propagation
;; (but in general, it leads to code expansion, since
;; it causes all integer multiplication to be inline)

(define_expand "mulhi3_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "")
        (mult:HI (match_operand:HI 1 "pic30_register_operand" "")
                 (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))]
  "(!pic30_isa32_target())"
  "
{ rtx temp_reg = 0, temp_opnd1 = 0, temp_opnd2 = 0;
  int valid_immediate = 0;

  if (immediate_operand(operands[2], VOIDmode)) {
    if (INTVAL(operands[2]) == 2) {
      emit_insn(
        gen_mulhi3imm_16(operands[0], operands[1], operands[2])
      );
      DONE;
    } else if (pic30_P_operand(operands[2],VOIDmode)) {
      valid_immediate = 1;
    } else {
      temp_opnd2  = gen_reg_rtx(HImode);

      emit_move_insn(temp_opnd2, operands[2]);
    }
  }
  if (pic30_ecore_target() || pic30_isav4_target()) {
    if (valid_immediate) {
      emit_insn(
        gen_mulhi3imm_16(operands[0],
                        temp_opnd1 ? temp_opnd1 : operands[1],
                        temp_opnd2 ? temp_opnd2 : operands[2])
      );
    } else {
      emit_insn(
        gen_emulhi3_16(operands[0],
                    temp_opnd1 ? temp_opnd1 : operands[1],
                    temp_opnd2 ? temp_opnd2 : operands[2])
      );
    }
  } else {
    temp_reg = gen_reg_rtx(SImode);
    if (valid_immediate) {
      emit_insn(
        gen_mulhisi3_imm_16(temp_reg,
                         temp_opnd1 ? temp_opnd1 : operands[1],
                         temp_opnd2 ? temp_opnd2 : operands[2])
      );
    } else {
      emit_insn(
        gen_mulhisi3_16(temp_reg,
                     temp_opnd1 ? temp_opnd1 : operands[1],
                     temp_opnd2 ? temp_opnd2 : operands[2])
      );
    }
    convert_move(operands[0], temp_reg, 0);
  }
  DONE;
}")

(define_expand "mulp16apsv3_16"
  [(set (match_operand:P16APSV 0 "pic30_register_operand" "")
        (mult:P16APSV 
          (match_operand:P16APSV 1 "pic30_reg_or_near_operand" "")
          (match_operand:P16APSV 2 "pic30_reg_or_imm_operand" "")))]
  "(!pic30_isa32_target())"
  "
{ rtx temp_reg = 0, temp_opnd1 = 0, temp_opnd2 = 0;
  int valid_immediate = 0;

  if (immediate_operand(operands[2], VOIDmode)) {
    if (INTVAL(operands[2]) == 2) {
      emit_insn(
        gen_mulp16apsvsi3_imm_16(operands[0], operands[1], operands[2])
      );
      DONE;
    } else if (pic30_P_operand(operands[2],VOIDmode)) {
      valid_immediate = 1;
    } else {
      temp_opnd2  = gen_reg_rtx(HImode);

      emit_move_insn(temp_opnd2, operands[2]);
    }
  }
  if (pic30_near_operand(operands[1], HImode)) {
    temp_opnd1 = gen_reg_rtx(HImode);
    
    emit_move_insn(temp_opnd1, operands[1]);
  }
  if (pic30_ecore_target() || pic30_isav4_target()) {
    if (valid_immediate) {
      emit_insn(
        gen_mulp16apsv3_imm_16(operands[0],
                             temp_opnd1 ? temp_opnd1 : operands[1],
                             temp_opnd2 ? temp_opnd2 : operands[2])
      );
    } else {
      emit_insn(
        gen_mulp16apsv3_16(operands[0],
                         temp_opnd1 ? temp_opnd1 : operands[1],
                         temp_opnd2 ? temp_opnd2 : operands[2])
      );
    }
  } else {
    temp_reg = gen_reg_rtx(SImode);
    if (valid_immediate) {
      emit_insn(
        gen_mulp16apsvsi3_imm_16(temp_reg,
                              temp_opnd1 ? temp_opnd1 : operands[1],
                              temp_opnd2 ? temp_opnd2 : operands[2])
      );
    } else {
      emit_insn(
        gen_mulp16apsvsi3_16(temp_reg,
                          temp_opnd1 ? temp_opnd1 : operands[1],
                          temp_opnd2 ? temp_opnd2 : operands[2])
      );
    }
    convert_move(operands[0], temp_reg, 0);
  }
  DONE;
}")

(define_insn "mulhi3imm_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"         "=a,r<>,r<>,R,R")
        (mult:HI 
            (match_operand:HI 1 "pic30_near_mode2_operand" "U,r,  R<>,r,R<>")
            (match_operand:HI 2 "immediate_operand"        "i,i,  i,  i,i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(INTVAL(operands[2]) == 2)"
  "@
     sl %1,WREG
     sl %1,%0
     sl %1,%0
     sl %1,%0
     sl %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulhi3imm_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"              "=a,r<>,r<>,R,R")
        (mult:HI 
          (match_operand:HI 1 "pic30_near_mode2_APSV_operand" "U,r,R<>,r,R<>")
          (match_operand:HI 2 "immediate_operand"             "i,i,  i,  i,i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(INTVAL(operands[2]) == 2)"
  "@
     sl %1,WREG
     sl %1,%0
     sl %1,%0
     sl %1,%0
     sl %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "mulhi3imm_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand" "=a,r<>,r<>,R,R")
        (mult:HI
            (match_operand:HI 1 "pic30_near_mode2_APSV_operand" "U,r,R<>,r,R<>")
            (match_operand:HI 2 "immediate_operand" "i,i,  i,  i,i")))]
  "(INTVAL(operands[2]) == 2)"
  "
{
  if (pic30_near_mode2_operand(operands[1],GET_MODE(operands[1]))) {
    emit(
      gen_mulhi3imm_DATA_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
     gen_mulhi3imm_APSV_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

; 32-bit product
; /* *_extend of an immediate_operand is illegal, apparantly 
;    so need two separate sequences */

(define_insn "umulhisi3imm_16"
  [(set (match_operand:SI 0 "pic30_register_operand"      "=r")
        (mult:SI 
          (zero_extend:SI 
             (match_operand:HI 1 "pic30_register_operand" "%r"))
          (match_operand:SI 2 "pic30_P_operand"            "P")))]
  "(!pic30_isa32_target())"
  "mul.uu %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "umulhisi3_DATA_16"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (mult:SI 
          (zero_extend:SI 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:SI 
            (match_operand:HI 2 "pic30_mode2_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "mul.uu %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "umulhisi3_APSV_16"
  [(set (match_operand:SI     0 "pic30_register_operand"  "=r,r")
        (mult:SI 
          (zero_extend:SI 
            (match_operand:HI 1 "pic30_register_operand"  "%r,r"))
          (zero_extend:SI 
            (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>"))))]
  "(!pic30_isa32_target())"
  "mul.uu %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "umulhisi3_16"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (mult:SI
          (zero_extend:SI
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:SI
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_operand(operands[2], GET_MODE(operands[2]))) {
    emit(
      gen_umulhisi3_DATA_16(operands[0], operands[1], operands[2])
    );
  } else {
    emit(
      gen_umulhisi3_APSV_16(operands[0], operands[1], operands[2])
    );
  }
  DONE;
}")

(define_insn "mulp16apsv3imm_DATA_16"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand"       "=a,r<>,r<>,R,R")
        (mult:P16APSV 
          (match_operand:P16APSV 1 "pic30_near_mode2_operand" "U,r,  R<>,r,R<>")
          (match_operand:P16APSV 2 "immediate_operand"        "i,i,  i,  i,i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(INTVAL(operands[2]) == 2)"
  "@
     sl %1,WREG
     sl %1,%0
     sl %1,%0
     sl %1,%0
     sl %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulp16apsv3imm_APSV_16"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand"         "=a,r<>,r<>,R,R")
        (mult:P16APSV 
            (match_operand:P16APSV 1 "pic30_near_mode2_APSV_operand" "U,r,R<>,r,R<>")
            (match_operand:P16APSV 2 "immediate_operand" "i,i,  i,  i,i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(INTVAL(operands[2]) == 2)"
  "@
     sl %1,WREG
     sl %1,%0
     sl %1,%0
     sl %1,%0
     sl %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "emulp16apsv3imm_16"
  [(set (match_operand:P16APSV 0 "pic30_mode2_operand" "=a,D<>,D<>,R,R")
        (mult:P16APSV
          (match_operand:P16APSV 1 "pic30_near_mode2_APSV_operand" "U,D,R<>,D,R<>")
          (match_operand:P16APSV 2 "immediate_operand" "i,i,  i,  i,i")))]
  "(INTVAL(operands[2]) == 2) && (pic30_ecore_target() || pic30_isav4_target())"
  "
{
  if (pic30_near_mode2_operand(operands[1],GET_MODE(operands[1]))) {
    emit(
      gen_mulp16apsv3imm_DATA_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_mulp16apsv3imm_APSV_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

; 32-bit product
; /* *_extend of an immediate_operand is illegal, apparantly 
;    so need two separate sequences */

(define_insn "umulp16apsvsi3imm_16"
  [(set (match_operand:SI 0 "pic30_register_operand"                      "=r")
    (mult:SI 
       (zero_extend:SI (match_operand:P16APSV 1 "pic30_register_operand" "%r"))
       (match_operand:SI 2 "pic30_P_operand"                              "P")))
  ]
  "(!pic30_isa32_target())"
  "mul.uu %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*umulp16apsvsi3sfr_16"
  [(set (match_operand:SI     0 "pic30_register_operand"         "=C,C,&r,r")
        (mult:SI 
          (zero_extend:SI 
            (match_operand:P16APSV 1 "pic30_wreg_operand"        "%a,a, a,a"))
          (zero_extend:SI 
            (match_operand:P16APSV 2 "pic30_reg_or_near_operand" " r,U, U,r"))))]
  "(!pic30_isa32_target())"
  "@
   mul.w %m2
   mul.w %2
   mov %2,%0\;mul.uu %1,%0,%0
   mul.uu %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;; 16 x 16 => 32 (signed)

;; /* *_extend of an immediate_operand is illegal, apparantly -
;;   so need separate patterns */

(define_insn "mulhisi3_imm_16"
  [(set (match_operand:SI 0 "pic30_register_operand"    "=r")
        (mult:SI 
          (sign_extend:SI (match_operand:HI 1 "pic30_register_operand" "%r"))
                          (match_operand:SI 2 "pic30_P_operand"        "P")))]
  "(!pic30_isa32_target())"
  "mul.su %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulhisi3_DATA_16"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (mult:SI 
          (sign_extend:SI 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (sign_extend:SI 
            (match_operand:HI 2 "pic30_mode2_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "mul.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulhisi3_APSV_16"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (mult:SI 
          (sign_extend:SI 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (sign_extend:SI 
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "mul.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "mulhisi3_16"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (mult:SI
          (sign_extend:SI
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (sign_extend:SI
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_mulhisi3_DATA_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_mulhisi3_APSV_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

(define_insn "mulp16apsvsi3_imm_16"
  [(set (match_operand:SI 0 "pic30_register_operand"    "=r")
        (mult:SI 
          (sign_extend:SI (match_operand:P16APSV 1 "pic30_register_operand" "%r"))
                          (match_operand:SI 2 "pic30_P_operand"        "P")))]
  "(!pic30_isa32_target())"
  "mul.su %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulp16apsvsi3_DATA_16"
  [(set (match_operand:SI  0 "pic30_accum_or_reg_operand" "=r,r, w")
        (mult:SI 
          (sign_extend:SI 
            (match_operand 1 "pic30_register_operand"     "%r,r, za"))
          (sign_extend:SI 
            (match_operand 2 "pic30_mode2_operand"        "r,R<>,za"))))]
  "(!pic30_isa32_target())"
  "@
   mul.ss %1,%2,%0
   mul.ss %1,%2,%0
   mpy %1*%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse,def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulp16apsvsi3_APSV_16"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (mult:SI 
          (sign_extend:SI 
            (match_operand 1 "pic30_register_operand" "%r,r"))
          (sign_extend:SI 
            (match_operand 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "mul.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "mulp16apsvsi3_16"
  [(set (match_operand:SI     0 "pic30_accum_or_reg_operand" "=r,r")
        (mult:SI
          (sign_extend:SI
            (match_operand:P16APSV 1 "pic30_register_operand" "%r,r"))
          (sign_extend:SI
            (match_operand:P16APSV 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_mulp16apsvsi3_DATA_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_mulp16apsvsi3_APSV_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")


(define_insn "umulhip32eds3_imm_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "=r")
    (mult:P32EDS 
      (zero_extend:P32EDS 
        (match_operand:HI     1 "pic30_register_operand" "%r"))
      (match_operand:P32EDS   2 "pic30_P_operand"                   "P")))]
  "(!pic30_isa32_target())"
  "mul.uu %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "umulhip32eds3_DATA_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "=r,r")
        (mult:P32EDS 
          (zero_extend:P32EDS 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:P32EDS 
            (match_operand:HI 2 "pic30_mode2_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "mul.uu  %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "umulhip32eds3_APSV_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "=r,r")
        (mult:P32EDS 
          (zero_extend:P32EDS 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:P32EDS 
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "mul.uu  %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "umulhip32eds3_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand" "=r,r")
        (mult:P32EDS
          (zero_extend:P32EDS
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:P32EDS
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_umulhip32eds3_DATA_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
     gen_umulhip32eds3_APSV_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

(define_insn "umulhip32peds3_imm_16"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand" "=r")
    (mult:P32PEDS 
      (zero_extend:P32PEDS 
        (match_operand:HI     1 "pic30_register_operand" "%r"))
      (match_operand:P32PEDS   2 "pic30_P_operand"                   "P")))]
  "(!pic30_isa32_target())"
  "mul.uu %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "umulhip32peds3_DATA_16"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand" "=r,r")
        (mult:P32PEDS 
          (zero_extend:P32PEDS 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:P32PEDS 
            (match_operand:HI 2 "pic30_mode2_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "mul.uu  %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "umulhip32peds3_APSV_16"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand" "=r,r")
        (mult:P32PEDS 
          (zero_extend:P32PEDS 
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:P32PEDS 
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "mul.uu  %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "umulhip32peds3_16"
  [(set (match_operand:P32PEDS 0 "pic30_register_operand" "=r,r")
        (mult:P32PEDS
          (zero_extend:P32PEDS
            (match_operand:HI 1 "pic30_register_operand" "%r,r"))
          (zero_extend:P32PEDS
            (match_operand:HI 2 "pic30_mode2_APSV_operand"    "r,R<>"))))]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_umulhip32peds3_DATA_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_umulhip32peds3_APSV_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

; ECORE
; /* *_extend of an immediate_operand is illegal, apparently
;    so need two separate sequences */

;; 16 x 16 => 16 (signed)
 
(define_insn "mulhi3_imm_16"
  [(set (match_operand:HI 0 "pic30_D_register_operand"   "=D")
        (mult:HI
          (match_operand:HI 1 "pic30_register_operand" "%r")
          (match_operand:HI 2 "pic30_P_operand"        "P")))]
  "pic30_ecore_target() || pic30_isav4_target()"
  "mulw.su %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulhi3_DATA_16"
  [(set (match_operand:HI     0 "pic30_D_register_operand" "=D,D")
        (mult:HI
            (match_operand:HI 1 "pic30_register_operand" "%r,r")
            (match_operand:HI 2 "pic30_mode2_operand"    "r,R<>")))]
  "pic30_ecore_target() || pic30_isav4_target()"
  "mulw.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulhi3_APSV_16"
  [(set (match_operand:HI     0 "pic30_D_register_operand"   "=D,D")
        (mult:HI
            (match_operand:HI 1 "pic30_register_operand"   "%r,r")
            (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>")))]
  "pic30_ecore_target() || pic30_isav4_target()"
  "mulw.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "emulhi3_16"
  [(set (match_operand:HI     0 "pic30_D_register_operand"   "=D,D")
        (mult:HI
            (match_operand:HI 1 "pic30_register_operand"   "%r,r")
            (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>")))]
  "pic30_ecore_target() || pic30_isav4_target()"
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_mulhi3_DATA_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_mulhi3_APSV_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

(define_insn "mulp16apsv3_imm_16"
  [(set (match_operand:P16APSV 0 "pic30_D_register_operand"    "=D")
        (mult:P16APSV
          (match_operand:P16APSV 1 "pic30_register_operand" "%r")
          (match_operand:P16APSV 2 "pic30_P_operand"        "P")))]
  "pic30_ecore_target() || pic30_isav4_target()"
  "mulw.su %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulp16apsv3_DATA_16"
  [(set (match_operand:P16APSV     0 "pic30_D_register_operand" "=D,D")
        (mult:P16APSV
          (match_operand:P16APSV 1 "pic30_register_operand" "%r,r")
          (match_operand:P16APSV 2 "pic30_mode2_operand"    "r,R<>")))]
  "pic30_ecore_target() || pic30_isav4_target()"
  "mulw.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulp16apsv3_APSV_16"
  [(set (match_operand:P16APSV   0 "pic30_D_register_operand" "=D,D")
        (mult:P16APSV
          (match_operand:P16APSV 1 "pic30_register_operand" "%r,r")
          (match_operand:P16APSV 2 "pic30_mode2_APSV_operand" "r,R<>")))]
  "pic30_ecore_target() || pic30_isav4_target()"
  "mulw.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "emulp16apsv3_16"
  [(set (match_operand:P16APSV     0 "pic30_D_register_operand" "=D,D")
        (mult:P16APSV
          (match_operand:P16APSV 1 "pic30_register_operand" "%r,r")
          (match_operand:P16APSV 2 "pic30_mode2_APSV_operand"    "r,R<>")))]
  "pic30_ecore_target() || pic30_isav4_target()"
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_mulp16apsv3_DATA_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_mulp16apsv3_APSV_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; builtin 16x16->32 instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "mulsu_DATA_16"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r,  r,r")
        (unspec:SI [
                    (match_operand:HI 1 "pic30_mode2_or_P_operand" "r ,r,  r,P")
                    (match_operand:HI 2 "pic30_mode2_or_P_operand" "r ,R<>,P,r")
        ] UNSPECV_MULSU))
  ]
  "(!pic30_isa32_target())"
  "@
   mul.su %1,%2,%0
   mul.su %1,%2,%0
   mul.su %1,#%2,%0
   mul.uu %2,#%1,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse,def,def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulsu_APSV_16"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r,  r")
        (unspec:SI [
	  (match_operand:HI 1 "pic30_register_operand"   "r,r,  r")
	  (match_operand:HI 2 "pic30_mode2_or_P_APSV_operand" "r,R<>,P")
	] UNSPECV_MULSU))
  ]
  "(!pic30_isa32_target())"
  "@
   mul.su %1,%2,%0
   mul.su %1,%2,%0
   mul.su %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse,def")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "mulsu_16"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r,r,  r,r")
        (unspec:SI [
          (match_operand:HI 1 "pic30_mode2_or_P_APSV_operand" "r ,r,  r,P")
          (match_operand:HI 2 "pic30_mode2_or_P_APSV_operand" "r ,R<>,P,r")
        ] UNSPECV_MULSU))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_or_P_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_mulsu_DATA_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_mulsu_APSV_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

;
; For the purpose of RAW stalls, an accumulator register can never
;   be used as a pointer
;
(define_insn "mulsu_acc_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w,w,w,w")
        (subreg:HI 
          (unspec:SI [
                    (match_operand:HI 1 "pic30_mode2_or_P_operand" "r,r,  r,P")
                    (match_operand:HI 2 "pic30_mode2_or_P_operand" "r,R<>,P,r")
          ] UNSPECV_MULSU) 0))
                   ]
  "(!pic30_isa32_target())"
  "@
   mul.su %1,%2,%0
   mul.su %1,%2,%0
   mul.su %1,#%2,%0
   mul.uu %2,#%1,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "etc,use,etc,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "muluu_DATA_16"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r,  r,r")
        (unspec:SI [
                    (match_operand:HI 1 "pic30_mode2_or_P_operand" "r ,r,  r,P")
                    (match_operand:HI 2 "pic30_mode2_or_P_operand" "r ,R<>,P,r")
        ] UNSPECV_MULUU))
                   ]
  "(!pic30_isa32_target())"
  "@
   mul.uu %1,%2,%0
   mul.uu %1,%2,%0
   mul.uu %1,#%2,%0
   mul.uu %2,#%1,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse,def,def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "muluu_APSV_16"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r,  r")
        (unspec:SI [
	  (match_operand:HI 1 "pic30_register_operand"   "r,r,  r")
	  (match_operand:HI 2 "pic30_mode2_or_P_APSV_operand" "r,R<>,P")
	] UNSPECV_MULUU))
  ]
  "(!pic30_isa32_target())"
  "@
   mul.uu %1,%2,%0
   mul.uu %1,%2,%0
   mul.uu %1,#%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse,def")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "muluu_16"
  [(set (match_operand:SI 0 "pic30_register_operand"          "=r,r,  r,r")
        (unspec:SI [
          (match_operand:HI 1 "pic30_mode2_or_P_APSV_operand" "r ,r,  r,P")
          (match_operand:HI 2 "pic30_mode2_or_P_APSV_operand" "r ,R<>,P,r")
        ] UNSPECV_MULUU))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_or_P_APSV_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_muluu_APSV_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_muluu_DATA_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

;
; For the purpose of RAW stalls, an accumulator register can never
;   be used as a pointer
;
(define_insn "muluu_acc_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand"  "=w,w,w,w")
        (subreg:HI 
          (unspec:SI [
                    (match_operand:HI 1 "pic30_mode2_or_P_operand" "r,r,  r,P")
                    (match_operand:HI 2 "pic30_mode2_or_P_operand" "r,R<>,P,r")
          ] UNSPECV_MULUU) 0))
                   ]
  "(!pic30_isa32_target())"
  "@
   mul.uu %1,%2,%0
   mul.uu %1,%2,%0
   mul.uu %1,#%2,%0
   mul.uu %2,#%1,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "etc,use,etc,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulus_DATA_16"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r")
        (unspec:SI [
	            (match_operand:HI 1 "pic30_register_operand"    "r,r")
	            (match_operand:HI 2 "pic30_mode2_operand" "r,R<>")
	] UNSPECV_MULUS))
	           ]
  "(!pic30_isa32_target())"
  "mul.us %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulus_APSV_16"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r")
        (unspec:SI [
	  (match_operand:HI 1 "pic30_register_operand"    "r,r")
	  (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>")
	] UNSPECV_MULUS))
  ]
  "(!pic30_isa32_target())"
  "mul.us %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "mulus_16"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r")
        (unspec:SI [
          (match_operand:HI 1 "pic30_register_operand"    "r,r")    
          (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>")
        ] UNSPECV_MULUS))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_mulus_DATA_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_mulus_APSV_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

;
; For the purpose of RAW stalls, an accumulator register can never
;   be used as a pointer
;
(define_insn "mulus_acc_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w,w")
        (subreg:HI 
          (unspec:SI [
                    (match_operand:HI 1 "pic30_register_operand"    "r,r")
                    (match_operand:HI 2 "pic30_mode2_operand" "r,R<>")
        ] UNSPECV_MULUS) 0))
                   ]
  "(!pic30_isa32_target())"
  "mul.us %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "etc,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulss_DATA_16"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r")
        (unspec:SI [
	            (match_operand:HI 1 "pic30_register_operand"    "r,r")
	            (match_operand:HI 2 "pic30_mode2_operand" "r,R<>")
	] UNSPECV_MULSS)) ]
  "(!pic30_isa32_target())"
  "mul.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "mulss_APSV_16"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r")
        (unspec:SI [
	  (match_operand:HI 1 "pic30_register_operand"    "r,r")
	  (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>")
	] UNSPECV_MULSS))
  ]
  "(!pic30_isa32_target())"
  "mul.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "mulss_16"
  [(set (match_operand:SI 0 "pic30_register_operand"               "=r,r")
        (unspec:SI [
          (match_operand:HI 1 "pic30_register_operand"    "r,r")    
          (match_operand:HI 2 "pic30_mode2_APSV_operand" "r,R<>")
        ] UNSPECV_MULSS))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_mulss_DATA_16(operands[0],operands[1],operands[2])
    );
  } else {
    emit(
      gen_mulss_APSV_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

;
; For the purpose of RAW stalls, an accumulator register can never
;   be used as a pointer
;
(define_insn "mulss_acc_16"
  [(set (match_operand:HI 0 "pic30_accumulator_operand" "=w,w")
        (subreg:HI  
          (unspec:SI [
            (match_operand:HI 1 "pic30_register_operand" "r,r")
            (match_operand:HI 2 "pic30_mode2_operand" "r,R<>")
          ] UNSPECV_MULSS) 0))
  ]
  "(!pic30_isa32_target())"
  "mul.ss %1,%2,%0"
  [
   (set_attr "cc" "change0")
   (set_attr "type" "etc,use")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 32 x 32 => 32 (signed / unsigned) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;
;;  For e-core machine we don't want to use the normal mechanism because
;;    the normal mulhi wants an even register (which is better for)
;;    16-bit mul but not for composing 32-bit muls
;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; divide instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; builtin 32/16 instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "sdivsihi_16"
  [(set (match_operand:HI   0 "pic30_register_operand"  "=a,?b")
        (unspec_volatile:HI [
	  (match_operand:SI 1 "pic30_register_operand"   "r, r")
	  (match_operand:HI 2 "pic30_ereg_operand"       "e, e")
	] UNSPECV_DIVSD))
   (clobber 
        (match_scratch:HI   3                           "=b, a"))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.sd %%1,%%2\;\"
                \"%s\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.sd %%1,%%2\;\"
                \"%s\"
                \"mov w0,w1\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
    }
  }
  "
  [
    (set_attr "cc" "clobber")  ; should have a new CC of div
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "smodsihi_16"
  [(set (match_operand:HI   0 "pic30_register_operand" "=b,?a")
        (unspec_volatile:HI [
          (match_operand:SI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")
        ] UNSPECV_MODSD))
   (clobber 
        (match_scratch:HI   3                          "=a, b"))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.sd %%1,%%2\;\"
                \"%s\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.sd %%1,%%2\;\"
                \"%s\"
                \"mov w1,w0\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
    }
  }
  "
  [
    (set_attr "cc" "clobber")  ; should have a new CC of div
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "divf_16"
  [(set (match_operand:HI   0 "pic30_register_operand" "=a,?b")
        (unspec_volatile:HI [
          (match_operand:HI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")
        ] UNSPECV_DIVF))
   (clobber 
        (match_scratch:HI   3                          "=b, a"))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;divf %%1,%%2\;\"
                \"%s\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;divf %%1,%%2\;\"
                \"%s\"
                \"mov w0,%%0\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
    }
  }
  "
  [
    (set_attr "cc" "clobber")  ; should have new cc of div
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "divmodf_16"
  [(set (match_operand:HI   0 "pic30_register_operand" "=a,?b")
        (unspec:HI [
          (match_operand:HI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")
        ] UNSPEC_DIVMODF))
   (set (match_operand:HI   3 "pic30_register_operand" "=b, a")
        (unspec:HI [
          (match_dup 1)
          (match_dup 2)
         ] UNSPEC_DIVMODF))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;divf %%1,%%2\;\"
                \"%s\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:
        if (pic30_errata_mask & exch_errata) {
          sprintf(c,\"%s\"
                  \"repeat #__TARGET_DIVIDE_CYCLES\;divf %%1,%%2\;\"
                  \"%s\"
                  \"push w1\;mov w0,w1\;pop w0\",
                  repeat_errata_push,repeat_errata_pop);
          return buffer;
        } else {
          sprintf(c,\"%s\"
                  \"repeat #__TARGET_DIVIDE_CYCLES\;divf %%1,%%2\;\"
                  \"%s\"
                  \"exch w0,w1\",
                  repeat_errata_push,repeat_errata_pop);
          return buffer;
        }
    }
  }
  "
  [
    (set_attr "cc" "clobber")  ; should have new CC of div
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "udivsihi_16"
  [(set (match_operand:HI 0 "pic30_register_operand"   "=a,?b")
        (unspec_volatile:HI [
	  (match_operand:SI 1 "pic30_register_operand"  "r, r")
	  (match_operand:HI 2 "pic30_ereg_operand"      "e, e")
	] UNSPECV_DIVUD))
   (clobber 
        (match_scratch:HI   3                          "=b, a"))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.ud %%1,%%2\;\"
                \"%s\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.ud %%1,%%2\;\"
                \"%s\"
                \"mov w0,w1\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
    }
  }
  "
  [
    (set_attr "cc" "clobber")  ; should have new CC of div
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "umodsihi_16"
  [(set (match_operand:HI 0 "pic30_register_operand"   "=b,?a")
        (unspec_volatile:HI [
          (match_operand:SI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")
        ] UNSPECV_MODUD))
   (clobber 
        (match_scratch:HI   3                          "=a, b"))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.ud %%1,%%2\;\"
                \"%s\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.ud %%1,%%2\;\"
                \"%s\"
                \"mov w1,w0\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
    }
  }
  "
  [
    (set_attr "cc" "clobber")  ; should have new CC of div
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "sdivmodsihi_16"
  [(set (match_operand:HI 0 "pic30_register_operand"   "=a,?b")
        (unspec_volatile:HI [
          (match_operand:SI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")
        ] UNSPECV_DIVMODSD))
   (set (mem:HI 
          (match_operand:HI 3 "pic30_register_operand" " e, e"))
        (unspec_volatile:HI [
          (match_dup 1)
          (match_dup 2)
        ] UNSPECV_DIVMODSD))
   (clobber 
        (match_scratch:HI   4                          "=b, a"))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.sd %%1,%%2\;\"
                \"%s\"
                \"mov w1,[%%3]\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.sd %%1,%%2\;\"
                \"%s\"
                \"mov w1,[%%3]\;mov w0,w1\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
    }
  }
  "
  [
    (set_attr "cc" "clobber")   ; should have new CC of div
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "sdivmodsihi_eds_16"
  [(set (match_operand:HI 0 "pic30_register_operand"     "=a,a,?b,?b")
        (unspec_volatile:HI [
          (match_operand:SI 1 "pic30_register_operand"    "r,r, r, r")
	  (match_operand:HI 2 "pic30_ereg_operand"        "e,e, e, e")
        ] UNSPECV_EDSDIVMODSD))
   (set (match_operand:HI 3 "pic30_register_operand"     "=b,e, e, a")
        (unspec_volatile:HI [
          (const_int 0)
        ] UNSPECV_EDSMOD))
   (clobber (match_scratch:HI 4                          "=X,b, e, e"))
   (clobber (match_scratch:HI 5                          "=X,X, a, X"))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.sd %%1,%%2\;\"
                \"%s\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.sd %%1,%%2\;\"
                \"%s\"
                \"mov w1,%%3\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 2:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.sd %%1,%%2\;\"
                \"%s\"
                \"mov w1,%%4\;mov w0,w1\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 3:  
        if (pic30_errata_mask & exch_errata)
          sprintf(c,\"%s\"
                  \"repeat #__TARGET_DIVIDE_CYCLES\;div.sd %%1,%%2\;\"
                  \"%s\"
                  \"mov w1,%%4\;mov w0,w1\;mov %%4,w0\",
                  repeat_errata_push,repeat_errata_pop);
        else 
          sprintf(c,\"%s\"
                  \"repeat #__TARGET_DIVIDE_CYCLES\;div.sd %%1,%%2\;\"
                  \"%s\"
                  \"exch w0,w1\",
                  repeat_errata_push,repeat_errata_pop);
        return buffer;
    }
  }
  "
  [
    (set_attr "cc" "clobber")   ; should have new CC of div
    (set_attr "type" "def")
  ]
)

(define_expand "sdivmodsihiumm_16"
  [(set (match_operand:HI 0 "pic30_register_operand"   "")
        (unspec_volatile:HI [
          (match_operand:SI 1 "pic30_register_operand" "")
          (match_operand:HI 2 "pic30_ereg_operand"     "")
        ] UNSPECV_DIVMODSD))
   (set (match_operand 3 "pic30_mem_eds_operand"       "")
        (unspec_volatile:HI [
          (match_dup 1)
          (match_dup 2)
        ] UNSPECV_DIVMODSD))
  ]
  "(!pic30_isa32_target())"
  "{
     rtx rem = gen_reg_rtx(HImode);
     emit(
       gen_sdivmodsihi_eds_16(operand0,operand1,operand2,rem)
     );
     emit(
       gen_P32UMMwt_hi_16(operand3, rem)
     );
     DONE;
   }
  "
)

(define_insn "udivmodsihi_16"
  [(set (match_operand:HI 0 "pic30_register_operand"  "=a,?b")
        (unspec_volatile:HI [
          (match_operand:SI 1 "pic30_register_operand" "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"     "e, e")
        ] UNSPECV_DIVMODUD))
   (set (mem:HI 
          (match_operand:HI 3 "pic30_register_operand" "e, e"))
        (unspec_volatile:HI [
          (match_dup 1)
          (match_dup 2)
        ] UNSPECV_DIVMODUD))
   (clobber 
        (match_scratch:HI   4                          "=b, a"))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.ud %%1,%%2\;\"
                \"%s\"
                \"mov w1,[%%3]\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.ud %%1,%%2\;\"
                \"%s\"
                \"mov w1,[%%3]\;mov w0,w1\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
    }
  }
  "
  [
    (set_attr "cc" "clobber")  ; should have new CC of div
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "udivmodsihi_umm_16"
  [(set (match_operand:HI 0 "pic30_register_operand"     "=a,a,?b,?b")
        (unspec_volatile:HI [
          (match_operand:SI 1 "pic30_register_operand"    "r,r, r, r")
	  (match_operand:HI 2 "pic30_ereg_operand"        "e,e, e, e")
        ] UNSPECV_EDSDIVMODUD))
   (set (match_operand:HI 3 "pic30_register_operand"     "=b,e, e, a")
        (unspec_volatile:HI [
          (const_int 0)
        ] UNSPECV_EDSMOD))
   (clobber (match_scratch:HI 4                          "=X,b, e, e"))
   (clobber (match_scratch:HI 5                          "=X,X, a, X"))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.ud %%1,%%2\;\"
                \"%s\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.ud %%1,%%2\;\"
                \"%s\"
                \"mov w1,%%3\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 2:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.ud %%1,%%2\;\"
                \"%s\"
                \"mov w1,%%4\;mov w0,w1\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 3:  
        if (pic30_errata_mask & exch_errata)
          sprintf(c,\"%s\"
                  \"repeat #__TARGET_DIVIDE_CYCLES\;div.ud %%1,%%2\;\"
                  \"%s\"
                  \"mov w1,%%4\;mov w0,w1\;mov %%4,w0\",
                  repeat_errata_push,repeat_errata_pop);
        else 
          sprintf(c,\"%s\"
                  \"repeat #__TARGET_DIVIDE_CYCLES\;div.ud %%1,%%2\;\"
                  \"%s\"
                  \"exch w0,w1\",
                  repeat_errata_push,repeat_errata_pop);
        return buffer;
    }
  }
  "
  [
    (set_attr "cc" "clobber")   ; should have new CC of div
    (set_attr "type" "def")
  ]
)

(define_expand "udivmodsihiumm_16"
  [(set (match_operand:HI 0 "pic30_register_operand"   "")
        (unspec_volatile:HI [
          (match_operand:SI 1 "pic30_register_operand" "")
          (match_operand:HI 2 "pic30_ereg_operand"     "")
        ] UNSPECV_DIVMODUD))
   (set (match_operand 3 "pic30_mem_umm_operand"       "")
        (unspec_volatile:HI [
          (match_dup 1)
          (match_dup 2)
        ] UNSPECV_DIVMODUD))
  ]
  "(!pic30_isa32_target())"
  "{
     rtx rem = gen_reg_rtx(HImode);
     emit(
       gen_udivmodsihi_umm_16(operand0,operand1,operand2,rem)
     );
     emit(
       gen_P32UMMwt_hi_16(operand3, rem)
     );
     DONE;
   }
  "
)


(define_insn "divmodhi4_16"
  [(set (match_operand:HI   0 "pic30_register_operand" "=a,?b")
        (div:HI
          (match_operand:HI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")))
   (set (match_operand:HI   3 "pic30_register_operand" "=b, a")
        (mod:HI 
          (match_dup 1)
          (match_dup 2)))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.sw %%1,%%2\;\"
                \"%s\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:  
        if (pic30_errata_mask & exch_errata) {
          sprintf(c,\"%s\"
                  \"repeat #__TARGET_DIVIDE_CYCLES\;div.sw %%1,%%2\;\"
                  \"%s\"
                  \"push w1\;mov w0,w1\;pop w0\",
                  repeat_errata_push,repeat_errata_pop);
          return buffer;
        } else {
          sprintf(c,\"%s\"
                  \"repeat #__TARGET_DIVIDE_CYCLES\;div.sw %%1,%%2\;\"
                  \"%s\"
                  \"exch w0,w1\",
                  repeat_errata_push,repeat_errata_pop);
          return buffer;
        }
    }
  }
  "
  [
    (set_attr "cc" "clobber")  ; should have new CC of div
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "udivmodhi4_16"
  [(set (match_operand:HI   0 "pic30_register_operand" "=a,?b")
        (udiv:HI
          (match_operand:HI 1 "pic30_register_operand"  "r, r")
          (match_operand:HI 2 "pic30_ereg_operand"      "e, e")))
   (set (match_operand:HI   3 "pic30_register_operand" "=b, a")
        (mod:HI 
          (match_dup 1)
          (match_dup 2)))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:  
        sprintf(c,\"%s\"
                \"repeat #__TARGET_DIVIDE_CYCLES\;div.uw %%1,%%2\;\"
                \"%s\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:  
        if (pic30_errata_mask & exch_errata) {
          sprintf(c,\"%s\"
                  \"repeat #__TARGET_DIVIDE_CYCLES\;div.uw %%1,%%2\;\"
                  \"%s\"
                  \"push w1\;mov w0,w1\;pop w0\",
                  repeat_errata_push,repeat_errata_pop);
          return buffer;
        } else {
          sprintf(c,\"%s\"
                  \"repeat #__TARGET_DIVIDE_CYCLES\;div.uw %%1,%%2\;\"
                  \"%s\"
                  \"exch w0,w1\",
                  repeat_errata_push,repeat_errata_pop);
          return buffer;
        }
    }
  }
  "
  [
    (set_attr "cc" "clobber")  ; should have new CC of div
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; square root instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Other arithmetic instructions:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Absolute value
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "absqi2_16"
   [(set (match_operand:QI 0 "pic30_register_operand" "=r")
        (abs:QI 
          (match_operand:QI 1 "pic30_register_operand" "0")))
    (clobber (reg:CC CC_REG))
   ]
   "(!pic30_isa32_target())"
   "btsc %1,#7\;neg.b %1,%0"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
   ]
)

;;;;;;;;;;;;;;;;;;
;; Half integer
;;;;;;;;;;;;;;;;;;

(define_insn "abshi2_16"
   [(set (match_operand:HI 0 "pic30_register_operand"  "=r")
        (abs:HI 
          (match_operand:HI 1 "pic30_register_operand"  "0")))
    (clobber (reg:CC CC_REG))
   ]
   "(!pic30_isa32_target())"
   "btsc %1,#15\;neg %1,%0"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
    (set_attr "op_type" "alu")
   ]
)

(define_insn "abssi2_16"
   [(set (match_operand:SI 0 "pic30_register_operand"   "=r,r")
         (abs:SI
           (match_operand:SI 1 "pic30_register_operand" " 0,r")))
    (clobber (reg:CC CC_REG))
   ]
   "(!pic30_isa32_target())"
   "@
    cp0 %d1\;bra ge,.LL1%=\;subr.w %1,#0,%0\;subbr.w %d1,#0,%d0\;.LL1%=:
    add %1,#0,%0\;add %d1,#0,%d0\;bra ge,.LL1%=\;subr.w %1,#0,%0\;subbr.w %d1,#0,%d0\;.LL1%=:"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
   ]
)

;;;;;;;;;;;;;;;;;;
;; Single float
;;;;;;;;;;;;;;;;;;

(define_insn "abssf2_16"
  [(set (match_operand:SF 0 "pic30_register_operand"        "=r")
        (abs:SF 
          (match_operand:SF 1 "pic30_register_operand"       "0")))
  ]
  "(!pic30_isa32_target())"
  "bclr %d0,#15"
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;
;; Double float
;;;;;;;;;;;;;;;;;;

(define_insn "absdf2_16"
  [(set (match_operand:DF 0 "pic30_register_operand"        "=r")
        (abs:DF 
          (match_operand:DF 1 "pic30_register_operand"       "0")))
  ]
  "(!pic30_isa32_target())"
  "bclr %q0,#15"
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Negation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; Quarter integer 
;;;;;;;;;;;;;;;;;;

(define_insn "negqi2_DATA_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (neg:QI (match_operand:QI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "neg.b %1,%0"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "negqi2_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (neg:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "neg.b %1,%0"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "negqi2_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (neg:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
    emit(gen_negqi2_DATA_16(operands[0],operands[1]));
  else
    emit(gen_negqi2_APSV_16(operands[0],operands[1]));
  DONE;
}")

(define_insn "*negqi2_sfr0_16"
  [(set (match_operand:QI 0 "pic30_wreg_operand"        "=a")
        (neg:QI (match_operand:QI 1 "pic30_near_operand" "U")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "neg.b %1,WREG"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*negqi2_sfr1_16"
  [(set (match_operand:QI 0 "pic30_near_operand"        "=U")
        (neg:QI (match_dup 0)))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "neg.b %0"
  [
    (set_attr "cc" "set") ; CAW
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;
;; Half integer 
;;;;;;;;;;;;;;;;;;

(define_insn "neghi2_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (neg:HI (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "neg %1,%0"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "neghi2_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (neg:HI 
          (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "neg %1,%0"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "neghi2_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (neg:HI 
          (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
    emit(gen_neghi2_DATA_16(operands[0],operands[1]));
  else
    emit(gen_neghi2_APSV_16(operands[0],operands[1]));
  DONE;
}")

(define_insn "*neghi2_sfr0_16"
  [(set (match_operand:HI 0 "pic30_wreg_operand"                "=a,a")
        (neg:HI (match_operand:HI 1 "pic30_reg_or_near_operand" " U,r")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   neg %1,WREG
   neg %1,%0"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, there is no operand 2 to interfere with a reload (CAW)
(define_insn "*neghi2_sfr1_16"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand"        "+U,r")
        (neg:HI (match_dup 0)))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   neg %0
   neg %0,%0"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "etc,def")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;
;; Single integer 
;;;;;;;;;;;;;;;;;;

(define_insn "negsi2_16"
  [(set (match_operand:SI 0 "pic30_register_operand"        "=r")
        (neg:SI 
          (match_operand:SI 1 "pic30_register_operand"       "r")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "subr %1,#0,%0\;subbr %d1,#0,%d0"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "negp32eds2_16"
  [(set (match_operand:P32EDS 0 "pic30_register_operand"        "=r")
        (neg:P32EDS 
          (match_operand:P32EDS 1 "pic30_register_operand"       "r")))
   (clobber (reg:CC CC_REG))
  ]
  ""
  "subr %1,#0,%0\;subbr %d1,#0,%d0"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)


;;;;;;;;;;;;;;;;;;
;; Single float
;;;;;;;;;;;;;;;;;;

(define_insn "negsf2_16"
  [(set (match_operand:SF 0        "pic30_register_operand" "=r")
        (neg:SF 
          (match_operand:SF 1 "pic30_register_operand"       "0")))
  ]
  "(!pic30_isa32_target())"
  "btg %d0,#15"
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*negsf2sfr_16"
  [(set (match_operand:SF 0        "pic30_near_operand" "=U")
        (neg:SF (match_dup 0)))
  ]
  "(!pic30_isa32_target())"
  "btg.b %0+3,#7"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "negdi2_16"
  [(set (match_operand:DI 0 "pic30_register_operand"        "=r")
        (neg:DI 
          (match_operand:DI 1 "pic30_register_operand" "r")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "subr %1,#0,%0\;subbr %d1,#0,%d0\;subbr %t1,#0,%t0\;subbr %q1,#0,%q0"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)


;;;;;;;;;;;;;;;;;;
;; Double float
;;;;;;;;;;;;;;;;;;

(define_insn "negdf2_16"
  [(set (match_operand:DF 0        "pic30_register_operand" "=r")
        (neg:DF 
           (match_operand:DF 1 "pic30_register_operand"  "0")))
  ]
  "(!pic30_isa32_target())"
  "btg %q0,#15"
  [
   (set_attr "cc" "unchanged")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; bit-logical instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; Quarter integer 
;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;
;; Set Bit ;;
;;;;;;;;;;;;;

(define_insn "bitsetqi_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r,R<>")
        (ior:QI (match_operand:QI 1 "pic30_mode2_operand" "0,0")
                (match_operand 2 "const_int_operand"      "i,i")))
  ]
  "(pic30_one_bit_set_p(INTVAL(operands[2])&0x00ff))"
  "bset.b %0,#%b2"
  [
   (set_attr "type" "def,etc")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bitsetqi_sfr_16"
  [(set (match_operand:QI 0 "pic30_near_operand"        "=U")
        (ior:QI  (match_dup 0)
                 (match_operand 1 "const_int_operand" "i")))
  ]
  "(!pic30_isa32_target()) && pic30_one_bit_set_p(INTVAL(operands[1]) & 0x00ff)"
  "bset.b %0,#%b1"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;
;; Reset Bit ;;
;;;;;;;;;;;;;;;

(define_insn "bitclrqi_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r,R,<>")
        (and:QI (match_operand:QI 1 "pic30_mode2_operand" "0,0,0")
                (match_operand 2 "const_int_operand"      "i,i,i")))
  ]
  "(pic30_one_bit_set_p((~INTVAL(operands[2])&0xff)))"
  "bclr.b %0,#%B2"
  [
   (set_attr "type" "def,use,defuse")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bitclrqi_sfr_16"
  [(set (match_operand:QI 0 "pic30_near_operand"        "=U")
        (and:QI  (match_dup 0)
                 (match_operand 1 "const_int_operand" "i")))
  ]
  "(pic30_one_bit_set_p((~INTVAL (operands[1])) & 0x00ff))"
  "bclr.b %0,#%B1"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "alu")
  ]
)


;;;;;;;;;;;;;;;;
;; Toggle Bit ;;
;;;;;;;;;;;;;;;;

(define_insn "bittogqi_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r,R,<>")
        (xor:QI (match_operand:QI 1 "pic30_mode2_operand" "0,0,0")
                (match_operand 2 "const_int_operand"      "i,i,i")))
  ]
  "(TARGET_CLASSIC) && (pic30_one_bit_set_p(INTVAL(operands[2])&0xffff))"
  "btg.b %0,#%b2"
  [
   (set_attr "type" "def,use,defuse")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bittogqi_sfr_16"
  [(set (match_operand:QI 0 "pic30_near_operand"        "=U")
        (xor:QI  (match_dup 0)
                 (match_operand 1 "const_int_operand" "i")))
  ]
  "(!pic30_isa32_target()) && pic30_one_bit_set_p(INTVAL(operands[1]) & 0x00ff)"
  "btg.b %0,#%b1"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;
;; Test Bit ;;
;;;;;;;;;;;;;;

(define_insn "*bittstqi_and_16"
  [(set (reg:CC_Z CC_REG)
        (compare
          (and (match_operand:QI 0 "pic30_reg_or_near_operand" "r,U")
               (match_operand 1 "immediate_operand" "i,i"))
          (const_int 0)))
  ]
  "((pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1)) && 
    (!pic30_isa32_target()))"
  "@
   btst %0,#%b1
   btst.b %0,#%b1"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc,use")
    (set_attr "op_type" "alu")
  ]
)
 
          
(define_insn "newbittstqi_16"
  [(set (reg:CC_Z CC_REG)
        (compare
          (zero_extract
            (match_operand:QI 0 "pic30_reg_or_near_operand" "r,U,R,<>")
            (const_int 1)
            (match_operand 1 "const_int_operand"         "i,i,i,i"))
        (const_int 0)))
  ]
  "((!pic30_isa32_target()) && (INTVAL(operands[1]) < 8))"
  "@
   btst %0,#%1
   btst.b %0,#%1
   btst  %0,#%1
   btst  %0,#%1"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc,etc,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*bittstqi_16"
  [(set (reg:CC_Z CC_REG)
        (compare
          (zero_extract (match_operand:QI 0 "pic30_reg_or_near_operand" "r,U")
                        (const_int 1)
                        (match_operand 1 "const_int_operand" "i,i"))
          (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
  "@
   btst %0,#%1
   btst.b %0,#%1"
  [
    (set_attr "cc" "set")
    (set_attr "type" "etc,use")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;
;; Half integer ;;
;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;
;; Set Bit ;;
;;;;;;;;;;;;;

;; the pre/post modify modes have been removed due to errata in Rev A silicon
;;   the pre/post modify modes are valid for REV_A3

(define_insn "bitsethi_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"         "=r,R,<>")
        (ior:HI  (match_operand:HI 1 "pic30_mode2_operand" "0,0,0")
                 (match_operand 2 "const_int_operand"      "i,i,i")))
  ]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1))"
  "bset %0,#%b2"
  [
   (set_attr "type" "def,use,defuse")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bitsethi_sfr_16"
  [(set (match_operand:HI 0 "pic30_near_operand"         "=U")
        (ior:HI  (match_dup 0)
                 (match_operand 1 "const_int_operand"  "i")))
  ]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "*
   {
     if ((INTVAL(operands[1])&0xffff) >= 256)
       return \"bset.b %0+1,#%b1-8\";
     else
       return \"bset.b %0,#%b1\";
   }"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;
;; Reset Bit ;;
;;;;;;;;;;;;;;;

;; the pre/post modify modes have been removed due to errata in Rev A silicon
;;   the pre/post modify modes are valid for REV_A3

(define_insn "bitclrhi_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"         "=r,R,<>")
        (and:HI  (match_operand:HI 1 "pic30_mode2_operand" "0,0,0")
                 (match_operand 2 "const_int_operand"      "i,i,i")))
  ]
  "(pic30_one_bit_set_p((~INTVAL(operands[2])) & 0xffff))"
  "bclr %0,#%B2"
  [
   (set_attr "type" "def,use,defuse")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
;        (and:HI  (match_operand:HI 1 "pic30_near_operand"  "0")
(define_insn "bitclrhi_sfr_16"
  [(set (match_operand:HI 0 "pic30_near_operand"           "=U")
        (and:HI  (match_dup 0)
                 (match_operand 1 "const_int_operand" "i")))
  ]
  "(pic30_one_bit_set_p((~INTVAL(operands[1])) & 0xffff))"
  "*
   {
     if (pic30_which_bit(~INTVAL(operands[1])) > 7)
       return \"bclr.b %0+1,#%B1-8\";
     else
       return \"bclr.b %0,#%B1\";
   }"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;
;; Toggle Bit ;;
;;;;;;;;;;;;;;;;

;; the pre/post modify modes have been removed due to errata in Rev A silicon
;;   the pre/post modify modes are valid for REV_A3

(define_insn "bittoghi_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"         "=r,R,<>")
        (xor:HI  (match_operand:HI 1 "pic30_mode2_operand" "0,0,0")
                 (match_operand 2 "const_int_operand"      "i,i,i")))
  ]
  "(TARGET_CLASSIC) && (pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1))"
  "btg %0,#%b2"
  [
   (set_attr "type" "def,use,defuse")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bittoghi_sfr_16"
  [(set (match_operand:HI 0 "pic30_near_operand"           "=U")
        (xor:HI  (match_dup 0)
                 (match_operand 1 "const_int_operand" "i")))
  ]
  "(TARGET_CLASSIC) && (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "*
   {
     if ((INTVAL(operands[1])&0xffff) >= 256)
       return \"btg.b %0+1,#%b1-8\";
     else
       return \"btg.b %0,#%b1\";
   }"
  [
    (set_attr "type" "use")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;
;; Test Bit ;;
;;;;;;;;;;;;;;

(define_insn "*bittsthi_and_DATA_16"
  [(set (reg:CC CC_REG)
        (compare
          (and (match_operand:HI 0 "pic30_near_mode2_operand" "r,R,<>,U")
               (match_operand 1 "immediate_operand"           "i,i,i, i"))
          (const_int 0))
   )
  ]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "@
   btst %0,#%b1
   btst %0,#%b1
   btst %0,#%b1
   btst.b %0+%b1/8,#%b1%%8"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*bittsthi_and_APSV_16"
  [(set (reg:CC CC_REG)
        (compare
          (and (match_operand:HI 0 "pic30_near_mode2_APSV_operand" "r,R,<>,U")
               (match_operand 1 "immediate_operand"           "i,i,i, i"))
          (const_int 0))
   )
  ]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "@
   btst %0,#%b1
   btst %0,#%b1
   btst %0,#%b1
   btst.b %0+%b1/8,#%b1%%8"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*bittsthi_DATA_16"
  [(set (reg:CC CC_REG) 
        (compare
          (zero_extract:HI
            (match_operand:HI 0 "pic30_near_mode2_operand" "r,R,<>,U")
            (const_int 1)
            (match_operand 1 "const_int_operand"           "i,i,i, i"))
          (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
  "@
   btst %0,#%1
   btst %0,#%1
   btst %0,#%1
   btst.b %0+%1/8,#%1%%8"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*bittsthi_APSV_16"
  [(set (reg:CC CC_REG) 
        (compare
          (zero_extract:HI
             (match_operand:HI 0 "pic30_near_mode2_APSV_operand" "r,R,<>,U")
             (const_int 1)
             (match_operand 1 "const_int_operand"           "i,i,i, i"))
        (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
  "@
   btst %0,#%1
   btst %0,#%1
   btst %0,#%1
   btst.b %0+%1/8,#%1%%8"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*newbittsthi_DATA_16"
  [(set (reg:CC CC_REG) 
        (compare 
          (zero_extract
            (match_operand:HI 0 "pic30_near_mode2_operand" "r,R,<>,U")
            (const_int 1)
            (match_operand 1 "const_int_operand"           "i,i,i, i"))
          (const_int 0))
   )]
  "(!pic30_isa32_target())"
  "@
   btst %0,#%1
   btst %0,#%1
   btst %0,#%1
   btst.b %0+%1/8,#%1%%8"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*newbittsthi_APSV_16"
  [(set (reg:CC CC_REG) 
        (compare 
          (zero_extract
            (match_operand:HI 0 "pic30_near_mode2_APSV_operand" "r,R,<>,U")
            (const_int 1)
            (match_operand 1 "const_int_operand"           "i,i,i, i"))
          (const_int 0))
   )]
  "(!pic30_isa32_target())"
  "@
   btst %0,#%1
   btst %0,#%1
   btst %0,#%1
   btst.b %0+%1/8,#%1%%8"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;
;; Single integer ;;
;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;
;; Set Bit ;;
;;;;;;;;;;;;;

(define_insn "bitset<mode>_16"
  [(set (match_operand:GM32BIT   0 "pic30_reg_or_R_operand" "=r,R")
        (ior:GM32BIT  
          (match_operand:GM32BIT 1 "pic30_reg_or_R_operand"  "0,0")
          (match_operand         2 "const_int_operand"       "i,i")))
  ]
  "((!pic30_isa32_target()) && 
    pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1))"
  "*
   {
     switch (which_alternative) {
       case 0:
         if (pic30_which_bit(INTVAL(operands[2])) < 16) {
           return \"bset %0,#%b2\";
	 } else {
           return \"bset %d0,#%b2-16\";
         }
       case 1:
         if (pic30_which_bit(INTVAL(operands[2])) < 16) {
           return \"bset %0,#%b2\";
         } else {
           return \"mov.w %I0,[w15]\;bset %D0,#%b2-16\";
         }
       default:
         gcc_assert(0);
         return \"nop\";
       }
   }"
  [
    (set_attr "type" "def,use")
    (set_attr "cc"   "unchanged,unchanged")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*bitsetsir_16"
  [(set (match_operand:SI 0 "pic30_register_operand"         "=r")
        (ior:SI  
          (match_operand:SI 1 "pic30_register_operand"        "0")
          (match_operand 2 "const_int_operand"                "i")))
  ]
  "((!pic30_isa32_target()) && 
    pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1))"
  "*
   {
     if (pic30_which_bit(INTVAL(operands[2])) < 16) {
       return \"bset %0,#%b2\";
     } else {
       return \"bset %d0,#%b2-16\";
     }
   }"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bitsetsi_sfr_16"
  [(set (match_operand:SI 0 "pic30_near_operand"         "=U")
        (ior:SI  (match_dup 0)
                 (match_operand 1 "const_int_operand"  "i")))
  ]
  "((!pic30_isa32_target()) &&
    (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1)))"
  "*
   {
     unsigned int n = INTVAL(operands[1]);

     if (n >= 0x1000000)
       return \"bset.b %0+3,#%b1-24\";
     else if (n >= 0x10000)
       return \"bset.b %0+2,#%b1-16\";
     else if (n >= 0x0100)
       return \"bset.b %0+1,#%b1-8\";
     else return \"bset.b %0+0,#%b1\";
   }"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;
;; Reset Bit ;;
;;;;;;;;;;;;;;;

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bitclrsi_sfr_16"
  [(set (match_operand:SI 0 "pic30_near_operand"         "=U")
        (and:SI  (match_dup 0)
                 (match_operand 1 "const_int_operand"  "i")))
  ]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "*
   {
     int n = pic30_which_bit(~INTVAL(operands[1]));

     if (n > 23)
       return \"bclr.b %0+3,#%B1-24\";
     else if (n > 15)
       return \"bclr.b %0+2,#%B1-16\";
     else if (n > 7)
       return \"bclr.b %0+1,#%B1-8\";
     else return \"bclr.b %0+0,#%B1\";
   }"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "bitclrsi_16"
  [(set (match_operand:SI 0 "pic30_register_operand"         "=r")
        (and:SI  
          (match_operand:SI 1 "pic30_register_operand"        "0")
          (match_operand 2 "const_int_operand"                "i")))
  ]
  "(!pic30_isa32_target()) &&
   (pic30_one_bit_set(GET_MODE(operands[0]),operands[2],0))"
  "*
   {
     int n = pic30_which_bit(~INTVAL(operands[2]));

     if (n > 15)
       return \"bclr %d0,#%B2-16\";
     else
       return \"bclr %0,#%B2\";
   }"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;
;; Toggle Bit ;;
;;;;;;;;;;;;;;;;

(define_insn "bittogsi_16"
  [(set (match_operand:SI 0 "pic30_mode2_operand"             "=r, R, r,R")
        (xor:SI  (match_operand:SI 1 "pic30_mode2_operand"     "0, 0, 0,0")
                 (match_operand    2 "const_int_operand"      "jh,jh,i,i")))
   (clobber (match_scratch:HI 3                                "=X,X, X,&r"))
  ]
  "(TARGET_CLASSIC) && 
   (pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1))"
  "*
   {
     unsigned int n = INTVAL(operands[2]);
     switch (which_alternative) {
       case 0:
         if (n >= 65536)
           gcc_assert(0);
         else
           return \"btg %0,#%b2\";
         break;

       case 1:
         if (n >= 65536)
           gcc_assert(0);
         else
           return \"btg %0,#%b2\";
         break;
     
       case 2:
         if (n >= 65536)
           return \"btg %d0,#%b2-16\";
         else
           gcc_assert(0);
         break;

       case 3:
         if (n >= 65536)
           return \"add %r0,#2,%3\;btg [%3],#%b2-16\";
         else
           gcc_assert(0);
     }

   }"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn "bittogsi_sfr_16"
  [(set (match_operand:SI 0 "pic30_near_operand"         "=U")
        (xor:SI  (match_dup 0)
                 (match_operand 1 "const_int_operand"  "i")))
  ]
  "(TARGET_CLASSIC) && (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "*
   {
     unsigned int n = INTVAL(operands[1]);
     if (n >= 0x01000000)
       return \"btg.b %0+3,#%b1-24\";
     else if (n >= 0x00010000)
       return \"btg.b %0+2,#%b1-16\";
     else if (n >= 0x00000100)
       return \"btg.b %0+1,#%b1-8\";
     else return \"btg.b %0+0,#%b1-0\";
   }"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;
;; Test Bit ;;
;;;;;;;;;;;;;;

(define_insn "*bittstsir_and_16"
  [(set (reg:CC_NZ CC_REG) 
        (compare
          (and 
            (match_operand:SI 0 "pic30_register_operand"  "r")
            (match_operand 1 "const_int_operand"          "i"))
          (const_int 0))
   )
  ]
  "(!pic30_isa32_target()) && 
   (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "*
   {
     if (INTVAL(operands[1]) < (1<<16)) {
       return \"btst %0,#%b1\";
     } else {
       return \"btst %d0,#%b1-16\";
     }
   }"
  [
    (set_attr "cc" "set")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*bittstsi_sfr_and_16"
  [(set (reg:CC_NZ CC_REG) 
        (compare 
          (and (match_operand:SI 0 "pic30_near_operand" "U")
               (match_operand    1 "const_int_operand"  "i"))
          (const_int 0))
   )
  ]
  "(pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1))"
  "btst.b %0+%b1/8,#%b1%%8"
  [
    (set_attr "cc" "set")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*bittstsiR_16"
  [(set (reg:CC_NZ CC_REG) 
        (compare
          (zero_extract (match_operand:SI 0 "pic30_reg_or_R_operand" "r,R")
                        (const_int 1)
                        (match_operand 1 "const_int_operand" "i,i"))
          (const_int 0))
   )
  ]
  "((!pic30_isa32_target()) && (INTVAL(operands[1]) < 16))"
  "btst %0,#%1"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "bittstsiR_and_16"
  [(set (reg:CC_NZ CC_REG)
        (compare
          (and 
             (match_operand:SI 0 "pic30_reg_or_R_operand"  "r,R")
             (match_operand 1 "const_int_operand"          "i,i"))
          (const_int 0))
   )
  ]
  "(!pic30_isa32_target()) &&
   (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1)) &&
   pic30_which_bit(INTVAL(operands[1])) < 16"
  "btst %0,#%b1"
  [
   (set_attr "cc" "set")
   (set_attr "type" "etc,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*bittstsir_16"
  [(set (reg:CC_NZ CC_REG) 
        (compare
          (zero_extract (match_operand:SI 0 "pic30_register_operand" "r")
                        (const_int 1)
                        (match_operand 1 "const_int_operand" "i"))
          (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
  "*
   {
     if (INTVAL(operands[1]) < 16) {
       return \"btst %0,#%1\";
     } else {
       return \"btst %d0,#%1-16\";
     }
   }"
  [
    (set_attr "cc" "set")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*bittstsi_sfr_16"
  [(set (reg:CC_NZ CC_REG) 
        (compare
          (zero_extract (match_operand:SI 0 "pic30_near_operand" "U")
                        (const_int 1)
                        (match_operand 1 "const_int_operand"  "i"))
          (const_int 0))
   )
  ]
  "(!pic30_isa32_target())"
  "btst.b %0+%1/8,#%1%%8"
  [
    (set_attr "cc" "set")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; AND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; quarter integer
;;;;;;;;;;;;;;;;;;

(define_insn "andqi3_DATA_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
               "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R,r")
        (and:QI 
           (match_operand:QI 1 "pic30_mode1J_operand"
               "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P,0")
           (match_operand:QI 2 "pic30_mode1J_operand"
               "r,  R<>,r,R<>,P,  P,r,  r,  r,  r,J")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   and.b %1,%2,%0
   and.b %1,%2,%0
   and.b %1,%2,%0
   and.b %1,%2,%0
   and.b %1,#%2,%0
   and.b %1,#%2,%0
   and.b %2,%1,%0
   and.b %2,%1,%0
   and.b %2,#%1,%0
   and.b %2,#%1,%0
   and.b #%2,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use,def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "andqi3_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
               "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R,r")
        (and:QI 
           (match_operand:QI 1 "pic30_mode1J_APSV_operand"
               "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P,0")
           (match_operand:QI 2 "pic30_mode1J_APSV_operand"
               "r,  R<>,r,R<>,P,  P,r,  r,  r,  r,J")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   and.b %1,%2,%0
   and.b %1,%2,%0
   and.b %1,%2,%0
   and.b %1,%2,%0
   and.b %1,#%2,%0
   and.b %1,#%2,%0
   and.b %2,%1,%0
   and.b %2,%1,%0
   and.b %2,#%1,%0
   and.b %2,#%1,%0
   and.b #%2,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,etc,use,def,use,defuse,use,def,use,def")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "andqi3_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
               "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R,r")
        (and:QI
           (match_operand:QI 1 "pic30_mode1J_or_1bitclr_APSV_operand"
               "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P,0")
           (match_operand:QI 2 "pic30_mode1J_or_1bitclr_APSV_operand"
               "r,  R<>,r,R<>,P,  P,r,  r,  r,  r,J")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],0)) {
    emit(
      gen_bitclrqi_16(operands[0], operands[2], operands[1])
    );
  } else if (pic30_one_bit_set(GET_MODE(operands[0]),operands[2],0)) {
    emit(
      gen_bitclrqi_16(operands[0], operands[1], operands[2])
    );
  } else if (pic30_mode1J_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_mode1J_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_andqi3_DATA_16(operands[0],operands[1],operands[2])
    );
  } else if (pic30_mode1J_APSV_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_mode1J_APSV_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_andqi3_APSV_16(operands[0],operands[1],operands[2])
    );
  } else {
    rtx op1, op2;

    op1 = force_reg(GET_MODE(operands[0]), operands[1]);
    op2 = force_reg(GET_MODE(operands[0]), operands[2]);
    emit(
      gen_andqi3_DATA_16(operands[0],op1,op2)
    );
  }
  DONE;
}")

(define_insn_and_split "*andqi3_sfr0_16"
  [(set (match_operand:QI 0 "pic30_register_operand"           "=a,a, d")
        (and:QI (match_operand:QI 1 "pic30_register_operand"   "%a,d, d")
                (match_operand:QI 2 "pic30_near_operand" " U,U, U")))
   (clobber (match_scratch:HI 3                          "=X,X,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   and.b %2,WREG
   mov.b %1,w0\;and.b %2,WREG
   mov #%2,%3\;and.b %1,[%3],%0"
  "reload_completed && (!pic30_isa32_target())"
  [
   (const_int 0)
  ]
"
{
  if (!pic30_wreg_operand(operands[0], QImode) &&
      !pic30_wreg_operand(operands[1], QImode))
  {
    rtx pop = gen_rtx_MEM(QImode, operands[3]);
    emit_insn(gen_movhi_address_16(operands[3], XEXP(operands[2],0)));
    emit_insn(gen_andqi3_16(operands[0], operands[1], pop));
    DONE;
  }
  else
  {
    FAIL;
  }
}
"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn_and_split "*andqi3_sfr2_16"
  [(set (match_operand:QI 0 "pic30_near_operand"             "=U,U")
        (and:QI (match_operand:QI 1 "pic30_register_operand" "%a,d")
                (match_dup 0)))
   (clobber (match_scratch:HI 2                              "=X,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   and.b %0
   mov #%0,%2\;and.b %1,[%2],[%2]"
  "reload_completed && (!pic30_isa32_target())"
  [
   (const_int 0)
  ]
"
{
  if (!pic30_wreg_operand(operands[1], QImode))
  {
    rtx pop = gen_rtx_MEM(QImode, operands[2]);
    emit_insn(gen_movhi_address_16(operands[2], XEXP(operands[0],0)));
    emit_insn(gen_andqi3_16(pop, operands[1], pop));
    DONE;
  }
  else
  {
    FAIL;
  }
}
"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "etc")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;
;; half integer
;;;;;;;;;;;;;;;

(define_insn "andhi3_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  R<>,r,R,  r<>,R,r<>")
        (and:HI 
          (match_operand:HI 1 "pic30_mode1P_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,P")
          (match_operand:HI 2 "pic30_mode1P_operand"
              "r,  R<>,r,R<>,P,  P,r,  r,  r,r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   and.w %1,%2,%0
   and.w %1,%2,%0
   and.w %1,%2,%0
   and.w %1,%2,%0
   and.w %1,#%2,%0
   and.w %1,#%2,%0
   and.w %2,%1,%0
   and.w %2,%1,%0
   and.w %2,#%1,%0
   and.w %2,#%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use,def,use,use,defuse,use,def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "andhi3_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  R<>,r,R,  r<>,R,r<>")
        (and:HI 
          (match_operand:HI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,P")
          (match_operand:HI 2 "pic30_mode1P_APSV_operand"
              "r,  R<>,r,R<>,P,  P,r,  r,  r,r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   and %1,%2,%0
   and %1,%2,%0
   and %1,%2,%0
   and %1,%2,%0
   and %1,#%2,%0
   and %1,#%2,%0
   and %2,%1,%0
   and %2,%1,%0
   and %2,#%1,%0
   and %2,#%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use,def,use,use,defuse,use,def")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "andhi3_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  R<>,r,R,  r<>,R,r<>")
        (and:HI
          (match_operand:HI 1 "pic30_mode1P_or_1bitclr_APSV_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,P")
          (match_operand:HI 2 "pic30_mode1P_or_1bitclr_APSV_operand"
              "r,  R<>,r,R<>,P,  P,r,  r,  r,r")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],0)) {
    if (!pic30_mode2_operand(operands[2], GET_MODE(operands[2]))) {
      operands[2] = force_reg(GET_MODE(operands[2]), operands[2]);
    }
    emit(
      gen_bitclrhi_16(operands[0], operands[2], operands[1])
    );
  } else if (pic30_one_bit_set(GET_MODE(operands[0]),operands[2],0)) {
    if (!pic30_mode2_operand(operands[1], GET_MODE(operands[1]))) {
      operands[1] = force_reg(GET_MODE(operands[1]), operands[1]);
    }
    emit(
      gen_bitclrhi_16(operands[0], operands[1], operands[2])
    );
  } else if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_mode1P_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_andhi3_DATA_16(operands[0],operands[1],operands[2])
    );
  } else if (pic30_reg_or_near_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_reg_or_near_operand(operands[0],GET_MODE(operands[0])) &&
             pic30_register_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_andhi3_sfr_16(operands[0],operands[1],operands[2])
    );
  } else {
    rtx xop1, xop2;

    xop1 = force_reg(GET_MODE(operands[0]),operands[1]);
    xop2 = force_reg(GET_MODE(operands[0]),operands[2]);
    emit(
      gen_andhi3_APSV_16(operands[0],xop1,xop2)
    );
  }
  DONE;
}")

(define_insn "andhi3_sfr_16"
  [(set (match_operand:HI   0 "pic30_reg_or_near_operand" "=U,U,U,a,r,r")
        (and:HI
          (match_operand:HI 1 "pic30_reg_or_near_operand" "%0,0,r,U,U,r")
          (match_operand:HI 2 "pic30_register_operand"    " a,r,r,a,r,r"))
   )
   (clobber 
          (match_scratch:HI 3                             "=X,r,r,X,&r,X"))
   (clobber (reg:CC_NZ CC_REG)) 
  ]
  "(!pic30_isa32_target())"
  "@
   and %0
   mov #%0,%3\;and %2,[%3],[%3]
   and %1,%2,%3\;mov %3,%0
   and %1,WREG
   mov %1,%3\;and %2,%3,%0
   and %1,%2,%0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "etc,etc,etc,def,def,def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*andhi3_imm_16"
  [(set (match_operand:HI 0 "pic30_register_operand"         "=r")
        (and:HI (match_operand:HI 1 "pic30_register_operand" "%0")
                 (match_operand:HI 2 "pic30_J_operand"  "J")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "and #%2,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;;;;
;;    gcc will FORCE a reload for a memory operation if it is a SUBREG -
;;    if the pattern doesn't have a register option, then reload will fail
;;    even though some machines (like dsPIC) can read a byte or hi mode just
;;    fine
;;;;
(define_insn "*andhi3_sfr2_16"
  [(set (match_operand:HI 0 "pic30_register_operand"          "=a,  r, r")
        (and:HI (match_operand:HI 1 "pic30_register_operand"  " 0,  r, r")
                (match_operand:HI 2 "pic30_reg_or_near_operand"
                                                              " U,  U, r")))
   (clobber (match_scratch:HI     3                           "=X,  &r,X"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   and %2,WREG
   mov %2,%3\;and %3,%1,%0
   and %1,%2,%0"
  [
   (set_attr "cc" "set") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;
;; single integer
;;;;;;;;;;;;;;;;;
(define_expand "andsi3_16"
 [(set (match_operand:SI 0 "pic30_mode2_operand"
			"=r<>,r<>,&r<>,R,R,R,R, R, r<>")
       (and:SI (match_operand:SI 1 "pic30_mode1P_operand"
			"%r,  r,   r,  r,r,r,r, r, r")
               (match_operand:SI 2 "pic30_mode1P_operand"
			 "r  ,<>,  R,  0,R,r,<>,P, P")))
 ]
 "(!pic30_isa32_target())"
 "
{
  if (GET_CODE(operands[2]) == CONST_INT) {
    HOST_WIDE_INT lo,hi;
    lo = trunc_int_for_mode(INTVAL(operands[2]),HImode);
    hi = trunc_int_for_mode(INTVAL(operands[2]) >> 16,HImode);

    emit_insn(
      gen_andhi3_16(gen_rtx_SUBREG(HImode, operands[0], 0),
                    gen_rtx_SUBREG(HImode, operands[1], 0),
                    GEN_INT(lo))
    );
    emit_insn(
      gen_andhi3_16(gen_rtx_SUBREG(HImode, operands[0], 2),
                    gen_rtx_SUBREG(HImode, operands[1], 2),
                    GEN_INT(hi))
    );
    DONE;
  } else {
    rtx operands_2 = force_reg(SImode, operands[2]);

    emit_insn(
      gen_andhi3_16(gen_rtx_SUBREG(HImode, operands[0], 0),
                    gen_rtx_SUBREG(HImode, operands[1], 0),
                    gen_rtx_SUBREG(HImode, operands_2, 0))
    );
    emit_insn(
      gen_andhi3_16(gen_rtx_SUBREG(HImode, operands[0], 2),
                    gen_rtx_SUBREG(HImode, operands[1], 2),
                    gen_rtx_SUBREG(HImode, operands_2, 2))
    );

    DONE;
  }
}")

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn_and_split "*andsi3_sfr0_16"
  [(set (match_operand:SI 0 "pic30_data_operand"      "=T")
        (and:SI (match_dup 0)
                (match_operand:SI 1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2 "=&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "mov #%0,%2\;and %1,[%2],[%2]\;and %d1,[++%2],[%2]"
  "reload_completed && (!pic30_isa32_target())"
  [
   (const_int 0)
  ]
"
  {
  	rtx pop = gen_rtx_MEM(SImode, operands[2]);
	emit_insn(gen_movhi_address_16(operands[2], XEXP(operands[0],0)));
	emit_insn(gen_andsi3_16(pop, operands[1], pop));
	DONE;
  }
"
  [
   (set_attr "cc" "clobber")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
(define_insn_and_split "*andsi3_sfr1_16"
  [(set (match_operand:SI 0 "pic30_data_operand"      "=T")
        (and:SI (match_operand:SI 1 "pic30_register_operand" "r")
                (match_dup 0)))
   (clobber (match_scratch:HI 2         "=&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "mov #%0,%2\;and %1,[%2],[%2]\;and %d1,[++%2],[%2]"
  "reload_completed && (!pic30_isa32_target())"
  [
   (const_int 0)
  ]
"
  {
  	rtx pop = gen_rtx_MEM(SImode, operands[2]);
	emit_insn(gen_movhi_address_16(operands[2], XEXP(operands[0],0)));
	emit_insn(gen_andsi3_16(pop, operands[1], pop));
	DONE;
  }
"
  [
   (set_attr "cc" "clobber")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;
;; double integer
;;;;;;;;;;;;;;;;;

(define_insn "*andhidi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (sign_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;and %1,%2,%0\;and %3,%d2,%d0\;\"
                              \"and %3,%t2,%t0\;and %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;and %1,%2,%0\;and %3,%d2,%0\;\"
                              \"and %3,%t2,%0\;and %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;and %1,%s2,%0\;and %3,%s2,%0\;\"
                              \"and %3,%s2,%0\;and %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;and %1,%2,%0\;and %3,%2,%0\;\"
                              \"and %3,%2,%0\;and %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;and %1,%2,%0\;and %3,%2,%d0\;\"
                              \"and %3,%2,%t0\;and %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;and %1,%2,%I0\;and %3,%d2,%I0\;\"
                              \"and %3,%t2,%I0\;and %3,%q2,%s0\",

     /* R,r,0 */          \"asr %1,#15,%3\;and %1,%2,%I0\;and %3,%2,%I0\;\"
                              \"and %3,%2,%I0\;and %3,%2,%s0\",

     /* R,r,R */          \"asr %1,#15,%3\;and %1,%I2,%I0\;and %3,%I2,%I0\;\"
                              \"and %3,%I2,%I0\;and %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;and %1,%I2,%0\;and %3,%I2,%d0\;\"
                              \"and %3,%I2,%t0\;and %3,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;and %1,%2,%0\;and %3,%d2,%d0\;\"
                              \"and %3,%t2,%t0\;and %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;and %1,%2,%0\;and %3,%d2,%0\;\"
                              \"and %3,%t2,%0\;and %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;and %1,%s2,%0\;and %3,%s2,%0\;\"
                              \"and %3,%s2,%0\;and %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;\"
                          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;\"
                          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %3,%2,%d0\;\"
                          \"nop\;\"
                          \"and %3,%2,%t0\;\"
                          \"nop\;\"
                          \"and %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;and %1,%2,%I0\;and %3,%d2,%I0\;\"
                              \"and %3,%t2,%I0\;and %3,%q2,%s0\",

     /* R,r,0 */          \"asr %1,#15,%3\;and %1,%2,%I0\;and %3,%2,%I0\;\"
                              \"and %3,%2,%I0\;and %3,%2,%s0\",

     /* R,r,R */          \"asr %1,#15,%3\;\"
                          \"and %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;\"
                          \"and %1,%I2,%0\;\"
                          \"nop\;\"
                          \"and %3,%I2,%d0\;\"
                          \"nop\;\"
                          \"and %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"and %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*andhidi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (zero_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R"))
   )
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;clr %d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;clr %0\;clr %0\;clr %0\",

     /* >,r,0 */          \"and %1,%s2,%0\;clr %0\;clr %0\;clr %0\",

     /* >,r,> */          \"and %1,%2,%0\;clr %0\;clr %0\;clr %0\",

     /* r,r,> */          \"and %1,%2,%0\;clr %d0\;mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;clr %I0\;clr %I0\;clr %0\",

     /* R,r,0 */          \"and %1,%2,%I0\;clr %I0\;clr %I0\;clr %I0\",

     /* R,r,R */          \"and %1,%2,%I0\;clr %I0\;clr %I0\;clr %I0\",

     /* r,r,R */          \"and %1,%2,%0\;clr %d0\;mul.uu %t0,#0,%t0\"
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;clr %d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;clr %0\;clr %0\;clr %0\",

     /* >,r,0 */          \"and %1,%s2,%0\;clr %0\;clr %0\;clr %0\",

     /* >,r,> */          \"and %1,%2,%0\;\"
                          \"clr %0\;\"
                          \"clr %0\;\"
                          \"clr %0\",

     /* r,r,> */          \"and %1,%2,%0\;\"
                          \"clr %d0\;\"
                          \"mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;clr %I0\;clr %I0\;clr %0\",

     /* R,r,0 */          \"and %1,%2,%I0\;clr %I0\;clr %I0\;clr %I0\",

     /* R,r,R */          \"and %1,%2,%I0\;\"
                          \"clr %I0\;\"
                          \"clr %I0\;\"
                          \"clr %I0\",

     /* r,r,R */          \"and %1,%2,%0\;\"
                          \"clr %d0\;\"
                          \"mul.uu %t0,#0,%t0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 3:  /* >,r,> */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #6,%r2\");
              }
              return szInsns;

     case 4:  /* r,r,> */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #6,%r2\");
              }
              return szInsns;

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*andsidi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (sign_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;and %1,%2,%0\;and %d1,%d2,%d0\;\"
                              \"and %3,%t2,%t0\;and %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;and %1,%2,%0\;and %d1,%d2,%0\;\"
                              \"and %3,%t2,%0\;and %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;and %1,%s2,%0\;and %d1,%s2,%0\;\"
                              \"and %3,%s2,%0\;and %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;and %1,%2,%0\;and %d1,%2,%0\;\"
                              \"and %3,%2,%0\;and %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;and %1,%2,%0\;and %d1,%2,%d0\;\"
                              \"and %3,%2,%t0\;and %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;and %1,%2,%I0\;and %d1,%d2,%I0\;\"
                              \"and %3,%t2,%I0\;and %3,%q2,%s0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;and %1,%2,%I0\;and %d1,%2,%I0\;\"
                              \"and %3,%2,%I0\;and %3,%2,%s0\",

     /* R,r,R */          \"asr %d1,#15,%3\;and %1,%I2,%I0\;and %d1,%I2,%I0\;\"
                              \"and %3,%I2,%I0\;and %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;and %1,%I2,%0\;and %d1,%I2,%d0\;\"
                              \"and %3,%I2,%t0\;and %3,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;and %1,%2,%0\;and %d1,%d2,%d0\;\"
                              \"and %3,%t2,%t0\;and %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;and %1,%2,%0\;and %d1,%d2,%0\;\"
                              \"and %3,%t2,%0\;and %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;and %1,%s2,%0\;and %d1,%s2,%0\;\"
                              \"and %3,%s2,%0\;and %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;\"
                          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%2,%0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;\"
                          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"and %3,%2,%t0\;\"
                          \"nop\;\"
                          \"and %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;and %1,%2,%I0\;and %d1,%d2,%I0\;\"
                              \"and %3,%t2,%I0\;and %3,%q2,%s0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;and %1,%2,%I0\;and %d1,%2,%I0\;\"
                              \"and %3,%2,%I0\;and %3,%2,%s0\",

     /* R,r,R */          \"asr %d1,#15,%3\;\"
                          \"and %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;\"
                          \"and %1,%I2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"and %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"and %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*andsidi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (zero_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R"))
   )
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;and %d1,%d2,%d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;and %d1,%d2,%0\;clr %0\;clr %0\",

     /* >,r,0 */          \"and %1,%s2,%0\;and %d1,%s2,%0\;clr %0\;clr %0\",

     /* >,r,> */          \"and %1,%2,%0\;and %d1,%2,%0\;clr %0\;clr %0\",

     /* r,r,> */          \"and %1,%2,%0\;and %d1,%2,%d0\;mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;and %d1,%d2,%I0\;clr %I0\;clr %0\",

     /* R,r,0 */          \"and %1,%2,%I0\;and %d1,%2,%I0\;clr %I0\;clr %0\",

     /* R,r,R */          \"and %1,%I2,%I0\;and %d1,%D2,%I0\;clr %I0\;clr %0\",

     /* r,r,R */          \"and %1,%I2,%0\;and %d1,%D2,%d0\;mul.uu %t0,#0,%t0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;and %d1,%d2,%d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;and %d1,%d2,%0\;clr %0\;clr %0\",

     /* >,r,0 */          \"and %1,%s2,%0\;and %d1,%s2,%0\;clr %0\;clr %0\",

     /* >,r,> */          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%2,%0\;\"
                          \"clr %0\;\"
                          \"clr %0\",

     /* r,r,> */          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%2,%d0\;\"
                          \"mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;and %d1,%d2,%I0\;clr %I0\;clr %0\",

     /* R,r,0 */          \"and %1,%2,%I0\;and %d1,%2,%I0\;clr %I0\;clr %0\",

     /* R,r,R */          \"and %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %d1,%D2,%I0\;\"
                          \"clr %I0\;\"
                          \"clr %0\",

     /* r,r,R */          \"and %1,%I2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%D2,%d0\;\"
                          \"mul.uu %t0,#0,%t0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops++;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 3:  /* >,r,> */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #4,%r2\");
              }
              return szInsns;

     case 4:  /* r,r,> */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #4,%r2\");
              }
              return szInsns;

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*anddihi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
    )
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;and %1,%2,%0\;and %d1,%3,%d0\;\"
                              \"and %t1,%3,%t0\;and %q1,%3,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;and %1,%2,%0\;and %d1,%3,%0\;\"
                              \"and %t1,%3,%0\;and %q1,%3,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;and %2,%s1,%0\;and %3,%s1,%0\;\"
                              \"and %3,%s1,%0\;and %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;and %2,%1,%0\;and %3,%1,%0\;\"
                              \"and %3,%1,%0\;and %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;and %2,%1,%0\;and %3,%1,%d0\;\"
                              \"and %3,%1,%t0\;and %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;and %1,%2,%I0\;and %3,%d1,%I0\;\"
                              \"and %3,%t1,%I0\;and %3,%q1,%s0\",

     /* R,0,r */          \"asr %2,#15,%3\;and %2,%1,%I0\;and %3,%1,%I0\;\"
                              \"and %3,%1,%I0\;and %3,%1,%0\",

     /* R,R,r */          \"asr %2,#15,%3\;and %2,%I1,%I0\;and %3,%I1,%I0\;\"
                              \"and %3,%I1,%I0\;and %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;and %2,%I1,%0\;and %3,%I1,%d0\;\"
                              \"and %3,%I1,%t0\;and %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;and %1,%2,%0\;and %d1,%3,%d0\;\"
                              \"and %t1,%3,%t0\;and %q1,%3,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;and %1,%2,%0\;and %d1,%3,%0\;\"
                              \"and %t1,%3,%0\;and %q1,%3,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;and %2,%s1,%0\;and %3,%s1,%0\;\"
                              \"and %3,%s1,%0\;and %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;\"
                          \"and %2,%1,%0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;\"
                          \"and %2,%1,%0\;\"
                          \"nop\;\"
                          \"and %3,%1,%d0\;\"
                          \"nop\;\"
                          \"and %3,%1,%t0\;\"
                          \"nop\;\"
                          \"and %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;and %1,%2,%I0\;and %3,%d1,%I0\;\"
                              \"and %3,%t1,%I0\;and %3,%q1,%s0\",

     /* R,0,r */          \"asr %2,#15,%3\;and %2,%1,%I0\;and %3,%1,%I0\;\"
                              \"and %3,%1,%I0\;and %3,%1,%0\",

     /* R,R,r */          \"asr %2,#15,%3\;\"
                          \"and %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;\"
                          \"and %2,%I1,%0\;\"
                          \"nop\;\"
                          \"and %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"and %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"and %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*anddihi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;clr %d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;clr %0\;clr %0\;clr %0\",

     /* >,0,r */          \"and %2,%s1,%0\;clr %0\;clr %0\;clr %0\",

     /* >,>,r */          \"and %2,%1,%0\;clr %0\;clr %0\;clr %0\",

     /* r,>,r */          \"and %2,%1,%0\;clr %d0\;mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;clr %I0\;clr %I0\;clr %0\",

     /* R,0,r */          \"and %2,%1,%I0\;clr %I0\;clr %I0\;clr %0\",

     /* R,R,r */          \"and %2,%1,%I0\;clr %I0\;clr %I0\;clr %0\",

     /* r,R,r */          \"and %2,%1,%0\;clr %d0\;mul.uu %t0,#0,%t0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[160];
  rtx x;

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 3:  /* >,>,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #6,%r1\");
              }
              return szInsns;

     case 4:  /* r,>,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #6,%r1\");
              }
              return szInsns;

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*anddisi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;and %1,%2,%0\;and %d1,%d2,%d0\;\"
                              \"and %t1,%3,%t0\;and %q1,%3,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;and %1,%2,%0\;and %d1,%d2,%0\;\"
                              \"and %t2,%3,%0\;and %q1,%3,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;and %2,%s1,%0\;and %d2,%s1,%0\;\"
                              \"and %3,%s1,%0\;and %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;and %2,%1,%0\;and %d2,%1,%0\;\"
                              \"and %3,%1,%0\;and %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;and %2,%1,%0\;and %d2,%1,%d0\;\"
                              \"and %3,%1,%t0\;and %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;and %1,%2,%I0\;and %d1,%d2,%I0\;\"
                              \"and %t1,%3,%I0\;and %q1,%3,%0\",

     /* R,0,r */          \"asr %d2,#15,%3\;and %2,%1,%I0\;and %d2,%1,%I0\;\"
                              \"and %3,%1,%I0\;and %3,%1,%0\",

     /* R,R,r */          \"asr %d2,#15,%3\;and %2,%I1,%I0\;and %d2,%I1,%I0\;\"
                              \"and %2,%I1,%I0\;and %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;and %2,%I1,%0\;and %d2,%I1,%d0\;\"
                              \"and %3,%I1,%t0\;and %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;and %1,%2,%0\;and %d1,%d2,%d0\;\"
                              \"and %t1,%3,%t0\;and %q1,%3,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;and %1,%2,%0\;and %d1,%d2,%0\;\"
                              \"and %t2,%3,%0\;and %q1,%3,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;and %2,%s1,%0\;and %d2,%s1,%0\;\"
                              \"and %3,%s1,%0\;and %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;\"
                          \"and %2,%1,%0\;\"
                          \"nop\;\"
                          \"and %d2,%1,%0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;\"
                          \"and %2,%1,%0\;\"
                          \"nop\;\"
                          \"and %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"and %3,%1,%t0\;\"
                          \"nop\;\"
                          \"and %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;and %1,%2,%I0\;and %d1,%d2,%I0\;\"
                              \"and %t1,%3,%I0\;and %q1,%3,%0\",

     /* R,0,r */          \"asr %d2,#15,%3\;and %2,%1,%I0\;and %d2,%1,%I0\;\"
                              \"and %3,%1,%I0\;and %3,%1,%0\",

     /* R,R,r */          \"asr %d2,#15,%3\;\"
                          \"and %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;\"
                          \"and %2,%I1,%0\;\"
                          \"nop\;\"
                          \"and %d2,%I1,%d0\;\"
                          \"nop\;\"
                          \"and %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"and %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*anddisi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (and:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;and %d1,%d2,%d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;and %d1,%d2,%0\;clr %0\;clr %0\",

     /* >,0,r */          \"and %2,%s1,%0\;and %d2,%s1,%0\;clr %0\;clr %0\",

     /* >,>,r */          \"and %2,%1,%0\;and %d2,%1,%0\;clr %0\;clr %0\",

     /* r,>,r */          \"and %2,%1,%0\;and %d2,%1,%d0\;mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;and %d1,%d2,%I0\;clr %I0\;clr %0\",

     /* R,0,r */          \"and %2,%1,%I0\;and %d2,%1,%I0\;clr %I0\;clr %0\",

     /* R,R,r */          \"and %2,%I1,%I0\;and %d2,%D1,%I0\;clr %I0\;clr %0\",

     /* r,R,r */          \"and %2,%I1,%0\;and %d2,%D1,%d0\;mul.uu %t0,#0,%t0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;and %d1,%d2,%d0\;mul.uu %t0,#0,%t0\",

     /* >,r,r */          \"and %1,%2,%0\;and %d1,%d2,%0\;clr %0\;clr %0\",

     /* >,0,r */          \"and %2,%s1,%0\;and %d2,%s1,%0\;clr %0\;clr %0\",

     /* >,>,r */          \"and %2,%1,%0\;\"
                          \"nop\;\"
                          \"and %d2,%1,%0\;\"
                          \"clr %0\;\"
                          \"clr %0\",

     /* r,>,r */          \"and %2,%1,%0\;\"
                          \"nop\;\"
                          \"and %d2,%1,%d0\;\"
                          \"mul.uu %t0,#0,%t0\",

     /* R,r,r */          \"and %1,%2,%I0\;\"
                          \"nop\;\"
                          \"and %d1,%d2,%I0\;\"
                          \"clr %I0\;\"
                          \"clr %0\",

     /* R,0,r */          \"and %2,%1,%I0\;\"
                          \"and %d2,%1,%I0\;\"
                          \"clr %I0\;\"
                          \"clr %0\",

     /* R,R,r */          \"and %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"and %d2,%D1,%I0\;\"
                          \"clr %I0\;\"
                          \"clr %0\",

     /* r,R,r */          \"and %2,%I1,%0\;\"
                          \"nop\;\"
                          \"and %d2,%D1,%d0\;\"
                          \"mul.uu %t0,#0,%t0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[170];
  const char **patterns;
  rtx x;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops++;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 3:  /* >,>,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #4,%r1\");
              }
              return szInsns;

     case 4:  /* r,>,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;add #4,%r1\");
              }
              return szInsns;

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "anddi3_16"
  [(set (match_operand:DI   0 "pic30_DI_mode2_operand"  "=r,>,>,>,&r,R,R,R,&r,&r")
        (and:DI
          (match_operand:DI 1 "pic30_reg_or_lit"        "%r,r,r,r, r,r,r,r, r,i")
          (match_operand:DI 2 "pic30_DI_mode2_operand"  " r,r,0,>, >,r,0,R, R,r")
   ))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;and %d1,%d2,%d0\;\"
                              \"and %t1,%t2,%t0\;and %q1,%q2,%q0\",

     /* >,r,r */          \"and %1,%2,%0\;and %d1,%d2,%0\;\"
                              \"and %t1,%t2,%0\;and %q1,%q2,%0\",

     /* >,r,0 */          \"and %1,%s2,%0\;and %d1,%s2,%0\;\"
                              \"and %t1,%s2,%0\;and %q1,%s2,%0\",

     /* >,r,> */          \"and %1,%2,%0\;and %d1,%2,%0\;\"
                              \"and %t1,%2,%0\;and %q1,%2,%0\",

     /* r,r,> */          \"and %1,%2,%0\;and %d1,%2,%d0\;\"
                              \"and %t1,%2,%t0\;and %q1,%2,%q0\",

     /* R,r,r */          \"and %1,%2,%I0\;and %d1,%d2,%I0\;\"
                              \"and %t1,%t2,%I0\;and %q1,%q2,%0\",

     /* R,r,0 */          \"and %1,%2,%I0\;and %d1,%2,%I0\;\"
                              \"and %t1,%2,%I0\;and %q1,%2,%0\",

     /* R,r,R */          \"and %1,%I2,%I0\;and %d1,%I2,%I0\;\"
                              \"and %t1,%I2,%I0\;and %q1,%2,%0\",

     /* r,r,R */          \"and %1,%I2,%0\;and %d1,%I2,%d0\;\"
                              \"and %t1,%I2,%t0\;and %q1,%2,%q0\",

  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"and %1,%2,%0\;and %d1,%d2,%d0\;\"
                              \"and %t1,%t2,%t0\;and %q1,%q2,%q0\",

     /* >,r,r */          \"and %1,%2,%0\;and %d1,%d2,%0\;\"
                              \"and %t1,%t2,%0\;and %q1,%q2,%0\",

     /* >,r,0 */          \"and %1,%s2,%0\;and %d1,%s2,%0\;\"
                              \"and %t1,%s2,%0\;and %q1,%s2,%0\",

     /* >,r,> */          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%2,%0\;\"
                          \"nop\;\"
                          \"and %t1,%2,%0\;\"
                          \"nop\;\"
                          \"and %q1,%2,%0\",

     /* r,r,> */          \"and %1,%2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"and %t1,%2,%t0\;\"
                          \"nop\;\"
                          \"and %q1,%2,%q0\",

     /* R,r,r */          \"and %1,%2,%I0\;and %d1,%d2,%I0\;\"
                              \"and %t1,%t2,%I0\;and %q1,%q2,%0\",

     /* R,r,0 */          \"and %1,%2,%I0\;\"
                          \"and %d1,%2,%I0\;\"
                          \"and %t1,%2,%I0\;\"
                          \"and %q1,%2,%0\",

     /* R,r,R */          \"and %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %t1,%I2,%I0\;\"
                          \"nop\;\"
                          \"and %q1,%2,%0\",

     /* r,r,R */          \"and %1,%I2,%0\;\"
                          \"nop\;\"
                          \"and %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"and %t1,%I2,%t0\;\"
                          \"nop\;\"
                          \"and %q1,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  const char **patterns;
  rtx x;
 
  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 9:  /* r,i,r */
              { char *op = \"and\";
                HOST_WIDE_INT i = INTVAL(operands[1]);
                int m[4];
                int done = 0;
                int j,k;
                char *c=szInsns;
 
                szInsns[0] = 0;
                m[0] = (i)       & (0xFFFF);
                m[1] = (i >> 16) & (0xFFFF);
                m[2] = (i >> 32) & (0xFFFF);
                m[3] = (i >> 48) & (0xFFFF);
               
                for (j = 3; j > 0; j--) {
                  if (done & (1<<j)) continue;  // masked already
                  c += sprintf(c,\"mov #0x%x,w%d\;\",m[j],REGNO(operands[0])+j);
                  done |= (1<<j);
                  for (k = 0; k < j; k++) {
                    if (done & (1<<k)) continue; // masked already
                    if (m[k] == m[j]) {
                      c += sprintf(c,\"%s w%d,w%d,w%d\;\",
                                      op, 
                                      REGNO(operands[2])+k,
                                      REGNO(operands[0])+j,
                                      REGNO(operands[0])+k);
                      done |= (1<<k);
                    }
                  }
                  c += sprintf(c,\"%s w%d,w%d,w%d\;\",
                                  op, 
                                  REGNO(operands[2])+j,
                                  REGNO(operands[0])+j,
                                  REGNO(operands[0])+j);
                }
                return szInsns;
              }
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; quarter integer
;;;;;;;;;;;;;;;;;;

(define_insn "*iorqi3_imm_16"
  [(set (match_operand:QI 0 "pic30_register_operand"         "=r")
        (ior:QI (match_operand:QI 1 "pic30_register_operand" "%0")
                (match_operand:QI 2 "pic30_J_operand"   "J")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "ior.b #%2,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "iorqi3_DATA_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R")
        (ior:QI 
           (match_operand:QI 1 "pic30_mode1P_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:QI 2 "pic30_mode1P_operand"
              "r,  R<>,r,R<>,P,  P,r,  r,  r,  r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   ior.b %1,%2,%0
   ior.b %1,%2,%0
   ior.b %1,%2,%0
   ior.b %1,%2,%0
   ior.b %1,#%2,%0
   ior.b %1,#%2,%0
   ior.b %2,%1,%0
   ior.b %2,%1,%0
   ior.b %2,#%1,%0
   ior.b %2,#%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "iorqi3_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R")
        (ior:QI 
           (match_operand:QI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:QI 2 "pic30_mode1P_APSV_operand"
              "r,  R<>,r,R<>,P,  P,r,  r,  r,  r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   ior.b %1,%2,%0
   ior.b %1,%2,%0
   ior.b %1,%2,%0
   ior.b %1,%2,%0
   ior.b %1,#%2,%0
   ior.b %1,#%2,%0
   ior.b %2,%1,%0
   ior.b %2,%1,%0
   ior.b %2,#%1,%0
   ior.b %2,#%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "iorqi3_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R")
        (ior:QI
           (match_operand:QI 1 "pic30_mode1P_or_1bit_APSV_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:QI 2 "pic30_mode1P_or_1bit_APSV_operand"
              "r,  R<>,r,R<>,P,  P,r,  r,  r,  r")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1)) {
    emit(
      gen_bitsetqi_16(operands[0], operands[2], operands[1])
    );
  } else if (pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1)) {
    emit(
      gen_bitsetqi_16(operands[0], operands[1], operands[2])
    );
  } else if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_mode1P_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_iorqi3_DATA_16(operands[0],operands[1],operands[2])
    );
  } else if (pic30_mode1P_APSV_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_mode1P_APSV_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
     gen_iorqi3_APSV_16(operands[0],operands[1],operands[2])
    );
  } else {
    rtx op1,op2;

    op1 = force_reg(GET_MODE(operands[0]),operands[1]);
    op2 = force_reg(GET_MODE(operands[0]),operands[2]);
    emit(
      gen_iorqi3_DATA_16(operands[0],op1,op2)
    );
  }
  DONE;
}")

(define_insn_and_split "*iorqi3_sfr0_16"
  [(set (match_operand:QI 0 "pic30_register_operand"           "=a,a,r")
        (ior:QI (match_operand:QI 1 "pic30_register_operand"   "%a,d,r")
                (match_operand:QI 2 "pic30_near_operand" " U,U,U")))
   (clobber (match_scratch: HI 3                         "=X,X,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   ior.b %2,WREG
   mov.b %1,w0\;ior.b %2,WREG
   mov #%2,%3\;ior.b %1,[%3],%0"
  "reload_completed && (!pic30_isa32_target())"
  [
   (const_int 0)
  ]
"
{
  if (!pic30_wreg_operand(operands[0], QImode) &&
      !pic30_wreg_operand(operands[1], QImode))
  {
  	rtx pop = gen_rtx_MEM(QImode, operands[3]);
	emit_insn(gen_movhi_address_16(operands[3], XEXP(operands[2],0)));
	emit_insn(gen_iorqi3_16(operands[0], operands[1], pop));
  	DONE;
  }
  else
  {
  	FAIL;
  }
}
"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 1 cannot interfere with reload (CAW)
 (define_insn "*iorqi3_sfr1_16"
   [(set (match_operand:QI 0 "pic30_near_operand"      "=U, U")
         (ior:QI (match_dup 0)
                 (match_operand:QI 1 "pic30_register_operand" "a, !d")))
    (clobber (match_scratch:HI 2          "=X, &r"))
    (clobber (reg:CC_NZ CC_REG))
   ]
   "(!pic30_isa32_target())"
   "@
    ior.b %0
    mov #%0,%2\;ior.b %1,[%2],[%2]"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;
;; half integer
;;;;;;;;;;;;;;;

; this match_can cause issues iff operand 1 is dies in this instruction and
;   we decide to use it to reload operand 0 (CAW)
(define_insn "iorhi3_sfr0_16"
  [(set (match_operand:HI 0         "pic30_reg_or_near_operand" "=U,a,r")
        (ior:HI (match_operand:HI 1 "pic30_register_operand"    "%a,0,r")
                (match_operand:HI 2 "pic30_reg_or_near_operand" " 0,U,r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   ior %0
   ior %2,WREG
   ior %2,%1,%0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "etc,def,def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*iorhi3_imm_16"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r,r")
        (ior:HI (match_operand:HI 1 "pic30_register_operand" "0,r")
                (match_operand:HI 2 "pic30_J_operand"        "J,P")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   ior #%2,%0
   ior %1,#%2,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*iorhi3_imma_16"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r,r")
        (ior:HI (match_operand:HI 1 "pic30_J_operand"        "J,P")
                (match_operand:HI 2 "pic30_register_operand" "0,r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   ior #%1,%0
   ior %2,#%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "iorhi3_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,  R,r<>,R,r<>,R,  r<>,R")
        (ior:HI 
           (match_operand:HI 1 "pic30_mode1P_operand"
              "%r,  r,  r,  r,r,  r,R<>,R<>,P,  P")
           (match_operand:HI 2 "pic30_mode1P_operand"
              "R<>,r,  R<>,r,P,  P,r,  r,  r,  r")))
   (clobber (reg:CC_NZ CC_REG)) 
  ]
  "(!pic30_isa32_target())"
  "@
   ior %1,%2,%0
   ior %1,%2,%0
   ior %1,%2,%0
   ior %1,%2,%0
   ior %1,#%2,%0
   ior %1,#%2,%0
   ior %2,%1,%0
   ior %2,%1,%0
   ior %2,#%1,%0
   ior %2,#%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "defuse,def,use,use,def,use,defuse,use,def,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "iorhi3_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,  R,r<>,R,r<>,R,  r<>,R")
        (ior:HI 
           (match_operand:HI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,  r,  r,r,  r,R<>,R<>,P,  P")
           (match_operand:HI 2 "pic30_mode1P_APSV_operand"
              "R<>,r,  R<>,r,P,  P,r,  r,  r,  r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   ior %1,%2,%0
   ior %1,%2,%0
   ior %1,%2,%0
   ior %1,%2,%0
   ior %1,#%2,%0
   ior %1,#%2,%0
   ior %2,%1,%0
   ior %2,%1,%0
   ior %2,#%1,%0
   ior %2,#%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "defuse,def,use,use,def,use,defuse,use,def,use")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "iorhi3_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,  R,r<>,R,r<>,R,  r<>,R")
        (ior:HI
           (match_operand:HI 1 "pic30_mode1P_or_1bit_APSV_operand"
              "%r,  r,  r,  r,r,  r,R<>,R<>,P,  P")
           (match_operand:HI 2 "pic30_mode1P_or_1bit_APSV_operand"
              "R<>,r,  R<>,r,P,  P,r,  r,  r,  r")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1)) {
    emit(
      gen_bitsethi_16(operands[0], operands[2], operands[1])
    );
  } else if (pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1)) {
    emit(
      gen_bitsethi_16(operands[0], operands[1], operands[2])
    );
  } else if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_mode1P_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_iorhi3_DATA_16(operands[0],operands[1],operands[2])
    );
  } else {
    rtx xop1, xop2;

    xop1 = force_reg(GET_MODE(operands[0]),operands[1]);
    xop2 = force_reg(GET_MODE(operands[0]),operands[2]);
    emit(
      gen_iorhi3_APSV_16(operands[0],xop1,xop2)
    );
  }
  DONE;
}")

(define_insn "*iorhi3_sfr1_16"
   [(set (match_operand:HI 0 "pic30_near_operand"            "=U, U")
         (ior:HI (match_dup 0)
                 (match_operand:HI 1 "pic30_register_operand" "a, !d")))
    (clobber (match_scratch:HI 2                             "=X, &r"))
    (clobber (reg:CC_NZ CC_REG))
   ]
   "(!pic30_isa32_target())"
   "@
    ior %0
    mov #%0,%2\;ior %1,[%2],[%2]"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "op_type" "alu")
  ]
)


;;;;;;;;;;;;;;;;;
;; single integer
;;;;;;;;;;;;;;;;;

(define_insn "ior<mode>3_DATA_16"
 [(set (match_operand:GM32BIT 0 "pic30_mode2_operand"
             "=r,&r, R,R,R, r,R,<>,<>,R,<>")
       (ior:GM32BIT 
          (match_operand:GM32BIT 1 "pic30_mode1P_operand"
             "%r, r, r,r,r, 0,r, r, r, r, r")
          (match_operand:GM32BIT 2 "pic30_mode1P_operand"
             " r, R, 0,R,r, P,P, <>,R,<>,P")))
  (clobber (reg:CC_NZ CC_REG))
 ]
 "(!pic30_isa32_target())"
 "*
  static const char *noerrata_normal_patterns[] = {
    \"ior %1,%2,%0\;ior %d1,%d2,%d0\",
    \"ior %1,%I2,%0\;ior %d1,%D2,%d0\",
    \"ior %1,%2,%I0\;ior %d1,%2,%D0\",
    \"ior %1,%I2,%I0\;ior %d1,%D2,%D0\",
    \"ior %1,%2,%I0\;ior %d1,%d2,%D0\",
    \"ior %1,#%2,%0\",
    \"ior %1,#%2,%I0\;mov %d1,%D0\",
    \"ior %1,%2,%0\;ior %d1,%2,%0\",
    \"ior %1,%I2,%0\;ior %d1,%D2,%0\",
    \"ior %1,%2,%I0\;ior %d1,%2,%D0\",
    \"ior %1,#%2,%0\;ior %d1,#0,%0\"
  };

  static const char *noerrata_pre_patterns[] = {
    \"add %r0,#4,%r0\;ior %1,%I2,%I0\;ior %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;ior %1,%I2,%I0\;ior %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;ior %1,#%2,%I0\;ior %d1,#0,%D0\"
  };

  static const char *psv_psv_normal_patterns[] = {
    \"ior %1,%2,%0\;ior %d1,%d2,%d0\",
    \"ior %1,%I2,%0\;nop\;ior %d1,%D2,%d0\",
    \"ior %1,%2,%I0\;ior %d1,%2,%D0\",
    \"ior %1,%I2,%I0\;nop\;ior %d1,%D2,%D0\",
    \"ior %1,%2,%I0\;ior %d1,%d2,%D0\",
    \"ior %1,#%2,%0\",
    \"ior %1,#%2,%I0\;mov %d1,%D0\",
    \"ior %1,%2,%0\;nop\;ior %d1,%2,%0\",
    \"ior %1,%I2,%0\;nop\;ior %d1,%D2,%0\",
    \"ior %1,%2,%I0\;nop\;ior %d1,%2,%D0\",
    \"ior %1,#%2,%0\;nop\;ior %d1,#0,%0\"
  };

  static const char *psv_psv_pre_patterns[] = {
    \"add %r0,#4,%r0\;ior %1,%I2,%I0\;nop\;ior %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;ior %1,%I2,%I0\;nop\;ior %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;ior %1,#%2,%I0\;nop\;ior %d1,#0,%D0\"
  };

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      pic30_rtx_nops++;
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"ior %1,%I2,%I0\;\"
             \"nop\;\"
             \"ior %d1,%D2,%D0\";
    } else if (which_alternative == 7) {
      /* special case for alternative 7, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        pic30_rtx_nops++;
        return \"add %r0,#4,%r0\;\"
               \"ior %1,%2,%I0\;\"
                \"nop\;\"
               \"ior %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        pic30_rtx_nops++;
        return \"add %r2,#4,%r2\;\"
               \"ior %1,%I2,%0\;\"
               \"nop\;\"
               \"ior %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      pic30_rtx_nops++;
      return psv_psv_pre_patterns[which_alternative - 8];
    }
    return psv_psv_normal_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"ior %1,%I2,%I0\;\"
             \"ior %d1,%D2,%D0\";
    } else if (which_alternative == 7) {
      /* special case for alternative 7, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"ior %1,%2,%I0\;\"
               \"ior %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"ior %1,%I2,%0\;\"
               \"ior %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return noerrata_pre_patterns[which_alternative - 8];
    }
    return noerrata_normal_patterns[which_alternative];
  }
 "
 [
  (set_attr "cc" "clobber") ; CAW
  (set_attr "type" "def,defuse,use,use,use,def,use,use,use,use,use")
  (set_attr "op_type" "alu")
 ]
)

(define_insn "ior<mode>3_APSV_16"
 [(set (match_operand:GM32BIT 0 "pic30_mode2_operand"
             "=r,&r, R,R,R, r,R,<>,<>,R,<>")
       (ior:GM32BIT 
          (match_operand:GM32BIT 1 "pic30_mode1P_APSV_operand"
             "%r, r, r,r,r, 0,r, r, r, r, r")
          (match_operand:GM32BIT 2 "pic30_mode1P_APSV_operand"
             " r, R, 0,R,r, P,P, <>,R,<>,P")))
  (clobber (reg:CC_NZ CC_REG))
 ]
 "(!pic30_isa32_target())"
 "*
  static const char *noerrata_normal_patterns[] = {
    \"ior %1,%2,%0\;ior %d1,%d2,%d0\",
    \"ior %1,%I2,%0\;ior %d1,%D2,%d0\",
    \"ior %1,%2,%I0\;ior %d1,%2,%D0\",
    \"ior %1,%I2,%I0\;ior %d1,%D2,%D0\",
    \"ior %1,%2,%I0\;ior %d1,%d2,%D0\",
    \"ior %1,#%2,%0\",
    \"ior %1,#%2,%I0\;mov %d1,%D0\",
    \"ior %1,%2,%0\;ior %d1,%2,%0\",
    \"ior %1,%I2,%0\;ior %d1,%D2,%0\",
    \"ior %1,%2,%I0\;ior %d1,%2,%D0\",
    \"ior %1,#%2,%0\;ior %d1,#0,%0\"
  };

  static const char *noerrata_pre_patterns[] = {
    \"add %r0,#4,%r0\;ior %1,%I2,%I0\;ior %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;ior %1,%I2,%I0\;ior %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;ior %1,#%2,%I0\;ior %d1,#0,%D0\"
  };

  static const char *psv_psv_normal_patterns[] = {
    \"ior %1,%2,%0\;ior %d1,%d2,%d0\",
    \"ior %1,%I2,%0\;nop\;ior %d1,%D2,%d0\",
    \"ior %1,%2,%I0\;ior %d1,%2,%D0\",
    \"ior %1,%I2,%I0\;nop\;ior %d1,%D2,%D0\",
    \"ior %1,%2,%I0\;ior %d1,%d2,%D0\",
    \"ior %1,#%2,%0\",
    \"ior %1,#%2,%I0\;mov %d1,%D0\",
    \"ior %1,%2,%0\;nop\;ior %d1,%2,%0\",
    \"ior %1,%I2,%0\;nop\;ior %d1,%D2,%0\",
    \"ior %1,%2,%I0\;nop\;ior %d1,%2,%D0\",
    \"ior %1,#%2,%0\;nop\;ior %d1,#0,%0\"
  };

  static const char *psv_psv_pre_patterns[] = {
    \"add %r0,#4,%r0\;ior %1,%I2,%I0\;nop\;ior %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;ior %1,%I2,%I0\;nop\;ior %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;ior %1,#%2,%I0\;nop\;ior %d1,#0,%D0\"
  };

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops++;
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"ior %1,%I2,%I0\;\"
             \"nop\;\"
             \"ior %d1,%D2,%D0\";
    } else if (which_alternative == 6) {
      /* special case for alternative 6, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"ior %1,%2,%I0\;\"
               \"nop\;\"
               \"ior %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"ior %1,%I2,%0\;\"
               \"nop\;\"
               \"ior %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return psv_psv_pre_patterns[which_alternative - 7];
    }
    return psv_psv_normal_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"ior %1,%I2,%I0\;\"
             \"ior %d1,%D2,%D0\";
    } else if (which_alternative == 6) {
      /* special case for alternative 6, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"ior %1,%2,%I0\;\"
               \"ior %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"ior %1,%I2,%0\;\"
               \"ior %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return noerrata_pre_patterns[which_alternative - 7];
    }
    return noerrata_normal_patterns[which_alternative];
  }
 "
 [
  (set_attr "cc" "clobber") ; CAW
  (set_attr "type" "def,defuse,use,use,use,def,use,use,use,use,use")
  (set_attr "op_type" "alu")
 ]
)

(define_expand "ior<mode>3_16"
 [(set (match_operand:GM32BIT 0 "pic30_mode2_operand"
             "=r<>,&r<>,R,R,R,  R,r, r,<>")
       (ior:GM32BIT
          (match_operand:GM32BIT 1 "pic30_mode1P_or_1bit_APSV_operand"
             "%r,   r,  r,r,r,  r,0, r,r")
          (match_operand:GM32BIT 2 "pic30_mode1P_or_1bit_APSV_operand"
             "r<>, R,  0,R,r<>,P,P, P,P")))]
 "(!pic30_isa32_target())"
 "
{
  if ((pic30_one_bit_set(GET_MODE(operands[0]),operands[1],1) && 
       pic30_reg_or_R_operand(operands[2],VOIDmode))) {
    emit(
      gen_bitset<mode>_16(operands[0], operands[2], operands[1])
    );
  } else if ((pic30_one_bit_set(GET_MODE(operands[0]),operands[2],1) && 
            pic30_reg_or_R_operand(operands[1], VOIDmode))) {
    emit(
      gen_bitset<mode>_16(operands[0], operands[1], operands[2])
    );
  } else if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_mode1P_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_ior<mode>3_DATA_16(operands[0],operands[1],operands[2])
    );
  } else if (immediate_operand(operands[2],VOIDmode)) {
    rtx reg = force_reg(GET_MODE(operands[0]),operands[2]);

    emit(
      gen_ior<mode>3_DATA_16(operands[0],operands[1],reg)
    );
  } else if (pic30_mode1P_APSV_operand(operands[1],GET_MODE(operands[1])) &&
             pic30_mode1P_APSV_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_ior<mode>3_APSV_16(operands[0],operands[1],operands[2])
    );
  } else {
    rtx op1,op2;

    op1 = force_reg(GET_MODE(operands[0]),operands[1]);
    op2 = force_reg(GET_MODE(operands[0]),operands[2]);
    emit(
      gen_ior<mode>3_DATA_16(operands[0],op1,op2)
    );
  }
  DONE;
}")

; leave this match_dup, operand 0 will not require a reload (CAW)
;(define_insn "*iorsi3_sfr0_16"
;  [(set (match_operand:SI 0 "pic30_data_operand" "=T")
;        (ior:SI (match_dup 0)
;                (match_operand:SI 1 "pic30_register_operand" "r")))
;   (clobber (match_scratch:HI 2 "=&r"))
;   (clobber (reg:CC_NZ CC_REG))
;  ]
;  "(!pic30_isa32_target())"
;  "mov #%0,%2\;ior %1,[%2],[%2]\;ior %d1,[++%2],[%2]"
;  [
;    (set_attr "cc" "clobber")
;    (set_attr "op_type" "alu")
;  ]
;)

; leave this match_dup, operand 0 will not require a reload (CAW)
;(define_insn "*iorsi3_sfr1_16"
;  [(set (match_operand:SI 0 "pic30_data_operand"        "=T")
;        (ior:SI (match_operand:SI 1 "pic30_register_operand"  "r")
;                (match_dup 0)))
;   (clobber (match_scratch:HI 2            "=&r"))
;   (clobber (reg:CC_NZ CC_REG))
;  ]
;  "(!pic30_isa32_target())"
;  "mov #%0,%2\;ior %1,[%2],[%2]\;ior %d1,[++%2],[%2]"
;  [
;    (set_attr "cc" "clobber")
;    (set_attr "op_type" "alu")
;  ]
;)

;;;;;;;;;;;;;;;;;
;; double integer
;;;;;;;;;;;;;;;;;

(define_insn "*iorhidi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (sign_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
        )
   )
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;ior %1,%2,%0\;ior %3,%d2,%d0\;\"
                              \"ior %3,%t2,%t0\;ior %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;ior %1,%2,%0\;ior %3,%d2,%0\;\"
                              \"ior %3,%t2,%0\;ior %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;ior %1,%s2,%0\;ior %3,%s2,%0\;\"
                              \"ior %3,%s2,%0\;ior %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;ior %1,%2,%0\;ior %3,%2,%0\;\"
                              \"ior %3,%2,%0\;ior %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;ior %1,%2,%0\;ior %3,%2,%d0\;\"
                              \"ior %3,%2,%t0\;ior %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;ior %1,%2,%I0\;ior %3,%d2,%I0\;\"
                              \"ior %3,%t2,%I0\;ior %3,%q2,%0\",

     /* R,r,0 */          \"asr %1,#15,%3\;ior %1,%2,%I0\;ior %3,%2,%I0\;\"
                              \"ior %3,%2,%I0\;ior %3,%2,%0\",

     /* R,r,R */          \"asr %1,#15,%3\;ior %1,%I2,%I0\;ior %3,%I2,%I0\;\"
                              \"ior %3,%I2,%I0\;ior %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;ior %1,%I2,%0\;ior %3,%I2,%d0\;\"
                              \"ior %3,%I2,%t0\;ior %3,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;ior %1,%2,%0\;ior %3,%d2,%d0\;\"
                              \"ior %3,%t2,%t0\;ior %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;ior %1,%2,%0\;ior %3,%d2,%0\;\"
                              \"ior %3,%t2,%0\;ior %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;\"
                          \"ior %1,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;\"
                          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;\"
                          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;ior %1,%2,%I0\;ior %3,%d2,%I0\;\"
                              \"ior %3,%t2,%I0\;ior %3,%q2,%0\",

     /* R,r,0 */          \"asr %1,#15,%3\;\"
                          \"ior %1,%2,%I0\;\"
                          \"ior %3,%2,%I0\;\"
                          \"ior %3,%2,%I0\;\"
                          \"ior %3,%2,%0\",

     /* R,r,R */          \"asr %1,#15,%3\;\"
                          \"ior %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;\"
                          \"ior %1,%I2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%I2,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%q0\",
  };

  const char **patterns;

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    /* movd version relies on the compiler never generating a mov.d */
    patterns = noerrata_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*iorhidi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (zero_extend:DI
              (match_operand:HI 1 "pic30_register_operand"    "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
        )
   )
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%d0\;\"
                          \"mov.d %t2,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%0\;\"
                          \"mov.d %t2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%s0\;\"
                          \"add #8,%r0\",

     /* >,r,> */          \"ior %1,%2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov.d %2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;\"
                          \"mov %2,%d0\;\"
                          \"mov.d %2,%t0\",

     /* R,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%Q0\;\"
                          \"mov %t2,%R0\;\"
                          \"mov %q2,%S0\",

     /* R,r,0 */          \"ior %1,%2,%0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"ior %1,%2,%0\;\"
                          \"mov %Q2,%d0\;\"
                          \"mov %R2,%t0\;\"
                          \"mov %S2,%q0\"
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%d0\;\"
                          \"mov.d %t2,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%0\;\"
                          \"mov.d %t2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%s0\;\"
                          \"add #8,%r0\",

     /* >,r,> */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov.d %2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%d0\;\"
                          \"nop\;\"
                          \"mov.d %2,%t0\",

     /* R,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%Q0\;\"
                          \"mov %t2,%R0\;\"
                          \"mov %q2,%S0\",

     /* R,r,0 */          \"ior %1,%2,%0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %Q2,%d0\;\"
                          \"nop\;\"
                          \"mov %R2,%t0\;\"
                          \"nop\;\"
                          \"mov %S2,%q0\"
  };

  const char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%d0\;\"
                          \"mov.d %t2,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%0\;\"
                          \"mov.d %t2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%s0\;\"
                          \"add #8,%r0\",

     /* >,r,> */          \"ior %1,%2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov %2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;\"
                          \"mov %2,%d0\;\"
                          \"mov %2,%t0\;\"
                          \"mov %2,%q0\",

     /* R,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d2,%Q0\;\"
                          \"mov %t2,%R0\;\"
                          \"mov %q2,%S0\",

     /* R,r,0 */          \"ior %1,%2,%0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"ior %1,%2,%0\;\"
                          \"mov %Q2,%d0\;\"
                          \"mov %R2,%t0\;\"
                          \"mov %S2,%q0\"
  };

  const char **patterns;

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

              }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*iorsidi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (sign_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;ior %1,%2,%0\;ior %d1,%d2,%d0\;\"
                              \"ior %3,%t2,%t0\;ior %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;ior %1,%2,%0\;ior %d1,%d2,%0\;\"
                              \"ior %3,%t2,%0\;ior %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;ior %1,%s2,%0\;ior %d1,%s2,%0\;\"
                              \"ior %3,%s2,%0\;ior %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;ior %1,%2,%0\;ior %d1,%2,%0\;\"
                              \"ior %3,%2,%0\;ior %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;ior %1,%2,%0\;ior %d1,%2,%d0\;\"
                              \"ior %3,%2,%t0\;ior %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;ior %1,%2,%I0\;ior %d1,%d2,%I0\;\"
                              \"ior %3,%t2,%I0\;ior %3,%q2,%0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;ior %1,%2,%I0\;ior %d1,%2,%I0\;\"
                              \"ior %3,%2,%I0\;ior %3,%2,%0\",

     /* R,r,R */          \"asr %d1,#15,%3\;ior %1,%I2,%I0\;ior %d1,%I2,%I0\;\"
                              \"ior %4,%I2,%I0\;ior %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;ior %1,%I2,%0\;ior %d1,%I2,%d0\;\"
                              \"ior %3,%I2,%t0\;ior %3,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;ior %1,%2,%0\;ior %d1,%d2,%d0\;\"
                              \"ior %3,%t2,%t0\;ior %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;ior %1,%2,%0\;ior %d1,%d2,%0\;\"
                              \"ior %3,%t2,%0\;ior %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;\"
                          \"ior %1,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;\"
                          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;\"
                          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;ior %1,%2,%I0\;ior %d1,%d2,%I0\;\"
                              \"ior %3,%t2,%I0\;ior %3,%q2,%0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;\"
                          \"ior %1,%2,%I0\;\"
                          \"ior %d1,%2,%I0\;\"
                          \"ior %3,%2,%I0\;\"
                          \"ior %3,%2,%0\",

     /* R,r,R */          \"asr %d1,#15,%3\;\"
                          \"ior %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;\"
                          \"ior %1,%I2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    /* movd version relies on the compiler never generating a mov.d */
    patterns = noerrata_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*iorsidi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (zero_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%0\;ior %d1,%s2,%0\;add #4,%r0\",

     /* >,r,> */          \"ior %1,%2,%0\;ior %d1,%2,%0\;\"
                              \"mov %2,%0\; mov %2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;ior %d1,%2,%d0\;mov.d %2,%t0\",

     /* R,r,r */          \"ior %1,%2,%I0\;ior %d1,%d2,%D0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"ior %1,%2,%I0\;ior %d1,%2,%D0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;ior %d1,%I2,%I0\;mov %I2,%I0\;mov %2,%0\",

     /* r,r,R */          \"ior %1,%I2,%0\;ior %d1,%D2,%d0\;mov %R2,%t0\;mov %S2,%q0\"
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%s2,%0\;\"
                          \"add #4,%r0\",

     /* >,r,> */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"mov.d %2,%t0\",

     /* R,r,r */          \"ior %1,%2,%I0\;ior %d1,%d2,%D0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"ior %1,%2,%I0\;\"
                          \"ior %d1,%2,%D0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"ior %1,%I2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%D2,%d0\;\"
                          \"nop\;\"
                          \"mov %R2,%t0\;\"
                          \"nop\;\"
                          \"mov %S2,%q0\"
  };

  const char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%0\;\"
                          \"ior %d1,%s2,%0\;\"
                          \"add #4,%r0\",

     /* >,r,> */          \"ior %1,%2,%0\;\"
                          \"ior %d1,%2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov %2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;\"
                          \"ior %d1,%2,%d0\;\"
                          \"mov %2,%t0\;\"
                          \"mov %2,%q0\",

     /* R,r,r */          \"ior %1,%2,%I0\;ior %d1,%d2,%D0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"ior %1,%2,%I0\;ior %d1,%2,%D0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;\"
                          \"ior %d1,%I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"ior %1,%I2,%0\;\"
                          \"ior %d1,%D2,%d0\;\"
                          \"mov %R2,%t0\;\"
                          \"mov %S2,%q0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
              }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*iordihi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;ior %2,%1,%0\;ior %3,%d1,%d0\;\"
                              \"ior %3,%t1,%t0\;ior %3,%q1,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;ior %2,%1,%0\;ior %3,%d1,%0\;\"
                              \"ior %3,%t1,%0\;ior %3,%q1,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;ior %2,%s1,%0\;ior %3,%s1,%0\;\"
                              \"ior %3,%s1,%0\;ior %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;ior %2,%1,%0\;ior %3,%1,%0\;\"
                              \"ior %3,%1,%0\;ior %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;ior %2,%1,%0\;ior %3,%1,%d0\;\"
                              \"ior %3,%1,%t0\;ior %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;ior %2,%1,%I0\;ior %3,%d1,%I0\;\"
                              \"ior %3,%t1,%I0\;ior %3,%q1,%s0\",

     /* R,0,r */          \"asr %2,#15,%3\;ior %2,%1,%I0\;ior %3,%1,%I0\;\"
                              \"ior %3,%1,%I0\;ior %3,%1,%s0\",

     /* R,R,r */          \"asr %2,#15,%3\;ior %2,%I1,%I0\;ior %3,%I1,%I0\;\"
                              \"ior %3,%I1,%I0\;ior %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;ior %1,%I1,%0\;ior %3,%I1,%d0\;\"
                              \"ior %3,%I1,%t0\;ior %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;ior %2,%1,%0\;ior %3,%d1,%d0\;\"
                              \"ior %3,%t1,%t0\;ior %3,%q1,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;ior %2,%1,%0\;ior %3,%d1,%0\;\"
                              \"ior %3,%t1,%0\;ior %3,%q1,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;ior %2,%s1,%0\;ior %3,%s1,%0\;\"
                              \"ior %3,%s1,%0\;ior %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;\"
                          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;\"
                          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;ior %2,%1,%I0\;ior %3,%d1,%I0\;\"
                              \"ior %3,%t1,%I0\;ior %3,%q1,%s0\",

     /* R,0,r */          \"asr %2,#15,%3\;ior %2,%1,%I0\;ior %3,%1,%I0\;\"
                              \"ior %3,%1,%I0\;ior %3,%1,%s0\",

     /* R,R,r */          \"asr %2,#15,%3\;\"
                          \"ior %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;\"
                          \"ior %1,%I1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    /* movd version relies on the compiler never generating a mov.d */
    patterns = noerrata_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*iordihi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;mov %d1,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;mov %d1,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"ior %2,%s1,%s0\;add #8,%r0\",

     /* >,>,r */          \"ior %2,%s1,%s0\;mov %1,%0\;mov %1,%0\;mov %1,%0\",

     /* r,>,r */          \"ior %2,%1,%0\;mov %1,%d0\;mov.d %1,%t0\",

     /* R,r,r */          \"ior %1,%2,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"ior %2,%1,%0\",

     /* R,R,r */          \"ior %2,%I1,%I0\;mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\",

     /* r,R,r */          \"ior %2,%1,%0\;mov %Q1,%d0\;mov %R1,%t0\;mov %S1,%q0\"
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;mov %d1,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;mov %d1,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"ior %2,%s1,%s0\;add #8,%r0\",

     /* >,>,r */          \"ior %2,%s1,%s0\;mov %1,%0\;mov %1,%0\;mov %1,%0\",

     /* r,>,r */          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%d0\;\"
                          \"nop\;\"
                          \"mov.d %1,%t0\",

     /* R,r,r */          \"ior %1,%2,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"ior %2,%1,%0\",

     /* R,R,r */          \"ior %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"mov %I1,%I0\;\"
                          \"nop\;\"
                          \"mov %I1,%I0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %Q1,%d0\;\"
                          \"nop\;\"
                          \"mov %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %S1,%q0\"
  };

  const char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;mov %d1,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;mov %d1,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"ior %2,%s1,%s0\;add #8,%r0\",

     /* >,>,r */          \"ior %2,%s1,%s0\;mov %1,%0\;mov %1,%0\;mov %1,%0\",

     /* r,>,r */          \"ior %2,%1,%0\;\"
                          \"mov %1,%d0\;\"
                          \"mov %1,%t0\;\"
                          \"mov %1,%q0\",

     /* R,r,r */          \"ior %1,%2,%0\;\"
                          \"mov %d1,%Q0\;\"
                          \"mov %t1,%R0\;\"
                          \"mov %q1,%S0\",

     /* R,0,r */          \"ior %2,%1,%0\",

     /* R,R,r */          \"ior %2,%I1,%I0\;\"
                          \"mov %I1,%I0\;\"
                          \"mov %I1,%I0\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"ior %2,%1,%0\;\"
                          \"mov %Q1,%d0\;\"
                          \"mov %R1,%t0\;\"
                          \"mov %S1,%q0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops+=3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
              }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*iordisi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;ior %2,%1,%0\;ior %d2,%d1,%d0\;\"
                              \"ior %3,%t1,%t0\;ior %3,%q1,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;ior %2,%1,%0\;ior %d2,%d1,%0\;\"
                              \"ior %3,%t1,%0\;ior %3,%q1,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;ior %2,%s1,%0\;ior %d2,%s1,%0\;\"
                              \"ior %3,%s1,%0\;ior %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;ior %2,%1,%0\;ior %d2,%1,%0\;\"
                              \"ior %3,%1,%0\;ior %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;ior %2,%1,%0\;ior %d2,%1,%d0\;\"
                              \"ior %3,%1,%t0\;ior %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;ior %2,%1,%I0\;ior %d2,%d1,%I0\;\"
                              \"ior %3,%t1,%I0\;ior %3,%q1,%0\",

     /* R,0,r */          \"asr %d2,#15,%3\;ior %2,%1,%I0\;ior %d2,%1,%I0\;\"
                              \"ior %3,%1,%I0\;ior %3,%1,%0\",

     /* R,R,r */          \"asr %d2,#15,%3\;ior %2,%I1,%I0\;ior %d2,%I1,%I0\;\"
                              \"ior %3,%I1,%I0\;ior %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;ior %2,%I1,%0\;ior %d1,%I1,%d0\;\"
                              \"ior %3,%I1,%t0\;ior %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;ior %2,%1,%0\;ior %d2,%d1,%d0\;\"
                              \"ior %3,%t1,%t0\;ior %3,%q1,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;ior %2,%1,%0\;ior %d2,%d1,%0\;\"
                              \"ior %3,%t1,%0\;ior %3,%q1,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;ior %2,%s1,%0\;ior %d2,%s1,%0\;\"
                              \"ior %3,%s1,%0\;ior %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;\"
                          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %d2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;\"
                          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;ior %2,%1,%I0\;ior %d2,%d1,%I0\;\"
                              \"ior %3,%t1,%I0\;ior %3,%q1,%0\",

     /* R,0,r */          \"asr %d2,#15,%3\;ior %2,%1,%I0\;ior %d2,%1,%I0\;\"
                              \"ior %3,%1,%I0\;ior %3,%1,%0\",

     /* R,R,r */          \"asr %d2,#15,%3\;\"
                          \"ior %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;\"
                          \"ior %2,%I1,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%I1,%d0\;\"
                          \"nop\;\"
                          \"ior %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"ior %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    /* movd version relies on the compiler never generating a mov.d */
    patterns = noerrata_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  }  else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*iordisi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"ior %2,%s1,%0\;ior %d2,%s1,%0\;add #4,%r0\",

     /* >,>,r */          \"ior %2,%1,%0\;ior %d2,%1,%0\;\"
                              \"mov %1,%0\;mov %1,%0\",

     /* r,>,r */          \"ior %2,%1,%0\;ior %d2,%1,%d0\;mov.d %1,%t0\",

     /* R,r,r */          \"ior %2,%1,%I0\;ior %d2,%d1,%D0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"ior %2,%1,%I0\;ior %d2,%1,%D0\",

     /* R,R,r */          \"ior %2,%I1,%I0\;ior %d2,%I1,%I0\;mov %I1,%I0\;mov %1,%0\",

     /* r,R,r */          \"ior %2,%I1,%0\;ior %d2,%D1,%d0\;mov %R1,%t0\;mov %S1,%q0\"
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"ior %2,%s1,%0\;ior %d2,%s1,%0\;add #4,%r0\",

     /* >,>,r */          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %d2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,>,r */          \"ior %2,%1,%0\;\"
                          \"nop\;\"
                          \"ior %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"mov.d %1,%t0\",

     /* R,r,r */          \"ior %2,%1,%I0\;ior %d2,%d1,%D0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"ior %2,%1,%I0\;ior %d2,%1,%D0\",

     /* R,R,r */          \"ior %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"ior %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"mov %I1,%I0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"ior %2,%I1,%0\;\"
                          \"nop\;\"
                          \"ior %d2,%D1,%d0\;\"
                          \"nop\;\"
                          \"mov %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %S1,%q0\"
  };

  const char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"ior %2,%s1,%0\;ior %d2,%s1,%0\;add #4,%r0\",

     /* >,>,r */          \"ior %2,%1,%0\;\"
                          \"ior %d2,%1,%0\;\"
                          \"mov %1,%0\;\"
                          \"mov %1,%0\",

     /* r,>,r */          \"ior %2,%1,%0\;\"
                          \"ior %d2,%1,%d0\;\"
                          \"mov %1,%t0\;\"
                          \"mov %1,%q0\",

     /* R,r,r */          \"ior %2,%1,%I0\;\"
                          \"ior %d2,%d1,%D0\"
                          \"\;mov %t1,%R0\"
                          \"\;mov %q1,%S0\",

     /* R,0,r */          \"ior %2,%1,%I0\;ior %d2,%1,%D0\",

     /* R,R,r */          \"ior %2,%I1,%I0\;\"
                          \"ior %d2,%I1,%I0\;\"
                          \"mov %I1,%I0\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"ior %2,%I1,%0\;\"
                          \"ior %d2,%D1,%d0\;\"
                          \"mov %R1,%t0\;\"
                          \"mov %S1,%q0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
              }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "iordi3_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (ior:DI
           (match_operand:DI 1 "pic30_register_operand"    "r,r,r,r, r,r,r,r, r")
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;\"
                              \"ior %t1,%t2,%t0\;ior %q1,%q2,%q0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;\"
                              \"ior %t1,%t2,%0\;ior %q1,%q2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%0\;ior %d1,%s2,%0\;\"
                              \"ior %t1,%s2,%0\;ior %q1,%s2,%0\",

     /* >,r,> */          \"ior %1,%2,%0\;ior %d1,%2,%0\;\"
                              \"ior %t1,%2,%0\;ior %q1,%2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;ior %d1,%2,%d0\;\"
                              \"ior %t1,%2,%t0\;ior %q1,%2,%q0\",

     /* R,r,r */          \"ior %1,%2,%I0\;ior %d1,%d2,%I0\;\"
                              \"ior %t1,%t2,%I0\;ior %q1,%q2,%0\",

     /* R,r,0 */          \"ior %1,%2,%I0\;ior %d1,%2,%I0\;\"
                              \"ior %t1,%2,%I0\;ior %q1,%2,%0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;ior %d1,%I2,%I0\;\"
                              \"ior %t1,%I2,%I0\;ior %q1,%2,%0\",

     /* r,r,R */          \"ior %1,%I2,%0\;ior %d1,%I2,%d0\;\"
                              \"ior %t1,%I2,%t0\;ior %q1,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%d0\;\"
                              \"ior %t1,%t2,%t0\;ior %q1,%q2,%q0\",

     /* >,r,r */          \"ior %1,%2,%0\;ior %d1,%d2,%0\;\"
                              \"ior %t1,%t2,%0\;ior %q1,%q2,%0\",

     /* >,r,0 */          \"ior %1,%s2,%0\;ior %d1,%s2,%0\;\"
                              \"ior %t1,%s2,%0\;ior %q1,%s2,%0\",

     /* >,r,> */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %t1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %q1,%2,%0\",

     /* r,r,> */          \"ior %1,%2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"ior %t1,%2,%t0\;\"
                          \"nop\;\"
                          \"ior %q1,%2,%q0\",

     /* R,r,r */          \"ior %1,%2,%I0\;ior %d1,%d2,%I0\;\"
                              \"ior %t1,%t2,%I0\;ior %q1,%q2,%0\",

     /* R,r,0 */          \"ior %1,%2,%I0\;ior %d1,%2,%I0\;\"
                              \"ior %t1,%2,%I0\;ior %q1,%2,%0\",

     /* R,r,R */          \"ior %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %t1,%I2,%I0\;\"
                          \"nop\;\"
                          \"ior %q1,%2,%0\",

     /* r,r,R */          \"ior %1,%I2,%0\;\"
                          \"nop\;\"
                          \"ior %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"ior %t1,%I2,%t0\;\"
                          \"nop\;\"
                          \"ior %q1,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    /* movd version relies on the compiler never generating a mov.d */
    patterns = noerrata_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; XOR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;
;; quarter integer
;;;;;;;;;;;;;;;;;;

;       (xor:QI (match_operand:QI 1 "pic30_register_operand" "%0")
;               (match_operand:QI 2 "pic30_J_operand"        " J")))

(define_insn "*xorqi3_imm_16"
  [(set (match_operand:QI         0 "pic30_register_operand" "=r")
        (xor:QI (match_dup        0)
                (match_operand:QI 1 "pic30_J_operand"        " J")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "xor.b #%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "xorqi3_DATA_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R")
        (xor:QI 
           (match_operand:QI 1 "pic30_mode1P_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:QI 2 "pic30_mode1P_operand"
              " r,  R<>,r,R<>,P,  P,r,  r,  r,  r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   xor.b %1,%2,%0
   xor.b %1,%2,%0
   xor.b %1,%2,%0
   xor.b %1,%2,%0
   xor.b %1,#%2,%0
   xor.b %1,#%2,%0
   xor.b %2,%1,%0
   xor.b %2,%1,%0
   xor.b %2,#%1,%0
   xor.b %2,#%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "xorqi3_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R")
        (xor:QI 
           (match_operand:QI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:QI 2 "pic30_mode1P_APSV_operand"
              " r,  R<>,r,R<>,P,  P,r,  r,  r,  r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   xor.b %1,%2,%0
   xor.b %1,%2,%0
   xor.b %1,%2,%0
   xor.b %1,%2,%0
   xor.b %1,#%2,%0
   xor.b %1,#%2,%0
   xor.b %2,%1,%0
   xor.b %2,%1,%0
   xor.b %2,#%1,%0
   xor.b %2,#%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "xorqi3_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"
              "=r<>,r<>,R,R,  r<>,R,r<>,R,  r<>,R")
        (xor:QI
           (match_operand:QI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,  r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:QI 2 "pic30_mode1P_APSV_operand"
              " r,  R<>,r,R<>,P,  P,r,  r,  r,  r")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_mode1P_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_xorqi3_DATA_16(operands[0],operands[1],operands[2])
    );
  } else if (pic30_mode1P_APSV_operand(operands[1],GET_MODE(operands[1])) &&
              pic30_mode1P_APSV_operand(operands[2],GET_MODE(operands[2]))) {
    emit(
      gen_xorqi3_APSV_16(operands[0],operands[1],operands[2])
    );
  } else {
    rtx op1, op2;
    
    op1 = force_reg(GET_MODE(operands[0]), operands[1]);
    op2 = force_reg(GET_MODE(operands[0]), operands[2]);
    emit(
      gen_xorqi3_DATA_16(operands[0], op1, op2)
    );
  }
  DONE;
}")

(define_insn_and_split "*xorqi3_sfr0_16"
  [(set (match_operand:QI 0 "pic30_register_operand"           "=a,a, r")
        (xor:QI (match_operand:QI 1 "pic30_register_operand"   "%a,d, r")
                (match_operand:QI 2 "pic30_near_operand" " U,U, U")))
   (clobber (match_scratch:HI 3                          "=X,X,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   xor.b %2,WREG
   mov.b %1,w0\;xor.b %2,WREG
   mov #%2,%3\;xor.b %1,[%3],%0"
  "reload_completed && (!pic30_isa32_target())"
  [
   (const_int 0)
  ]
"
{
  if (!pic30_wreg_operand(operands[0], QImode) &&
      !pic30_wreg_operand(operands[1], QImode)) {
    rtx pop = gen_rtx_MEM(QImode, operands[3]);
    emit_insn(gen_movhi_address_16(operands[3], XEXP(operands[2],0)));
    emit_insn(gen_xorqi3_16(operands[0], operands[1], pop));
    DONE;
  } else {
    FAIL;
  }
}
"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*xorqi3_sfr1_16"
  [(set (match_operand:QI 0 "pic30_near_operand"       "=U,!???U")
        (xor:QI (match_dup 0)
                (match_operand:QI 1 "pic30_register_operand"  "a,!???d")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0: return \"xor.b %0\";
     case 1: if (pic30_errata_mask & exch_errata)
               return \"push w0\;mov %1,w0\;xor.b %0\;pop w0\";
             else
               return \"exch w0,%1\;xor.b %0\;exch w0,%1\";
   }
  "
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;
;; half integer
;;;;;;;;;;;;;;;

(define_insn "xorhi3_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>, R,R,  r<>,R,r<>,R,  r<>,R")
        (xor:HI 
           (match_operand:HI 1 "pic30_mode1P_operand"
              "%r,  r,   r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:HI 2 "pic30_mode1P_operand"
              "r,  R<>, r,R<>,P,  P,r,  r,  r,  r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   xor %1,%2,%0
   xor %1,%2,%0
   xor %1,%2,%0
   xor %1,%2,%0
   xor %1,#%2,%0
   xor %1,#%2,%0
   xor %2,%1,%0
   xor %2,%1,%0
   xor %2,#%1,%0
   xor %2,#%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "xorhi3_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>, R,R,  r<>,R,r<>,R,  r<>,R")
        (xor:HI 
           (match_operand:HI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,   r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:HI 2 "pic30_mode1P_APSV_operand"
              "r,  R<>, r,R<>,P,  P,r,  r,  r,  r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   xor %1,%2,%0
   xor %1,%2,%0
   xor %1,%2,%0
   xor %1,%2,%0
   xor %1,#%2,%0
   xor %1,#%2,%0
   xor %2,%1,%0
   xor %2,%1,%0
   xor %2,#%1,%0
   xor %2,#%1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use,def,use,defuse,use,def,use")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "xorhi3_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"
              "=r<>,r<>, R,R,  r<>,R,r<>,R,  r<>,R")
        (xor:HI
           (match_operand:HI 1 "pic30_mode1P_APSV_operand"
              "%r,  r,   r,r,  r,  r,R<>,R<>,P,  P")
           (match_operand:HI 2 "pic30_mode1P_APSV_operand"
              "r,  R<>, r,R<>,P,  P,r,  r,  r,  r")))
  ]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode1P_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_mode1P_operand(operands[2],GET_MODE(operands[2])))
    emit(
      gen_xorhi3_DATA_16(operands[0],operands[1],operands[2])
    );
  else if (pic30_mode1P_APSV_operand(operands[1],GET_MODE(operands[1])) &&
           pic30_mode1P_APSV_operand(operands[2],GET_MODE(operands[2])))
    emit(
      gen_xorhi3_APSV_16(operands[0],operands[1],operands[2])
    );
  else {
    rtx op1,op2;
   
    op1 = force_reg(GET_MODE(operands[0]),operands[1]);
    op2 = force_reg(GET_MODE(operands[0]),operands[2]);
    emit(
      gen_xorhi3_DATA_16(operands[0],op1,op2)
    );
  }
  DONE;
}")

(define_insn "xorhi3_sfr0_16"
  [(set (match_operand:HI 0         "pic30_reg_or_near_operand" "=U,a,r")
        (xor:HI (match_operand:HI 1 "pic30_register_operand"    "%a,0,r")
                (match_operand:HI 2 "pic30_reg_or_near_operand" " 0,U,r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   xor %0
   xor %2,WREG
   xor %2,%1,%0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "etc,def,def")
    (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "xorhi3_sfr2_16"
  [(set (match_operand:HI 0 "pic30_near_operand" "=U")
        (xor:HI (match_dup 0)
                (match_operand:HI 1 "pic30_immediate_1bit_operand" "i")))
  ]
  "(!pic30_isa32_target())"
  "*
   { unsigned int bit_num;
     static char insn[48];

     if (GET_CODE(operands[1]) == CONST_INT) {
       int i;
       i = INTVAL(operands[1]);
   
       i = i & 0xFFFF;
       /* apparantly I can't use log here */
       for (bit_num = 0 ; bit_num <= 16; bit_num++)
         if (((1 << bit_num) & i) == i) break;
       if (bit_num == 16) abort();
       sprintf(insn, \"btg %%0,#%d\",bit_num);
       return insn;
     } else abort();
   }"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "xorhi3_sfr3_16"
  [(set (match_operand:HI 0 "pic30_near_operand" "=U")
        (xor:HI (match_operand:HI 1 "pic30_immediate_1bit_operand" "i")
                (match_dup 0)))
  ]
  "(!pic30_isa32_target())"
  "*
   { unsigned int bit_num;
     static char insn[48];

     if (GET_CODE(operands[1]) == CONST_INT) {
       int i;
       i = INTVAL(operands[1]);
  
       i = i & 0xFFFF;
       /* apparantly I can't use log here */
       for (bit_num = 0 ; bit_num <= 16; bit_num++)
         if (((1 << bit_num) & i) == i) break;
       if (bit_num == 16) abort();
       sprintf(insn, \"btg %%0,#%d\",bit_num);
       return insn;
     } else abort();
   }"
  [
    (set_attr "cc" "unchanged")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*xorhi3_imm_16"
  [(set (match_operand:HI 0 "pic30_register_operand"         "=r")
        (xor:HI (match_operand:HI 1 "pic30_register_operand" "%0")
                (match_operand:HI 2 "pic30_J_operand"   "J")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "xor #%2,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

; this match_can cause issues iff operand 1 is dies in this instruction and
;   we decide to use it to reload operand 0 (CAW)
(define_insn "*xorhi3_sfr0_16"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand" "+a,U,!???d,!???U")
        (xor:HI (match_dup 0)
                (match_operand:HI 1 "pic30_reg_or_near_operand"
                                                        "U,a,!???U,!???d")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0: return \"xor %1,WREG\";
     case 1: return \"xor %0\";
     case 2: if (pic30_errata_mask & exch_errata)
               return \"push w0\;mov w0,%0\;xor %1,WREG\;mov w0,%0\;pop w0\";
             else
               return \"exch w0,%0\;xor %1,WREG\;exch w0,%0\";
     case 3: if (pic30_errata_mask & exch_errata)
               return \"push w0\;mov %1,w0\;xor %0\;pop w0\";
             else
               return \"exch w0,%1\;xor %0\;exch w0,%1\";
   }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def,etc,def,etc")
    (set_attr "op_type" "alu")
  ]
)

; this match_can cause issues iff operand 1 is dies in this instruction and
;   we decide to use it to reload operand 0 (CAW)
(define_insn "*xorhi3_sfr1_16"
  [(set (match_operand:HI 0 "pic30_reg_or_near_operand" "+a,U,!???d,!???U")
        (xor:HI (match_operand:HI 1 "pic30_reg_or_near_operand"
                                                        "U,a,!???U,!???d")
                (match_dup 0)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   switch (which_alternative) {
     default: gcc_assert(0);
     case 0: return \"xor %1,WREG\";
     case 1: return \"xor %0\";
     case 2: if (pic30_errata_mask & exch_errata)
               return \"push w0\;mov %0,w0\;xor %1,WREG\;mov w0,%0\;pop w0\";
             else
               return \"exch w0,%0\;xor %1,WREG\;exch w0,%0\";
     case 3: if (pic30_errata_mask & exch_errata)
               return \"push w0\;mov %1,w0\;xor %0\;pop w0\";
             else
               return \"exch w0,%1\;xor %0\;exch w0,%1\";
   }"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def,etc,def,etc")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;
;; single integer
;;;;;;;;;;;;;;;;;

(define_insn "xor<mode>3_DATA_16"
 [(set (match_operand:GM32BIT 0 "pic30_mode2_operand"
             "=r,&r, R,R,R, r,R,<>,<>,R,<>")
       (xor:GM32BIT 
          (match_operand:GM32BIT 1 "pic30_register_operand"
             "%r, r, r,r,r, 0,r, r, r, r, r")
          (match_operand:GM32BIT 2 "pic30_mode1P_operand"
             " r, R, 0,R,r, P,P, <>,R,<>,P")))
  (clobber (reg:CC_NZ CC_REG))
 ]
 "(!pic30_isa32_target())"
 "*
  static const char *normal_patterns[] = {
    \"xor %1,%2,%0\;xor %d1,%d2,%d0\",
    \"xor %1,%I2,%0\;xor %d1,%D2,%d0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"xor %1,%2,%I0\;xor %d1,%d2,%D0\",
    \"xor %1,#%2,%0\",
    \"xor %1,#%2,%I0\;mov %d1,%D0\",
    \"xor %1,%2,%0\;xor %d1,%2,%0\",
    \"xor %1,%I2,%0\;xor %d1,%D2,%0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,#%2,%0\;xor %d1,#0,%0\"
  };

  static const char *pre_patterns[] = {
    \"add %r0,#4,%r0\;xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;xor %1,#%2,%I0\;xor %d1,#0,%D0\"
  };

  static const char *psv_psv_normal_patterns[] = {
    \"xor %1,%2,%0\;xor %d1,%d2,%d0\",
    \"xor %1,%I2,%0\;nop\;xor %d1,%D2,%d0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,%I2,%I0\;nop\;xor %d1,%D2,%D0\",
    \"xor %1,%2,%I0\;xor %d1,%d2,%D0\",
    \"xor %1,#%2,%0\",
    \"xor %1,#%2,%I0\;mov %d1,%D0\",
    \"xor %1,%2,%0\;nop\;xor %d1,%2,%0\",
    \"xor %1,%I2,%0\;nop\;xor %d1,%D2,%0\",
    \"xor %1,%2,%I0\;nop\;xor %d1,%2,%D0\",
    \"xor %1,#%2,%0\;nop\;xor %d1,#0,%0\"
  };

  static const char *psv_psv_pre_patterns[] = {
    \"add %r0,#4,%r0\;xor %1,%I2,%I0\;nop\;xor %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;xor %1,%I2,%I0\;nop\;xor %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;xor %1,#%2,%I0\;nop\;xor %d1,#0,%D0\"
  };

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops++;
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"xor %1,%I2,%I0\;\"
             \"nop\;\"
             \"xor %d1,%D2,%D0\";
    } else if (which_alternative == 7) {
      /* special case for alternative 7, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"xor %1,%2,%I0\;\"
               \"nop\;\"
               \"xor %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"xor %1,%I2,%0\;\"
               \"nop\;\"
               \"xor %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return psv_psv_pre_patterns[which_alternative - 8];
    }
    return psv_psv_normal_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"xor %1,%I2,%I0\;\"
             \"xor %d1,%D2,%D0\";
    } else if (which_alternative == 7) {
      /* special case for alternative 7, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"xor %1,%2,%I0\;\"
               \"xor %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"xor %1,%I2,%0\;\"
               \"xor %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return pre_patterns[which_alternative - 8];
    }
    return normal_patterns[which_alternative];
  }
 "
 [
  (set_attr "cc" "clobber") ; CAW
  (set_attr "type" "def,defuse,use,use,use,def,use,use,use,use,use")
  (set_attr "op_type" "alu")
 ]
)

(define_insn "xor<mode>3_APSV_16"
 [(set (match_operand:GM32BIT 0 "pic30_mode2_operand"
             "=r,&r, R,R,R, r,R,<>,<>,R,<>")
       (xor:GM32BIT 
          (match_operand:GM32BIT 1 "pic30_register_operand"
             "%r, r, r,r,r, 0,r, r, r, r, r")
          (match_operand:GM32BIT 2 "pic30_mode1P_APSV_operand"
             " r, R, 0,R,r, P,P, <>,R,<>,P")))
  (clobber (reg:CC_NZ CC_REG))
 ]
 "(!pic30_isa32_target())"
 "*
  static const char *normal_patterns[] = {
    \"xor %1,%2,%0\;xor %d1,%d2,%d0\",
    \"xor %1,%I2,%0\;xor %d1,%D2,%d0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"xor %1,%2,%I0\;xor %d1,%d2,%D0\",
    \"xor %1,#%2,%0\",
    \"xor %1,#%2,%I0\;mov %d1,%D0\",
    \"xor %1,%2,%0\;xor %d1,%2,%0\",
    \"xor %1,%I2,%0\;xor %d1,%D2,%0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,#%2,%0\;xor %d1,#0,%0\"
  };

  static const char *pre_patterns[] = {
    \"add %r0,#4,%r0\;xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;xor %1,#%2,%I0\;xor %d1,#0,%D0\"
  };

  static const char *psv_psv_normal_patterns[] = {
    \"xor %1,%2,%0\;xor %d1,%d2,%d0\",
    \"xor %1,%I2,%0\;xor %d1,%D2,%d0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"xor %1,%2,%I0\;xor %d1,%d2,%D0\",
    \"xor %1,#%2,%0\",
    \"xor %1,#%2,%I0\;mov %d1,%D0\",
    \"xor %1,%2,%0\;xor %d1,%2,%0\",
    \"xor %1,%I2,%0\;xor %d1,%D2,%0\",
    \"xor %1,%2,%I0\;xor %d1,%2,%D0\",
    \"xor %1,#%2,%0\;xor %d1,#0,%0\"
  };

  static const char *psv_psv_pre_patterns[] = {
    \"add %r0,#4,%r0\;xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"add %r2,#4,%r2\;xor %1,%I2,%I0\;xor %d1,%D2,%D0\",
    \"add %r0,#4,%r0\;xor %1,#%2,%I0\;xor %d1,#0,%D0\"
  };

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops++;
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"xor %1,%I2,%I0\;\"
             \"nop\;\"
             \"xor %d1,%D2,%D0\";
    } else if (which_alternative == 7) {
      /* special case for alternative 7, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"xor %1,%2,%I0\;\"
               \"nop\;\"
               \"xor %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"xor %1,%I2,%0\;\"
               \"nop\;\"
               \"xor %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return psv_psv_pre_patterns[which_alternative - 8];
    }
    return psv_psv_normal_patterns[which_alternative];
  } else {
    if (pic30_pre_modify(operands[0]) && pic30_pre_modify(operands[2])) {
      /* special case for both operands being pre-modify */
      return \"add %r0,#4,%r0\;\"
             \"add %r2,#4,%r2\;\"
             \"xor %1,%I2,%I0\;\"
             \"xor %d1,%D2,%D0\";
    } else if (which_alternative == 7) {
      /* special case for alternative 7, with two chances but only one taken */
      if (pic30_pre_modify(operands[0])) {
        return \"add %r0,#4,%r0\;\"
               \"xor %1,%2,%I0\;\"
               \"xor %d1,%2,%D0\";
      } else if (pic30_pre_modify(operands[2])) {
        return \"add %r2,#4,%r2\;\"
               \"xor %1,%I2,%0\;\"
               \"xor %d1,%D2,%0\";
      }
    } else if (pic30_pre_modify(operands[0]) || pic30_pre_modify(operands[2])) {
      return pre_patterns[which_alternative - 8];
    }
    return normal_patterns[which_alternative];
  }
 "
 [
  (set_attr "cc" "clobber")  ; CAW
  (set_attr "type" "def,defuse,use,use,use,def,use,use,use,use,use")
  (set_attr "op_type" "alu")
 ]
)

(define_expand "xor<mode>3_16"
 [(set (match_operand:GM32BIT 0 "pic30_mode2_operand"
             "=r<>,&r<>,R,R,R,  R,r,&r,<>")
       (xor:GM32BIT
          (match_operand:GM32BIT 1 "pic30_register_operand"
             "%r,   r,  r,r,r,  r,0, r,r")
          (match_operand:GM32BIT 2 "pic30_mode1P_APSV_operand"
             "r<>, R,  0,R,r<>,P,P, P,P")))
 ]
 ""
 "
{
  if (pic30_register_operand(operands[1],GET_MODE(operands[1])) &&
      pic30_mode1P_operand(operands[2],GET_MODE(operands[2])))
    emit(
      gen_xor<mode>3_DATA_16(operands[0],operands[1],operands[2])
    );
  else if (pic30_register_operand(operands[1],GET_MODE(operands[1])) &&
           pic30_mode1P_APSV_operand(operands[2],GET_MODE(operands[2])))
    emit(
      gen_xor<mode>3_APSV_16(operands[0],operands[1],operands[2])
    );
  else {
    rtx op1,op2;
   
    op1 = force_reg(GET_MODE(operands[0]),operands[1]);
    op2 = force_reg(GET_MODE(operands[0]),operands[2]);
    emit(
      gen_xor<mode>3_DATA_16(operands[0],op1,op2)
    );
  }
  DONE;
}")



;;;;;;;;;;;;;;;;;
;; double integer
;;;;;;;;;;;;;;;;;

(define_insn "*xorhidi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (sign_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;xor %1,%2,%0\;xor %3,%d2,%d0\;\"
                              \"xor %3,%t2,%t0\;xor %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;xor %1,%2,%0\;xor %3,%d2,%0\;\"
                              \"xor %3,%t2,%0\;xor %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;xor %1,%s2,%0\;xor %3,%s2,%0\;\"
                              \"xor %3,%s2,%0\;xor %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;xor %1,%2,%0\;xor %3,%2,%0\;\"
                              \"xor %3,%2,%0\;xor %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;xor %1,%2,%0\;xor %3,%2,%d0\;\"
                              \"xor %3,%2,%t0\;xor %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;xor %1,%2,%I0\;xor %3,%d2,%I0\;\"
                              \"xor %3,%t2,%I0\;xor %3,%q2,%0\",

     /* R,r,0 */          \"asr %1,#15,%3\;xor %1,%2,%I0\;xor %3,%2,%I0\;\"
                              \"xor %3,%2,%I0\;xor %3,%2,%0\",

     /* R,r,R */          \"asr %1,#15,%3\;xor %1,%I2,%I0\;xor %3,%I2,%I0\;\"
                              \"xor %3,%I2,%I0\;xor %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;xor %1,%I2,%0\;xor %3,%I2,%d0\;\"
                              \"xor %3,%I2,%t0\;xor %3,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %1,#15,%3\;xor %1,%2,%0\;xor %3,%d2,%d0\;\"
                              \"xor %3,%t2,%t0\;xor %3,%q2,%q0\",

     /* >,r,r */          \"asr %1,#15,%3\;xor %1,%2,%0\;xor %3,%d2,%0\;\"
                              \"xor %3,%t2,%0\;xor %3,%q2,%0\",

     /* >,r,0 */          \"asr %1,#15,%3\;xor %1,%s2,%0\;xor %3,%s2,%0\;\"
                              \"xor %3,%s2,%0\;xor %3,%s2,%0\",

     /* >,r,> */          \"asr %1,#15,%3\;\"
                          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\",

     /* r,r,> */          \"asr %1,#15,%3\;\"
                          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%q0\",

     /* R,r,r */          \"asr %1,#15,%3\;xor %1,%2,%I0\;xor %3,%d2,%I0\;\"
                              \"xor %3,%t2,%I0\;xor %3,%q2,%0\",

     /* R,r,0 */          \"asr %1,#15,%3\;\"
                          \"xor %1,%2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\",

     /* R,r,R */          \"asr %1,#15,%3\;\"
                          \"xor %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\",

     /* r,r,R */          \"asr %1,#15,%3\;\"
                          \"xor %1,%I2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%I2,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*xorhidi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (zero_extend:DI
              (match_operand:HI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                   "=X,X,&r,&r,&r,X,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;mov %d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;mov %d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%s0\;add #8,%r0\",

     /* >,r,> */          \"xor %1,%2,%0\;mov %2,%0\;mov %2,%0\;mov %2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;mov %2,%d0\;mov.d %2,%t0\",

     /* R,r,r */          \"xor %1,%2,%0\;mov %d2,%Q0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"xor %1,%2,%0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;mov %I2,%I0\;mov %I2,%I0\;mov %2,%0\",

     /* r,r,R */          \"xor %1,%2,%0\;mov %Q2,%d0\;mov %R2,%t0\;mov %S2,%q0\"
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;mov %d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;mov %d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%s0\;add #8,%r0\",

     /* >,r,> */          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;mov %2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%d0\;\"
                          \"nop\;\"
                          \"mov.d %2,%t0\",

     /* R,r,r */          \"xor %1,%2,%0\;mov %d2,%Q0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"xor %1,%2,%0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %Q2,%d0\;\"
                          \"nop\;\"
                          \"mov %R2,%t0\;\"
                          \"nop\;\"
                          \"mov %S2,%q0\"
  };
  
  const char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;mov %d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;mov %d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%s0\;add #8,%r0\",

     /* >,r,> */          \"xor %1,%2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov %2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;\"
                          \"mov %2,%d0\;\"
                          \"mov %2,%t0\;\"
                          \"mov %2,%q0\",

     /* R,r,r */          \"xor %1,%2,%0\;\"
                          \"mov %d2,%Q0\;\"
                          \"mov %t2,%R0\;\"
                          \"mov %q2,%S0\",

     /* R,r,0 */          \"xor %1,%2,%0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"xor %1,%2,%0\;\"
                          \"mov %Q2,%d0\;\"
                          \"mov %R2,%t0\;\"
                          \"mov %S2,%q0\"
  };
  

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
              }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*xorsidi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (sign_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;xor %1,%2,%0\;xor %d1,%d2,%d0\;\"
                              \"xor %3,%t2,%t0\;xor %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;xor %1,%2,%0\;xor %d1,%d2,%0\;\"
                              \"xor %3,%t2,%0\;xor %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;xor %1,%s2,%0\;xor %d1,%s2,%0\;\"
                              \"xor %3,%s2,%0\;xor %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;xor %1,%2,%0\;xor %d1,%2,%0\;\"
                              \"xor %3,%2,%0\;xor %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;xor %1,%2,%0\;xor %d1,%2,%d0\;\"
                              \"xor %3,%2,%t0\;xor %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;xor %1,%2,%I0\;xor %d1,%d2,%I0\;\"
                              \"xor %3,%t2,%I0\;xor %3,%q2,%0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;xor %1,%2,%I0\;xor %d1,%2,%I0\;\"
                              \"xor %3,%2,%I0\;xor %3,%2,%0\",

     /* R,r,R */          \"asr %d1,#15,%3\;xor %1,%I2,%I0\;xor %d1,%I2,%I0\;\"
                              \"xor %3,%I2,%I0\;xor %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;xor %1,%I2,%0\;xor %d1,%I2,%d0\;\"
                              \"xor %3,%I2,%t0\;xor %3,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d1,#15,%3\;xor %1,%2,%0\;xor %d1,%d2,%d0\;\"
                              \"xor %3,%t2,%t0\;xor %3,%q2,%q0\",

     /* >,r,r */          \"asr %d1,#15,%3\;xor %1,%2,%0\;xor %d1,%d2,%0\;\"
                              \"xor %3,%t2,%0\;xor %3,%q2,%0\",

     /* >,r,0 */          \"asr %d1,#15,%3\;xor %1,%s2,%0\;xor %d1,%s2,%0\;\"
                              \"xor %3,%s2,%0\;xor %3,%s2,%0\",

     /* >,r,> */          \"asr %d1,#15,%3\;\"
                          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\",

     /* r,r,> */          \"asr %d1,#15,%3\;\"
                          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%q0\",

     /* R,r,r */          \"asr %d1,#15,%3\;xor %1,%2,%I0\;xor %d1,%d2,%I0\;\"
                              \"xor %3,%t2,%I0\;xor %3,%q2,%0\",

     /* R,r,0 */          \"asr %d1,#15,%3\;xor %1,%2,%I0\;xor %d1,%2,%I0\;\"
                              \"xor %3,%2,%I0\;xor %3,%2,%0\",

     /* R,r,R */          \"asr %d1,#15,%3\;\"
                          \"xor %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%0\",

     /* r,r,R */          \"asr %d1,#15,%3\;\"
                          \"xor %1,%I2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%I2,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*xorsidi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (zero_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%0\;xor %d1,%s2,%0\;add #4,%0\",

     /* >,r,> */          \"xor %1,%2,%0\;xor %d1,%2,%0\;\"
                              \"mov %2,%0\;mov %2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;xor %d1,%2,%d0\;mov.d %2,%t0\",

     /* R,r,r */          \"xor %1,%2,%I0\;xor %d1,%d2,%D0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"xor %1,%2,%I0\;xor %d1,%2,%D0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;xor %d1,%I2,%I0\;mov %I2,%I0\;mov %2,%0\",

     /* r,r,R */          \"xor %1,%I2,%0\;xor %d1,%D2,%d0\;mov %R2,%t0\;mov %S2,%q0\"
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%0\;xor %d1,%s2,%0\;add #4,%0\",

     /* >,r,> */          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\;\"
                          \"nop\;\"
                          \"mov %2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"mov.d %2,%t0\",

     /* R,r,r */          \"xor %1,%2,%I0\;xor %d1,%d2,%D0\;mov %t2,%R0\;mov %q2,%S0\",

     /* R,r,0 */          \"xor %1,%2,%I0\;xor %d1,%2,%D0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"mov %I2,%I0\;\"
                          \"nop\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"xor %1,%I2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%D2,%d0\;\"
                          \"nop\;\"
                          \"mov %R2,%t0\;\"
                          \"nop\;\"
                          \"mov %S2,%q0\"
  };

  const char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;mov.d %t2,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;mov.d %t2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%0\;xor %d1,%s2,%0\;add #4,%0\",

     /* >,r,> */          \"xor %1,%2,%0\;\"
                          \"xor %d1,%2,%0\;\"
                          \"mov %2,%0\;\"
                          \"mov %2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;\"
                          \"xor %d1,%2,%d0\;\"
                          \"mov %2,%t0\;\"
                          \"mov %2,%q0\",

     /* R,r,r */          \"xor %1,%2,%I0\;\"
                          \"xor %d1,%d2,%D0\;\"
                          \"mov %t2,%R0\;\"
                          \"mov %q2,%S0\",

     /* R,r,0 */          \"xor %1,%2,%I0\;xor %d1,%2,%D0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;\"
                          \"xor %d1,%I2,%I0\;\"
                          \"mov %I2,%I0\;\"
                          \"mov %2,%0\",

     /* r,r,R */          \"xor %1,%I2,%0\;\"
                          \"xor %d1,%D2,%d0\;\"
                          \"mov %R2,%t0\;\"
                          \"mov %S2,%q0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];


     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

   }
}"
   [
     (set_attr "cc" "math,math,math,math,math,clobber,clobber,clobber,clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*xordihi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;xor %2,%1,%0\;xor %3,%d1,%d0\;\"
                              \"xor %3,%t1,%t0\;xor %3,%q1,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;xor %2,%1,%0\;xor %3,%d1,%0\;\"
                              \"xor %3,%t1,%0\;xor %3,%q1,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;xor %2,%s1,%0\;xor %3,%s1,%0\;\"
                              \"xor %3,%s1,%0\;xor %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;xor %2,%1,%0\;xor %3,%1,%0\;\"
                              \"xor %3,%1,%0\;xor %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;xor %2,%1,%0\;xor %3,%1,%d0\;\"
                              \"xor %3,%1,%t0\;xor %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;xor %2,%1,%I0\;xor %3,%d1,%I0\;\"
                              \"xor %3,%t1,%I0\;xor %3,%q1,%0\",

     /* R,0,r */          \"asr %2,#15,%3\;xor %2,%1,%I0\;xor %3,%1,%I0\;\"
                              \"xor %3,%1,%I0\;xor %3,%1,%0\",

     /* R,R,r */          \"asr %2,#15,%3\;xor %2,%I1,%I0\;xor %3,%I1,%I0\;\"
                              \"xor %3,%I1,%I0\;xor %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;xor %2,%I1,%0\;xor %3,%I1,%d0\;\"
                              \"xor %3,%I1,%t0\;xor %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %2,#15,%3\;xor %2,%1,%0\;xor %3,%d1,%d0\;\"
                              \"xor %3,%t1,%t0\;xor %3,%q1,%q0\",

     /* >,r,r */          \"asr %2,#15,%3\;xor %2,%1,%0\;xor %3,%d1,%0\;\"
                              \"xor %3,%t1,%0\;xor %3,%q1,%0\",

     /* >,0,r */          \"asr %2,#15,%3\;xor %2,%s1,%0\;xor %3,%s1,%0\;\"
                              \"xor %3,%s1,%0\;xor %3,%s1,%0\",

     /* >,>,r */          \"asr %2,#15,%3\;\"
                          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\",

     /* r,>,r */          \"asr %2,#15,%3\;\"
                          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%q0\",

     /* R,r,r */          \"asr %2,#15,%3\;xor %2,%1,%I0\;xor %3,%d1,%I0\;\"
                              \"xor %3,%t1,%I0\;xor %3,%q1,%0\",

     /* R,0,r */          \"asr %2,#15,%3\;xor %2,%1,%I0\;xor %3,%1,%I0\;\"
                              \"xor %3,%1,%I0\;xor %3,%1,%0\",

     /* R,R,r */          \"asr %2,#15,%3\;\"
                          \"xor %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\",

     /* r,R,r */          \"asr %2,#15,%3\;\"
                          \"xor %2,%I1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%I1,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*xordihi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:HI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;mov %d1,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;mov %d1,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"xor %2,%s1,%s0\;add #8,%r0\",

     /* >,>,r */          \"xor %2,%1,%0\;mov %1,%0\;mov %1,%0\;mov %1,%0\",

     /* r,>,r */          \"xor %2,%1,%0\;mov %1,%d0\;mov.d %1,%t0\",

     /* R,r,r */          \"xor %2,%1,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"xor %2,%1,%0\",

     /* R,R,r */          \"xor %2,%I1,%I0\;mov %I1,%I0\;mov %I1,%I0\;mov %1,%0\",

     /* r,R,r */          \"xor %2,%1,%0\;mov %Q1,%d0\;mov %R1,%t0\;mov %S1,%q0\"
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;mov %d1,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;mov %d1,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"xor %2,%s1,%s0\;add #8,%r0\",

     /* >,>,r */          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,>,r */          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%d0\;\"
                          \"nop\;\"
                          \"mov.d %1,%t0\",

     /* R,r,r */          \"xor %2,%1,%0\;mov %d1,%Q0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"xor %2,%1,%0\",

     /* R,R,r */          \"xor %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"mov %I1,%I0\;\"
                          \"nop\;\"
                          \"mov %I1,%I0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %Q1,%d0\;\"
                          \"nop\;\"
                          \"mov %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %S1,%q0\"
  };

  const char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;mov %d1,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;mov %d1,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"xor %2,%s1,%s0\;add #8,%r0\",

     /* >,>,r */          \"xor %2,%1,%0\;\"
                          \"mov %1,%0\;\"
                          \"mov %1,%0\;\"
                          \"mov %1,%0\",

     /* r,>,r */          \"xor %2,%1,%0\;\"
                          \"mov %1,%d0\;\"
                          \"mov %1,%t0\;\"
                          \"mov %1,%q0\",

     /* R,r,r */          \"xor %2,%1,%0\;\"
                          \"mov %d1,%Q0\;\"
                          \"mov %t1,%R0\;\"
                          \"mov %q1,%S0\",

     /* R,0,r */          \"xor %2,%1,%0\",

     /* R,R,r */          \"xor %2,%I1,%I0\;\"
                          \"mov %I1,%I0\;\"
                          \"mov %I1,%I0\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"xor %2,%1,%0\;\"
                          \"mov %Q1,%d0\;\"
                          \"mov %R1,%t0\;\"
                          \"mov %S1,%q0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

              }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*xordisi3_se_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (match_operand:DI 1 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (sign_extend:DI
              (match_operand:SI 2 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (match_scratch:HI 3                   "=&r,&r,&r,&r,&r,&r,&r,&r,&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;xor %2,%1,%0\;xor %d2,%d1,%d0\;\"
                              \"xor %3,%t1,%t0\;xor %3,%q1,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;xor %2,%1,%0\;xor %d2,%d1,%0\;\"
                              \"xor %3,%t1,%0\;xor %3,%q1,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;xor %2,%s1,%0\;xor %d2,%s1,%0\;\"
                              \"xor %3,%s1,%0\;xor %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;xor %2,%1,%0\;xor %d2,%1,%0\;\"
                              \"xor %3,%1,%0\;xor %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;xor %2,%1,%0\;xor %d2,%1,%d0\;\"
                              \"xor %3,%1,%t0\;xor %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;xor %2,%1,%I0\;xor %d2,%d1,%I0\;\"
                              \"xor %3,%t1,%I0\;xor %3,%q1,%0\",

     /* R,0,r */          \"asr %d2,#15,%3\;xor %2,%1,%I0\;xor %d2,%1,%I0\;\"
                              \"xor %3,%1,%I0\;xor %3,%1,%0\",

     /* R,R,r */          \"asr %d2,#15,%3\;xor %2,%I1,%I0\;xor %d2,%I1,%I0\;\"
                              \"xor %3,%I1,%I0\;xor %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;xor %2,%I1,%0\;xor %d2,%I1,%d0\;\"
                              \"xor %3,%I1,%t0\;xor %3,%1,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"asr %d2,#15,%3\;xor %2,%1,%0\;xor %d2,%d1,%d0\;\"
                              \"xor %3,%t1,%t0\;xor %3,%q1,%q0\",

     /* >,r,r */          \"asr %d2,#15,%3\;xor %2,%1,%0\;xor %d2,%d1,%0\;\"
                              \"xor %3,%t1,%0\;xor %3,%q1,%0\",

     /* >,0,r */          \"asr %d2,#15,%3\;xor %2,%s1,%0\;xor %d2,%s1,%0\;\"
                              \"xor %3,%s1,%0\;xor %3,%s1,%0\",

     /* >,>,r */          \"asr %d2,#15,%3\;\"
                          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %d2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\",

     /* r,>,r */          \"asr %d2,#15,%3\;\"
                          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%q0\",

     /* R,r,r */          \"asr %d2,#15,%3\;xor %2,%1,%I0\;xor %d2,%d1,%I0\;\"
                              \"xor %3,%t1,%I0\;xor %3,%q1,%0\",

     /* R,0,r */          \"asr %d2,#15,%3\;xor %2,%1,%I0\;xor %d2,%1,%I0\;\"
                              \"xor %3,%1,%I0\;xor %3,%1,%0\",

     /* R,R,r */          \"asr %d2,#15,%3\;\"
                          \"xor %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%0\",

     /* r,R,r */          \"asr %d2,#15,%3\;\"
                          \"xor %2,%I1,%0\;\"
                          \"nop\;\"
                          \"xor %d2,%I1,%d0\;\"
                          \"nop\;\"
                          \"xor %3,%I1,%t0\;\"
                          \"nop\;\"
                          \"xor %3,%1,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,0,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[1],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;

     case 8:  /* r,R,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[1],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r1\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "*xordisi3_ze_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")
           (zero_extend:DI
              (match_operand:SI 1 "pic30_register_operand" "r,r,r,r, r,r,r,r, r"))
        )
   )
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"xor %2,%s1,%0\;xor %d2,%s1,%0\;add #4,%r0\",

     /* >,>,r */          \"xor %2,%1,%0\;xor %d2,%1,%0\;\"
                              \"mov %1,%0\;mov %1,%0\",

     /* r,>,r */          \"xor %2,%1,%0\;xor %d2,%1,%d0\;mov.d %1,%t0\",

     /* R,r,r */          \"xor %2,%1,%I0\;xor %d2,%d1,%D0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"xor %2,%1,%I0\;xor %d2,%1,%D0\",

     /* R,R,r */          \"xor %2,%I1,%I0\;xor %d2,%I1,%I0\;mov %I1,%I0\;mov %1,%0\",

     /* r,R,r */          \"xor %2,%I1,%0\;xor %d2,%D1,%d0\;mov %R1,%t0\;mov %S1,%q0\"
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"xor %2,%s1,%0\;xor %d2,%s1,%0\;add #4,%r0\",

     /* >,>,r */          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %d2,%1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,>,r */          \"xor %2,%1,%0\;\"
                          \"nop\;\"
                          \"xor %d2,%1,%d0\;\"
                          \"nop\;\"
                          \"mov.d %1,%t0\",

     /* R,r,r */          \"xor %2,%1,%I0\;xor %d2,%d1,%D0\;mov %t1,%R0\;mov %q1,%S0\",

     /* R,0,r */          \"xor %2,%1,%I0\;xor %d2,%1,%D0\",

     /* R,R,r */          \"xor %2,%I1,%I0\;\"
                          \"nop\;\"
                          \"xor %d2,%I1,%I0\;\"
                          \"nop\;\"
                          \"mov %I1,%I0\;\"
                          \"nop\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"xor %2,%I1,%0\;\"
                          \"nop\;\"
                          \"xor %d2,%D1,%d0\;\"
                          \"nop\;\"
                          \"mov %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %S1,%q0\"
  };

  const char *psv_psv_movd_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;mov.d %t1,%t0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;mov.d %t1,%0\",

     /* >,0,r */          \"xor %2,%s1,%0\;xor %d2,%s1,%0\;add #4,%r0\",

     /* >,>,r */          \"xor %2,%1,%0\;\"
                          \"xor %d2,%1,%0\;\"
                          \"mov %1,%0\;\"
                          \"mov %1,%0\",

     /* r,>,r */          \"xor %2,%1,%0\;\"
                          \"xor %d2,%1,%d0\;\"
                          \"mov %1,%t0\;\"
                          \"mov %1,%q0\",

     /* R,r,r */          \"xor %2,%1,%I0\;\"
                          \"xor %d2,%d1,%D0\;\"
                          \"mov %t1,%R0\;\"
                          \"mov %q1,%S0\",

     /* R,0,r */          \"xor %2,%1,%I0\;xor %d2,%1,%D0\",

     /* R,R,r */          \"xor %2,%I1,%I0\;\"
                          \"xor %d2,%I1,%I0\;\"
                          \"mov %I1,%I0\;\"
                          \"mov %1,%0\",

     /* r,R,r */          \"xor %2,%I1,%0\;\"
                          \"xor %d2,%D1,%d0\;\"
                          \"mov %R1,%t0\;\"
                          \"mov %S1,%q0\"
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata_movd(NULL,operands[2])) {
    patterns = psv_psv_movd_patterns;
  } else if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
              }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)

(define_insn "xordi3_16"
  [(set (match_operand:DI 0 "pic30_DI_mode2_operand"         "=r,>,>,>,&r,R,R,R,&r")
        (xor:DI
           (match_operand:DI 1 "pic30_register_operand"    "r,r,r,r, r,r,r,r, r")
           (match_operand:DI 2 "pic30_DI_mode2_operand"       "r,r,0,>, >,r,0,R, R")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  const char *noerrata_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;\"
                              \"xor %t1,%t2,%t0\;xor %q1,%q2,%q0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;\"
                              \"xor %t1,%t2,%0\;xor %q1,%q2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%0\;xor %d1,%s2,%0\;\"
                              \"xor %t1,%s2,%0\;xor %q1,%s2,%0\",

     /* >,r,> */          \"xor %1,%s2,%0\;xor %d1,%2,%0\;\"
                              \"xor %t1,%2,%0\;xor %q1,%2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;xor %d1,%2,%d0\;\"
                              \"xor %t1,%2,%t0\;xor %q1,%2,%q0\",

     /* R,r,r */          \"xor %1,%2,%I0\;xor %d1,%d2,%I0\;\"
                              \"xor %t1,%t2,%I0\;xor %q1,%q2,%0\",

     /* R,r,0 */          \"xor %1,%2,%I0\;xor %d1,%2,%I0\;\"
                              \"xor %t1,%2,%I0\;xor %q1,%2,%0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;xor %d1,%I2,%I0\;\"
                              \"xor %t1,%I2,%I0\;xor %q1,%2,%0\",

     /* r,r,R */          \"xor %1,%I2,%0\;xor %d1,%I2,%d0\;\"
                              \"xor %t1,%I2,%t0\;xor %q1,%2,%q0\",
  };

  const char *psv_psv_patterns[] = {
     /* r,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%d0\;\"
                              \"xor %t1,%t2,%t0\;xor %q1,%q2,%q0\",

     /* >,r,r */          \"xor %1,%2,%0\;xor %d1,%d2,%0\;\"
                              \"xor %t1,%t2,%0\;xor %q1,%q2,%0\",

     /* >,r,0 */          \"xor %1,%s2,%0\;xor %d1,%s2,%0\;\"
                              \"xor %t1,%s2,%0\;xor %q1,%s2,%0\",

     /* >,r,> */          \"xor %1,%s2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %t1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %q1,%2,%0\",

     /* r,r,> */          \"xor %1,%2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%2,%d0\;\"
                          \"nop\;\"
                          \"xor %t1,%2,%t0\;\"
                          \"nop\;\"
                          \"xor %q1,%2,%q0\",

     /* R,r,r */          \"xor %1,%2,%I0\;xor %d1,%d2,%I0\;\"
                              \"xor %t1,%t2,%I0\;xor %q1,%q2,%0\",

     /* R,r,0 */          \"xor %1,%2,%I0\;xor %d1,%2,%I0\;\"
                              \"xor %t1,%2,%I0\;xor %q1,%2,%0\",

     /* R,r,R */          \"xor %1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %d1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %t1,%I2,%I0\;\"
                          \"nop\;\"
                          \"xor %q1,%2,%0\",

     /* r,r,R */          \"xor %1,%I2,%0\;\"
                          \"nop\;\"
                          \"xor %d1,%I2,%d0\;\"
                          \"nop\;\"
                          \"xor %t1,%I2,%t0\;\"
                          \"nop\;\"
                          \"xor %q1,%2,%q0\",
  };

  /* increasing the patterns, means increasing this number too */
  static char szInsns[180];
  rtx x;
  const char **patterns;

  if (pic30_psrd_psrd_errata(NULL,operands[2])) {
    pic30_rtx_nops += 3;
    patterns = psv_psv_patterns;
  } else {
    patterns = noerrata_patterns;
  }

  switch (which_alternative) {
     default: return patterns[which_alternative];

     case 5:  /* R,r,r */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 6:  /* R,r,0 */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }
              return szInsns;

     case 7:  /* R,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[0],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r0\");
              }

              x = XEXP(operands[2],0);
	      if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;

     case 8:  /* r,r,R */
              strcpy(szInsns, patterns[which_alternative]);

              x = XEXP(operands[2],0);
              if (!pic30_dead_or_set_p(NEXT_INSN(insn), x) &&
                  !find_regno_note(insn, REG_UNUSED, REGNO(x))) {
                 strcat(szInsns,\"\;sub #6,%r2\");
              }
              return szInsns;
   }
}"
   [
     (set_attr "cc" "clobber")
     (set_attr "type" "def")
     (set_attr "op_type" "alu")
  ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; NOT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; QImode ;;
;;;;;;;;;;;;

(define_insn "one_cmplqi2_DATA_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (not:QI (match_operand:QI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "com.b %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "one_cmplqi2_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (not:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "com.b %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*one_cmplqi2_sfr_16"
  [(set (match_operand:QI 0 "pic30_near_operand"        "=U")
        (not:QI (match_dup 0)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "com.b %0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_expand "one_cmplqi2_16"
  [(set (match_operand:QI 0 "general_operand")
        (not:QI (match_operand:QI 1 "general_operand")))]
  "(!pic30_isa32_target())"
  "{
      if (pic30_mode2_operand(operands[0],QImode)) {
        if (pic30_mode2_operand(operands[1],QImode)) {
          emit(gen_one_cmplqi2_DATA_16(operands[0],operands[1]));
          DONE;
        } else if (pic30_mode2_APSV_operand(operands[1],QImode)) {
          emit(gen_one_cmplqi2_APSV_16(operands[0],operands[1]));
          DONE;
        } else {
          rtx op1 = gen_reg_rtx(QImode);

          emit_move_insn(op1, operands[1]);
          emit(gen_one_cmplqi2_DATA_16(operands[0],op1));
          DONE;
        }
      }
      FAIL;
   }"
)

;;;;;;;;;;;;
;; HImode ;;
;;;;;;;;;;;;

(define_insn "one_cmplhi2_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (not:HI 
           (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "com %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "one_cmplhi2_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"        "=r<>,r<>,R,R")
        (not:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "com %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "one_cmplhi2_16"
  [(set (match_operand: HI 0 "general_operand")
        (not: HI (match_operand:HI 1 "general_operand")))
  ]
  "(!pic30_isa32_target())"
  "{
      if (pic30_mode2_operand(operands[0],HImode)) {
        if (pic30_mode2_operand(operands[1],HImode)) {
          emit(gen_one_cmplhi2_DATA_16(operands[0],operands[1]));
          DONE;
        } else if (pic30_mode2_APSV_operand(operands[1],HImode)) {
          emit(gen_one_cmplhi2_APSV_16(operands[0],operands[1]));
          DONE;
        } else {
          rtx op1 = gen_reg_rtx(HImode);

          emit_move_insn(op1, operands[1]);
          emit(gen_one_cmplhi2_DATA_16(operands[0],op1));
          DONE;
        }
      }
      FAIL;
   }"
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*one_cmplhi2_sfr_16"
  [(set (match_operand:HI 0 "pic30_near_operand"        "=U")
        (not:HI (match_dup 0)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "com %0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;
;; SImode ;;
;;;;;;;;;;;;

(define_insn "one_cmplsi2_16"
  [(set (match_operand:SI 0 "pic30_register_operand"        "=r")
        (not:SI (match_operand:SI 1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "com %1,%0\;com %d1,%d0"
  [
   (set_attr "cc" "clobber") 
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*one_cmplsi2_sfr_16"
  [(set (match_operand:SI 0 "pic30_near_operand"        "=U")
        (not:SI (match_dup 0)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "com %0\;com %0+2"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

;; DImode

(define_insn "one_cmpldi2_16"
  [(set (match_operand:DI 0 "pic30_register_operand"        "=r")
        (not:DI (match_operand:DI 1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "com %1,%0\;com %d1,%d0\;com %t1,%t0\;com %q1,%q0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*one_cmpldi2_sfr_16"
  [(set (match_operand:DI 0 "pic30_near_operand"        "=U")
        (not:DI (match_dup 0)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "com %0\;com %0+2\;com %0+4\;com %0+6"
  [
    (set_attr "cc" "clobber")
    (set_attr "op_type" "alu")
  ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Find first one
;;
;; Represents one plus the index of the least significant 1-bit in X,
;; represented as an integer of mode M.  (The value is zero if X is
;; zero.)  The mode of X need not be M; depending on the target
;; machine, various mode combinations may be valid.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "ffshi2_DATA_16"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (ffs:HI 
           (match_operand:HI 1 "pic30_mode2_operand" "r,R<>")))
   (clobber (reg:CC_C CC_REG))
  ]
  "(!pic30_isa32_target())"
  "ff1r %1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ffshi2_APSV_16"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (ffs:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,R<>")))
   (clobber (reg:CC_C CC_REG))
  ]
  "(!pic30_isa32_target())"
  "ff1r %1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "ffshi2_16"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (ffs:HI 
           (match_operand:HI 1 "pic30_mode2_operand" "r,R<>")))
  ]
  "(!pic30_isa32_target())"
  "{
     if (pic30_mode2_APSV_operand(operands[1],GET_MODE(operands[1]))) {
       emit(
         gen_ffshi2_APSV_16(operands[0], operands[1])
       );
     } else {
       emit(
         gen_ffshi2_DATA_16(operands[0], operands[1])
       );
     }
     DONE;
   }")

(define_insn "ff1lhi2_DATA_16"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (unspec:HI [
          (match_operand:HI 1 "pic30_mode2_operand" "r,R<>")
        ] UNSPEC_FF1L))
   (clobber (reg:CC_C CC_REG))
  ]
  "(!pic30_isa32_target())"
  "ff1l %1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ff1lhi2_APSV_16"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (unspec:HI [
          (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,R<>")
         ] UNSPEC_FF1L))
   (clobber (reg:CC_C CC_REG))
  ]
  "(!pic30_isa32_target())"
  "ff1l %1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def,defuse")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "ff1lhi2_16"
  [(set (match_operand:HI 0 "pic30_register_operand"           "=r,r")
        (unspec:HI [
           (match_operand:HI 1 "pic30_mode2_operand" "r,R<>")
         ] UNSPEC_FF1L))
  ]
  "(!pic30_isa32_target())"
  "{
     if (pic30_mode2_APSV_operand(operands[1],GET_MODE(operands[1]))) {
       emit(
         gen_ff1lhi2_APSV_16(operands[0], operands[1])
       );
     } else {
       emit(
         gen_ff1lhi2_DATA_16(operands[0], operands[1])
       );
     }
     DONE;
   }")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Shift instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Arithmetic Shift Left instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; QImode ;;
;;;;;;;;;;;;

(define_insn "*ashlqi3_gen_1_DATA_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (ashift:QI (match_operand:QI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                   (match_operand:QI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sl.b %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*ashlqi3_gen_1_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (ashift:QI (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
                   (match_operand:QI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sl.b %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*ashlqi3_sfr_1_16"
  [(set (match_operand:QI 0 "pic30_wreg_or_near_operand"   "=a,U")
        (ashift:QI (match_operand:QI 1 "pic30_near_operand" "U,0")
                   (match_operand:QI 2 "pic30_I_operand"    "I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    sl.b %1,WREG
    sl.b %0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,etc")
   (set_attr "op_type" "alu")
  ]
)

;; For shift by n, we operate in word mode.
;; This is ok, since we are shifting left
;; (zeroes are inserted from the right).
;; However, the condition codes are not useful.

;; for register sl, must first mask off upper bits because
;;   if it was loaded with a mov.b (likely) into a dirty register (possible)
;;   then the word-sized shift value will saturate

(define_insn "ashlqi3_unused_16"
  [(set (match_operand:QI 0 "pic30_register_operand"                 "=r,r")
        (ashift:QI (match_operand:QI 1 "pic30_register_operand"       "r,r")
                   (match_operand:QI 2 "pic30_reg_or_P_operand" "r,P")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "0"
  "@
    and.w #0xFF,%2\;sl %1,%2,%0
    sl %1,#%2,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashlqiqi3_16"
  [(set (match_operand:QI 0 "pic30_register_operand"                 "=r,r")
        (ashift:QI (match_operand:QI 1 "pic30_register_operand"       "r,r")
                   (match_operand:QI 2 "pic30_reg_or_P_operand"       "r,P")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    sl %1,%2,%0
    sl %1,#%2,%0"
  [
   (set_attr "cc" "clobber") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashlqihi3_16"
  [(set (match_operand:QI 0 "pic30_register_operand"                 "=r,r")
        (ashift:QI (match_operand:QI 1 "pic30_register_operand"       "r,r")
                   (match_operand:HI 2 "pic30_reg_or_P_operand"       "r,P")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    sl %1,%2,%0
    sl %1,#%2,%0"
  [
   (set_attr "cc" "clobber") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "ashlqi3_16"
  [(set (match_operand:QI   0 "pic30_register_operand"   "=r,r,r")
        (ashift:SI
          (match_operand:QI 1 "pic30_register_operand"    "r,r,r")
          (match_operand:HI 2 "pic30_reg_or_imm_operand"  "Kq,i,r")))
  ]
  "(pic30_isa32_target())"
  "{ rtx op2 = operands[2];

     if (GET_CODE(op2) == SUBREG) {
       op2 = XEXP(op2,0);
     }
     if (GET_MODE(op2) == E_QImode) {
       emit(
         gen_ashlqiqi3_16(operands[0],operands[1],op2)
       );
     } else {
       // voidmode, himode, or subreg of some other mode
       emit(
         gen_ashlqihi3_16(operands[0],operands[1],operands[2])
       );
     }
     DONE;
   }"
)

;;;;;;;;;;;;
;; HImode ;;
;;;;;;;;;;;;

(define_insn "*ashlhi3_gen_1_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (ashift:HI (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                   (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    sl %1,%0
    sl %1,%0
    sl %1,%0
    sl %1,%0"
 [
  (set_attr "cc" "math") ; CAW
  (set_attr "type" "def,defuse,use,use")
  (set_attr "op_type" "alu")
 ]
)

(define_insn "*ashlhi3_gen_1_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (ashift:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    sl %1,%0
    sl %1,%0
    sl %1,%0
    sl %1,%0"
 [
  (set_attr "cc" "math") ; CAW
  (set_attr "type" "def,defuse,use,use")
  (set_attr "op_type" "alu")
 ]
)

(define_insn_and_split "*ashlhi3_sfr0_16"
  [(set (match_operand:HI 0 "pic30_register_operand"             "=a,?d")
        (ashift:HI (match_operand:HI 1 "pic30_near_operand" "U, U")
                   (match_operand:HI 2 "pic30_I_operand"    "I, I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sl %1,WREG
   mov %1,%0\;sl %0,%0"
  "reload_completed && (!pic30_isa32_target())"
  [
   (set (match_dup 0) (match_dup 1))
   (set (match_dup 0) (ashift:HI (match_dup 0) (const_int 1)))
   (clobber (reg:CC_NZC CC_REG))
  ]
"
{
  if (pic30_wreg_operand(operands[0], HImode)) {
    FAIL;
  }
}
"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*ashlhi3_sfr1_16"
  [(set (match_operand:HI 0 "pic30_near_operand"           "=U")
        (ashift:HI (match_dup 0)
                   (match_operand:HI 1 "pic30_I_operand"    "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sl %0"
  [(set_attr "cc" "math")]) ; CAW

(define_insn "ashlhi3_16"
  [(set (match_operand:HI 0 "pic30_register_operand"              "=r,r,r")
        (ashift:HI (match_operand:HI 1 "pic30_register_operand"   "r,r,r")
                   (match_operand:HI 2 "pic30_reg_or_imm_operand" "Kh,i,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   switch (which_alternative) {
     case 0: 
       return \"sl %1,#%2,%0\";
     case 1: 
       if (INTVAL(operands[2]) < 0)
         return \"asr %1,#%J2%%16,%0\";
       else
         return \"sl %1,#%2%%16,%0\";
     case 2:
         return \"sl %1,%2,%0\";
     default: gcc_assert(0);
   }
}"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashlp16apsv3_16"
  [(set (match_operand:P16APSV 0 "pic30_register_operand"      "=r,r,r")
        (ashift:P16APSV 
           (match_operand:P16APSV 1 "pic30_register_operand"   "r,r,r")
           (match_operand:P16APSV 2 "pic30_reg_or_imm_operand" "Kh,i,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   switch (which_alternative) {
     case 0:
       return \"sl %1,#%2,%0\";
     case 1:
       if (INTVAL(operands[2]) < 0)
         return \"asr %1,#%J2%%16,%0\";
       else
        return \"sl %1,#%2%%16,%0\";
     case 2:
        return \"sl %1,%2,%0\";
     default: gcc_assert(0);
   }
}"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;
;; SImode ;;
;;;;;;;;;;;;

(define_expand "ashlsi3_16"
  [(set (match_operand:SI 0 "pic30_register_operand" "")
        (ashift:SI (match_operand:SI 1 "pic30_register_operand" "")
                   (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))
  ]
  "(!pic30_isa32_target())"
  "
{
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0:
          emit_insn(gen_movsi_16(operands[0], operands[1]));
          break;
        case 1:
          emit_insn(
            gen_ashlsi3_imm1_16(operands[0], operands[1], operands[2])
          );
          break;
        case 8:
          emit_insn(
            gen_ashlsi3_imm8_16(operands[0], operands[1], operands[2])
          );
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
          emit_insn(
            gen_ashlsi3_imm2to15_16(operands[0],operands[1], operands[2])
          );
          break;
        case 16:
          emit_insn(
            gen_ashlsi3_imm16plus_16(operands[0],operands[1], operands[2])
          );
          break;
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
          emit_insn(
            gen_ashlsi3_imm16plus_16(operands[0],operands[1], operands[2])
          );
          break;
        default:
          emit_insn(
            gen_movsi_16(operands[0], const0_rtx)
          );
          break;
      }
    } else {
      if (optimize_size) {
        emit_insn(
         gen_ashlsi3_reg_Os_16(operands[0],operands[1],operands[2])
        );
      } else {
        emit_insn(
         gen_ashlsi3_reg_16(operands[0],operands[1],operands[2])
       );
      }
    }
    DONE;
}")

(define_insn "ashlsi3_imm1_16"
  [(set (match_operand:SI 0            "pic30_register_operand" "=r")
        (ashift:SI (match_operand:SI 1 "pic30_register_operand"  "r")
                   (match_operand:HI 2 "pic30_I_operand"         "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add %1,%1,%0\;addc %d1,%d1,%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashlsi3_imm8_16"
  [(set (match_operand:SI 0            "pic30_register_operand"  "=&r")
        (ashift:SI (match_operand:SI 1 "pic30_register_operand"   "r")
                   (match_operand:HI 2 "pic30_imm8_operand" "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     int idDst = REGNO(operands[0]);
     int idSrc = REGNO(operands[1]);
     if (idDst == idSrc) {
       return \"sl %d1,#%2,%d0\;\"
              \"swap %1\;\"
              \"mov.b %0,%d0\;\"
              \"clr.b %0\";
     } else {
       return \"sl %d1,#%2,%0\;\"
              \"lsr %1,#%k2,%d0\;\"
              \"ior %0,%d0,%d0\;\"
              \"sl %1,#%2,%0\";
     }
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashlsi3_imm16plus_16"
  [(set (match_operand:SI 0            "pic30_register_operand"  "=r,r")
        (ashift:SI (match_operand:SI 1 "pic30_register_operand"  " r,r")
                   (match_operand:HI 2 "pic30_imm16plus_operand" " Ks,i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sl %1,#%K2,%d0\;mov #0,%0
   mul.uu %0,#0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashlsi3_imm2to15_16"
  [(set (match_operand:SI 0            "pic30_register_operand" "=r,&r")
        (ashift:SI (match_operand:SI 1 "pic30_register_operand"  "r, r")
                   (match_operand:HI 2 "pic30_imm2to15_operand"  "i, i")))
   (clobber (match_scratch:HI 3                                "=&r, X"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
      int idDst, idSrc;

      switch (which_alternative) {
        case 0:
          /*
           ** Take care that the source and dest don't overlap
           */
          idDst = REGNO(operands[0]);
          idSrc = REGNO(operands[1]);
          if (idDst >= idSrc) {
            return \"sl %d1,#%2,%3\;\"
                   \"lsr %1,#%k2,%d0\;\"
                   \"ior %3,%d0,%d0\;\"
                   \"sl %1,#%2,%0\";
          } else {
            return \"sl %1,#%2,%0\;\"
                   \"sl %d1,#%2,%3\;\"
                   \"lsr %1,#%k2,%d0\;\"
                   \"ior %3,%d0,%d0\";
          }
        default:
          /*
           ** The dest and source don't overlap
           ** so use dest lsw as a temporary
           */
          return \"sl %d1,#%2,%0\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %0,%d0,%d0\;\"
                 \"sl %1,#%2,%0\";
      }
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;
;  True it sets a reg, but.... the last instruction is not a load.  etc
;
(define_insn "ashlsi3_reg_Os_16"
  [(set (match_operand:SI            0 "pic30_register_operand" "=r")
        (ashift:SI (match_operand:SI 1 "pic30_register_operand" " 0")
                   (match_operand:HI 2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI        3                          "=2"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(optimize_size) && (!pic30_isa32_target())"
  "*
   {
      return 
      	      \".set ___BP___,0\n\"
              \".LB%=:\;\"
              \"dec %2,%2\;\"
              \"bra n,.LE%=\;\"
              \"add %1,%1,%0\;\"
              \"addc %d1,%d1,%d0\;\"
              \"bra .LB%=\n\"
              \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashlsi3_reg_16"
  [(set (match_operand:SI     0 "pic30_register_operand" "=&r")
        (ashift:SI 
          (match_operand:SI   1 "pic30_register_operand" " r")
          (match_operand:HI   2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI 3                         "=&r"))]
  "(!optimize_size)"
  "subr %2,#16,%3\;bra nn,.LL1%=\;neg %3,%3\;sl %1,%3,%d0\;clr %0\;bra .LL2%=\n.LL1%=:\tlsr %1,%3,%3\;sl %1,%2,%0\;sl %d1,%2,%d0\;ior %3,%d0,%d0\n.LL2%=:"
  [
    (set_attr "cc" "clobber")
  ]
)
;
; P32EDS
;

(define_expand "ashlp32eds3_16"
  [(set (match_operand:P32EDS                0 "pic30_register_operand" "")
        (ashift:P32EDS (match_operand:P32EDS 1 "pic30_register_operand" "")
                       (match_operand:HI     2 "pic30_reg_or_imm_operand" "")))]
  "(!pic30_isa32_target())"
  "
{
  if (GET_CODE(operands[2]) == CONST_INT) {
    switch (INTVAL(operands[2])) {
      case 0:
        emit_insn(
          gen_movp32eds_16(operands[0], operands[1])
        );
        break;
      case 1:
        emit_insn(
          gen_ashlp32eds3_imm1_16(operands[0],operands[1], operands[2])
        );
        break;
      case 8:
        emit_insn(
          gen_ashlp32eds3_imm8_16(operands[0], operands[1], operands[2])
        );
        break;
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
        emit_insn(
          gen_ashlp32eds3_imm2to15_16(operands[0],operands[1], operands[2])
        );
        break;
      case 16:
        emit_insn(
          gen_ashlp32eds3_imm16plus_16(operands[0], operands[1], operands[2])
        );
        break;
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
        emit_insn(
          gen_ashlp32eds3_imm16plus_16(operands[0],operands[1], operands[2])
        );
        break;
      default:
        emit_insn(
          gen_movp32eds_16(operands[0], const0_rtx)
        );
        break;
    }
  } else {
    emit_insn(
      gen_ashlp32eds3_reg_16(operands[0],operands[1],operands[2])
    );
  }
  DONE;
}")

(define_insn "ashlp32eds3_imm1_16"
  [(set (match_operand:P32EDS                0  "pic30_register_operand" "=r")
        (ashift:P32EDS (match_operand:P32EDS 1 "pic30_register_operand"  "r")
                       (match_operand:HI     2 "pic30_I_operand"         "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add %1,%1,%0\;rlc %0,[w15]\;addc %d1,%d1,%d0\;bclr %0,#15"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashlp32eds3_imm8_16"
  [(set (match_operand:P32EDS                0 "pic30_register_operand"  "=r")
        (ashift:P32EDS (match_operand:P32EDS 1 "pic30_register_operand"   "r")
                       (match_operand:HI     2 "pic30_imm8_operand" "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     int idDst = REGNO(operands[0]);
     int idSrc = REGNO(operands[1]);
     if (idDst == idSrc) {
       return \"sl %d1,#%2,%d0\;\"
              \"swap %1\;\"
              \"mov.b %0,%d0\;\"
              \"clr.b %0\";
     } else {
       return \"sl %d1,#%2,%0\;\"
              \"lsr %1,#%k2,%d0\;\"
              \"ior %0,%d0,%d0\;\"
              \"sl %1,#%2,%0\";
     }
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashlp32eds3_imm16plus_16"
  [(set (match_operand:P32EDS                0 "pic30_register_operand"  "=r")
        (ashift:P32EDS (match_operand:P32EDS 1 "pic30_register_operand"  "r")
                       (match_operand:HI     2 "pic30_imm16plus_operand" "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sl %1,#%K2,%d0\;mov #0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashlp32eds3_imm2to15_16"
  [(set (match_operand:P32EDS   0 "pic30_register_operand" "=r, &r")
        (ashift:P32EDS 
          (match_operand:P32EDS 1 "pic30_register_operand" "r,  r")
          (match_operand:HI     2 "pic30_imm2to15_operand" "i,  i")))
   (clobber (match_scratch:HI  3                           "=&r,X"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     int idDst, idSrc;

     switch (which_alternative) {
       case 0:
         /*
          ** Take care that the source and dest don't overlap
          */
         idDst = REGNO(operands[0]);
         idSrc = REGNO(operands[1]);
         if (idDst >= idSrc) {
           return \"sl %d1,#%2,%3\;\"
                  \"lsr %1,#%k2,%d0\;\"
                  \"ior %3,%d0,%d0\;\"
                  \"sl %1,#%2,%0\";
         } else {
           return \"sl %1,#%2,%0\;\"
                  \"sl %d1,#%2,%3\;\"
                  \"lsr %1,#%k2,%d0\;\"
                  \"ior %3,%d0,%d0\";
        }
        default:
          /*
           ** The dest and source don't overlap
           ** so use dest lsw as a temporary
           */
           return \"sl %d1,#%2,%0\;\"
                  \"lsr %1,#%k2,%d0\;\"
                  \"ior %0,%d0,%d0\;\"
                  \"sl %1,#%2,%0\";
     }
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashlp32eds3_reg_16"
  [(set (match_operand:P32EDS                0 "pic30_register_operand" "=r")
        (ashift:P32EDS (match_operand:P32EDS 1 "pic30_register_operand" " 0")
                       (match_operand:HI     2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI                3                          "=2"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
      return \".set ___BP___,0\n\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra n,.LE%=\;\"
             \"add %1,%1,%0\;\"
             \"addc %d1,%d1,%d0\;\"
             \"bra .LB%=\n\"
             \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DImode arithmetic shift left.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "ashldi3_16"
  [(set (match_operand:DI 0 "pic30_register_operand"            "")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand"  "")
                   (match_operand:HI 2 "pic30_reg_or_imm_operand" ""))) 
  ]
  "(!pic30_isa32_target())"
  "
{
    if (GET_CODE(operands[2]) == CONST_INT) {
      if (INTVAL(operands[2]) == 0) {
        emit_insn(
          gen_movdi_16(operands[0], operands[1])
        );
      } else if (INTVAL(operands[2]) == 1) {
        emit_insn(
          gen_ashldi3_imm1_16(operands[0], operands[1], operands[2])
        );
      } else if (INTVAL(operands[2]) >= 2 && INTVAL(operands[2]) <= 63) {
        emit_insn(
          gen_ashldi3_immn_16(operands[0], operands[1], operands[2])
        );
      } else {
        emit_insn(
           gen_movdi_16(operands[0], const0_rtx)
        );
      }
    } else {
      emit_insn(
        gen_ashldi3_reg_16(operands[0],operands[1],operands[2])
      );
    }
    DONE;
}")

(define_insn "ashldi3_imm1_16"
  [(set (match_operand:DI            0 "pic30_register_operand" "=r")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand" " r")
                   (match_operand:HI 2 "immediate_operand"      " i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && INTVAL(operands[2])==1"
  "sl %1,%0\;rlc %d1,%d0\;rlc %t1,%t0\;rlc %q1,%q0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashldi3_imm16_16"
  [(set (match_operand:DI 0            "pic30_register_operand" "=r")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                   (match_operand:HI 2 "immediate_operand" "i")))
  ]
  "(!pic30_isa32_target()) && INTVAL(operands[2])==16"
  "mov %t1,%q0\;mov %d1,%t0\;mov %1,%d0\;mov #0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashldi3_imm32_16"
  [(set (match_operand:DI 0            "pic30_register_operand" "=r")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                   (match_operand:HI 2 "immediate_operand" "i")))
  ]
  "(!pic30_isa32_target()) && INTVAL(operands[2])==32"
  "mov.d %1,%t0\;mul.su %0,#0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashldi3_imm48_16"
  [(set (match_operand:DI 0            "pic30_register_operand" "=r")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                   (match_operand:HI 2 "immediate_operand" "i")))
  ]
  "(!pic30_isa32_target()) && INTVAL(operands[2])==48"
  "mov %1,%q0\;mov #0,%t0\;mul.su %0,#0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashldi3_immn_16"
  [(set (match_operand:DI            0 "pic30_register_operand" "=r")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand" " 0")
                   (match_operand:HI 2 "immediate_operand"      " i")))
   (clobber (match_scratch:HI        3                          "=&r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{ static char buffer[256];
  char *f;
  int results = 0;
  rtx result_reg;
      
  /* how many results do we need?
     if all but the low reg is dead we can shift fewer values */
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0]));
  if (!pic30_dead_or_set_p_with_original(NEXT_INSN(insn), result_reg, 
                                         operands[0]) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg))) 
    results = 1;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+1);
  if (!pic30_dead_or_set_p_with_original(NEXT_INSN(insn), result_reg, 
                                          operands[0]) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+1;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+2);
  if (!pic30_dead_or_set_p_with_original(NEXT_INSN(insn), result_reg, 
                                          operands[0]) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+2;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+3);
  if (!pic30_dead_or_set_p_with_original(NEXT_INSN(insn), result_reg, 
                                          operands[0]) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+3;

  f = buffer;
  f += sprintf(buffer,\".set ___BP___,0 ; (%ld,%d)\;\", 
               INTVAL(operands[2]), results);
  if (INTVAL(operands[2]) < 16) {
    switch (results) {
      case 4:
        if (!optimize_size) {
          f += sprintf(f,
             \"sl %%q1,#%%2,%%q0\;\"
             \"lsr %%t1,#%ld,%%3\;\"
             \"ior %%3,%%q0,%%q0\;\"
             \"sl %%t1,#%%2,%%t0\;\"
             \"lsr %%d1,#%ld,%%3\;\"
             \"ior %%3,%%t0,%%t0\;\"
             \"sl %%d1,#%%2,%%d0\;\"
             \"lsr %%1,#%ld,%%3\;\"
             \"ior %%3,%%d0,%%d0\;\"
             \"sl %%1,#%%2,%%0\",
             16 - INTVAL(operands[2]), 
             16 - INTVAL(operands[2]), 
             16 - INTVAL(operands[2]));
        } else {
          f += sprintf(f,
            \"mov #%%2,%%3\;\"
            \".LB%%=:\;\"
            \"sl %%1,%%0\;\"
            \"rlc %%d1,%%d0\;\"
            \"rlc %%t1,%%t0\;\"
            \"rlc %%q1,%%q0\;\"
            \"dec %%3,%%3\;\"
            \"bra nz,.LB%%=\");
        }
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"sl %%t1,#%%2,%%t0\;\"
           \"lsr %%d1,#%ld,%%3\;\"
           \"ior %%3,%%t0,%%t0\;\"
           \"sl %%d1,#%%2,%%d0\;\"
           \"lsr %%1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"sl %%1,#%%2,%%0\", 
           16 - INTVAL(operands[2]), 
           16 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"sl %%d1,#%%2,%%d0\;\"
           \"lsr %%1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"sl %%1,#%%2,%%0\", 
           16 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
          \"sl %%1,#%%2,%%0\");
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 16) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"mov %%t1,%%q0\;\"
           \"mov %%d1,%%t0\;\"
           \"mov %%1,%%d0\;\"
           \"clr %%0\");
        break;
      case 3:
        f += sprintf(f,
           \"mov %%d1,%%t0\;\"
           \"mov %%1,%%d0\;\"
           \"clr %%0\");
        break;
      case 2:
        f += sprintf(f,
           \"mov %%1,%%d0\;\"
           \"clr %%0\");
        break;
      case 1:
        f += sprintf(f,
           \"clr %%0\");
        break;
    }
    if (((unsigned)(f - buffer)) > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 32) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"sl %%t1,#%ld,%%q0\;\"
           \"lsr %%d1,#%ld,%%3\;\"
           \"ior %%3,%%q0,%%q0\;\"
           \"sl %%d1,#%ld,%%t0\;\"
           \"lsr %%1,#%ld,%%3\;\"
           \"ior %%3,%%t0,%%t0\;\"
           \"sl %%1,#%ld,%%d0\;\"
           \"clr %%0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"sl %%d1,#%ld,%%t0\;\"
           \"lsr %%1,#%ld,%%3\;\"
           \"ior %%3,%%t0,%%t0\;\"
           \"sl %%1,#%ld,%%d0\;\"
           \"clr %%0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"sl %%1,#%ld,%%d0\;\"
           \"clr %%0\",
           INTVAL(operands[2]) - 16);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,\"clr %%0\");
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 32) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"mov.d %%1,%%t0\;\"
           \"mul.uu %%0,#0,%%0\");
        break;
      case 3:
        f += sprintf(f,
           \"mov %%1,%%t0\;\"
           \"mul.uu %%0,#0,%%0\");
        break;
      case 2:
        f += sprintf(f, \"mul.uu %%0,#0,%%0\");
        break;
      case 1:
        f += sprintf(f, \"clr %%0\");
        break;
    }
    if (((unsigned)(f - buffer)) > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 48) {
    switch (results) {
      case 4:
        f += sprintf(f, \"sl %%d1,#%ld,%%q0\;\"
           \"lsr %%1,#%ld,%%3\;\"
           \"ior %%3,%%q0,%%q0\;\"
           \"sl %%1,#%ld,%%t0\;\"
           \"mul.uu %%0,#0,%%0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f, \"sl %%1,#%ld,%%t0\;\"
           \"mul.uu %%0,#0,%%0\",
           INTVAL(operands[2]) - 32);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f, \"mul.uu %%0,#0,%%0\");
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f, \"clr %%0\");
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 48) {
    switch (results) {
      case 4:
        f += sprintf(f, \"mov %%1,%%q0\;\"
           \"clr %%t0\;\"
           \"mul.uu %%0,#0,%%0\");
        break;
      case 3:
        f += sprintf(f, \"clr %%t0\;\"
           \"mul.uu %%0,#0,%%0\");
        break;
      case 2:
        f += sprintf(f, \"mul.uu %%0,#0,%%0\");
        break;
      case 1:
        f += sprintf(f, \"clr %%0\");
        break;
    }
    if (((unsigned)(f - buffer)) > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 64) {
    switch (results) {
      case 4: 
        f += sprintf(f, \"sl %%1,#%ld,%%q0\;\", INTVAL(operands[2])-48);
        /* FALLSTHROUGH */
      case 3:
        f += sprintf(f, \"clr %%t0\;\");
        /* FALLSTHROUGH */
      case 2:
        f += sprintf(f, \"mul.uu %%0,#0,%%0\"); 
        break;
      case 1:
        f += sprintf(f, \"clr %%0\");
        break;
    }
    if (((unsigned)(f - buffer)) > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  }
  gcc_assert(0);
  return \"nop\";
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashldi3_reg_16"
  [(set (match_operand:DI            0 "pic30_register_operand" "=r")
        (ashift:DI (match_operand:DI 1 "pic30_register_operand" " 0")
                   (match_operand:HI 2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI        3                          "=2"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
      return 
      	      \".set ___BP___,0\n\"
              \".LB%=:\;\"
              \"dec %2,%2\;\"
              \"bra n,.LE%=\;\"
              \"sl %1,%0\;\"
              \"rlc %d1,%d0\;\"
              \"rlc %t1,%t0\;\"
              \"rlc %q1,%q0\;\"
              \"bra .LB%=\n\"
              \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "etc")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Logical Shift Right instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; QImode ;;
;;;;;;;;;;;;

(define_insn "lshrqi3_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"  "=r<>,r<>,R,R")
        (lshiftrt:QI 
          (match_operand:QI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
          (match_operand:HI 2 "pic30_I_operand"      "I,  I,  I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "lsr.b %1,%0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "def,defuse,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*lshrqi3_one_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (lshiftrt:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "lsr.b %1,%0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "def,defuse,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*lshrqi3_sfr0_16"
  [(set (match_operand:QI 0 "pic30_register_operand"               "=a,r")
        (lshiftrt:QI (match_operand:QI 1 "pic30_near_operand" "U,U")
                     (match_operand:HI 2 "pic30_I_operand"    "I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    lsr.b %1,WREG
    mov #%1,%0\;lsr.b [%0],%0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*lshrqi3_sfr1_16"
  [(set (match_operand:QI 0 "pic30_near_operand"          "+U")
        (lshiftrt:QI (match_dup 0)
                     (match_operand:HI 1 "pic30_I_operand" "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "lsr.b %0"
  [
    (set_attr "cc" "math") ; CAW
    (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;
;; HImode ;;
;;;;;;;;;;;;

(define_insn "*lshrhi3_one_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (lshiftrt:HI (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                     (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "lsr %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*lshrhi3_one_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (lshiftrt:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "lsr %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*lshrhi3_sfr0_16"
  [(set (match_operand:HI 0 "pic30_register_operand"               "=a,?r")
        (lshiftrt:HI (match_operand:HI 1 "pic30_data_operand" "U, T")
                     (match_operand:HI 2 "pic30_I_operand"    "I, I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lsr %1,WREG
   mov %1,%0\;lsr %0,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

; leave this match_dup, operand 0 will not require a reload (CAW)
(define_insn "*lshrhi3_sfr1_16"
  [(set (match_operand:HI 0 "pic30_near_operand"          "=U")
        (lshiftrt:HI (match_dup 0)
                     (match_operand:HI 1 "pic30_I_operand" "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "lsr %0"
  [(set_attr "cc" "math")]) ; CAW

(define_insn "lshrhi3_16"
  [(set (match_operand:HI 0 "pic30_register_operand"                "=r,r,r")
        (lshiftrt:HI (match_operand:HI 1 "pic30_register_operand"   "r,r,r")
                     (match_operand:HI 2 "pic30_reg_or_imm_operand" "Kh,i,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    lsr %1,#%2,%0
    clr %0
    lsr %1,%2,%0"
  [
   (set_attr "cc" "math,change0,math")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "lshrp16apsv3_16"
  [(set (match_operand:P16APSV   0 "pic30_register_operand"   "=r,r,r")
        (lshiftrt:P16APSV
          (match_operand:P16APSV 1 "pic30_register_operand"   "r,r,r")
          (match_operand:P16APSV 2 "pic30_reg_or_imm_operand" "Kh,i,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    lsr %1,#%2,%0
    clr %0
    lsr %1,%2,%0"
  [
   (set_attr "cc" "math,change0,math")
   (set_attr "type" "def")
   (set_attr "op_type" "alu,movlit,alu")
  ]
)

;;;;;;;;;;;;
;; SImode ;;
;;;;;;;;;;;;

(define_expand "lshr<mode>3_16"
  [(set (match_operand:GM32BIT   0 "pic30_register_operand"   "")
        (lshiftrt:GM32BIT 
          (match_operand:GM32BIT 1 "pic30_register_operand"   "")
          (match_operand:HI      2 "pic30_reg_or_imm_operand" "")))
  ]
  "(!pic30_isa32_target())"
  "
{
   if (GET_CODE(operands[2]) == CONST_INT) {
     switch (INTVAL(operands[2])) {
       case 0:
         emit_insn(gen_mov<mode>_16(operands[0], operands[1]));
         break;
       case 1:
         emit_insn(gen_lshr<mode>3_imm1_16(operands[0],
                                           operands[1], operands[2]));
         break;
       case 2:
       case 3:
       case 4:
       case 5:
       case 6:
       case 7:
       case 8:
       case 9:
       case 10:
       case 11:
       case 12:
       case 13:
       case 14:
       case 15:
         emit_insn(gen_lshr<mode>3_imm2to15_16(operands[0],
                                               operands[1], operands[2]));
         break;
       case 16:
         emit_insn(gen_lshr<mode>3_imm16plus_16(operands[0],
                                                operands[1], operands[2]));
         break;
       case 17:
       case 18:
       case 19:
       case 20:
       case 21:
       case 22:
       case 23:
       case 24:
       case 25:
       case 26:
       case 27:
       case 28:
       case 29:
       case 30:
       case 31:
         emit_insn(gen_lshr<mode>3_imm16plus_16(operands[0],
                                                operands[1], operands[2]));
         break;
       default:
         emit_insn(gen_mov<mode>_16(operands[0], const0_rtx));
         break;
     }
   } else {
      if (optimize_size) {
        emit_insn(
          gen_lshr<mode>3_reg_Os_16(operands[0],operands[1],operands[2])
        );
      } else {
        emit_insn(
          gen_lshr<mode>3_reg_16(operands[0],operands[1],operands[2])
        );
      }
   }
   DONE;
}")

(define_insn "lshr<mode>3_imm1_16"
  [(set (match_operand:GM32BIT   0 "pic30_register_operand" "=r")
        (lshiftrt:GM32BIT 
          (match_operand:GM32BIT 1 "pic30_register_operand"  "r")
          (match_operand:HI      2 "pic30_I_operand"  "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "lsr %d1,%d0\;rrc %1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "lshr<mode>3_imm16plus_16"
  [(set (match_operand:GM32BIT   0 "pic30_register_operand" "=r")
        (lshiftrt:GM32BIT 
          (match_operand:GM32BIT 1 "pic30_register_operand"  "r")
          (match_operand:HI      2 "pic30_imm16plus_operand" "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
  if (find_regno_note(insn, REG_UNUSED,REGNO(operands[1])+1))
    return \"lsr %d1,#%K2,%0\";
  else
    return \"lsr %d1,#%K2,%0\;mov #0,%d0\";
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "lshr<mode>3_imm2to15_16"
  [(set (match_operand:GM32BIT   0 "pic30_register_operand" "=r")
        (lshiftrt:GM32BIT 
          (match_operand:GM32BIT 1 "pic30_register_operand"  "r")
          (match_operand:HI      2 "pic30_imm2to15_operand"  "i")))
   (clobber (match_scratch:HI    3                         "=&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
      /*
       ** Take care that the source and dest don't overlap
       */
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        return \"sl %d1,#%k2,%3\;\"
               \"lsr %1,#%2,%0\;\"
               \"ior %3,%0,%0\;\"
               \"lsr %d1,#%2,%d0\";
      } else {
        return \"lsr %d1,#%2,%d0\;\"
               \"sl %d1,#%k2,%3\;\"
               \"lsr %1,#%2,%0\;\"
               \"ior %3,%0,%0\";
      }
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "lshr<mode>3_reg_Os_16"
  [(set (match_operand:GM32BIT   0 "pic30_register_operand" "=r")
        (lshiftrt:GM32BIT 
          (match_operand:GM32BIT 1 "pic30_register_operand"  "0")
          (match_operand:HI      2 "pic30_register_operand"  "r")))
   (clobber (match_scratch:HI    3                          "=2"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target() && optimize_size)"
  "*
   {
      return 
      	      \".set ___BP___,0\n\"
              \".LB%=:\;\"
              \"dec %2,%2\;\"
              \"bra n,.LE%=\;\"
              \"lsr %d1,%d0\;\"
              \"rrc %1,%0\;\"
              \"bra .LB%=\n\"
              \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "lshr<mode>3_reg_16"
  [(set (match_operand:GM32BIT   0 "pic30_register_operand" "=&r")
        (lshiftrt:GM32BIT
          (match_operand:GM32BIT 1 "pic30_register_operand" " r")
          (match_operand:HI      2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI    3                         "=&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target() && !optimize_size)"
  "subr %2,#16,%3\;bra nn,.LB%=\;neg %3,%3\;lsr %d1,%3,%0\;clr %d0\;bra .LE%=\n.LB%=:\tsl %d1,%3,%3\;lsr %1,%2,%0\;ior %3,%0,%0\;lsr %d1,%2,%d0\n.LE%=:"
  [
    (set_attr "cc" "clobber")
  ]
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DImode arithmetic shift left.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "lshrdi3_16"
  [(set (match_operand:DI              0 "pic30_register_operand"   "")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand"   "")
                     (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))
  ]
  "(!pic30_isa32_target())"
  "
{
    if (GET_CODE(operands[2]) == CONST_INT) {             
      if (INTVAL(operands[2]) == 0) {
        emit_insn(
          gen_movdi_16(operands[0], operands[1])
        );
      } else if (INTVAL(operands[2]) == 1) {
        emit_insn(
          gen_lshrdi3_imm1_16(operands[0], operands[1], operands[2])
        );
      } else if (INTVAL(operands[2]) >= 2 && INTVAL(operands[2]) <= 63) {
        emit_insn(
          gen_lshrdi3_immn_16(operands[0], operands[1], operands[2])
        );
      } else {
        emit_insn(
          gen_movdi_16(operands[0], const0_rtx)
        );
      }
    } else {
      emit_insn(
        gen_lshrdi3_reg_16(operands[0],operands[1],operands[2])
      );
    }
    DONE;
}")

(define_insn "lshrdi3_imm1_16"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && (INTVAL(operands[2])==1)"
  "lsr %q1,%q0\;rrc %t1,%t0\;rrc %d1,%d0\;rrc %1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "lshrdi3_imm16_16"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && (INTVAL(operands[2])==16)"
  "mov %d1,%0\;mov %t1,%d0\;mul.uu %q1,#1,%t0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "lshrdi3_imm32_16"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && (INTVAL(operands[2])==32)"
  "mov.d %t1,%0\;mul.uu %t0,#0,%t0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "lshrdi3_imm48_16"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && (INTVAL(operands[2])==48)"
  "mul.uu %q1,#1,%0\;mul.uu %t0,#0,%t0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "lshrdi3_immn_16"
  [(set (match_operand:DI 0 "pic30_register_operand"              "=r")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand"       "i")))
   (clobber (match_scratch:HI          3                         "=&r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{ static char buffer[256];
  char *f;
  int results = 0;
  rtx result_reg;
      
  /* how many results do we need?
     if all but the low reg is dead we can shift fewer values */
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0]));
  if (!pic30_dead_or_set_p_with_original(NEXT_INSN(insn), result_reg,
                                         operands[0]) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+1);
  if (!pic30_dead_or_set_p_with_original(NEXT_INSN(insn), result_reg,
                                          operands[0]) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+1; 
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+2);
  if (!pic30_dead_or_set_p_with_original(NEXT_INSN(insn), result_reg,
                                          operands[0]) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+2;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+3);
  if (!pic30_dead_or_set_p_with_original(NEXT_INSN(insn), result_reg,
                                          operands[0]) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+3;

  f = buffer;
  f += sprintf(buffer,\".set ___BP___,0 ; (%ld,%d)\;\", 
               INTVAL(operands[2]), results);
  if (INTVAL(operands[2]) < 16) {
    switch (results) {
      case 4:
        if (!optimize_size) {
          f += sprintf(f,
             \"lsr %%1,#%%2,%%0\;\"
             \"sl %%d1,#%ld,%%3\;\"
             \"ior %%3,%%0,%%0\;\"
             \"lsr %%d1,#%%2,%%d0\;\"
             \"sl %%t1,#%ld,%%3\;\"
             \"ior %%3,%%d0,%%d0\;\"
             \"lsr %%t1,#%%2,%%t0\;\"
             \"sl %%q1,#%ld,%%3\;\"
             \"ior %%3,%%t0,%%t0\;\"
             \"lsr %%q1,#%%2,%%q0\",
             16 - INTVAL(operands[2]), 
             16 - INTVAL(operands[2]), 
             16 - INTVAL(operands[2]));
        } else {;;;;
          f += sprintf(f,
            \"mov #%%2,%%3\;\"
            \".LB%%=:\;\"
            \"lsr %%q1,%%q0\;\"
            \"rrc %%t1,%%t0\;\"
            \"rrc %%d1,%%d0\;\"
            \"rrc %%1,%%0\;\"
            \"dec %%3,%%3\;\"
            \"bra nz,.LB%%=\");
        }
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"lsr %%1,#%%2,%%0\;\"
           \"sl %%d1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%d1,#%%2,%%d0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"lsr %%t1,#%%2,%%t0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%t0,%%t0\",
           16 - INTVAL(operands[2]), 
           16 - INTVAL(operands[2]),
           16 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"lsr %%1,#%%2,%%0\;\"
           \"sl %%d1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%d1,#%%2,%%d0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\",
           16 - INTVAL(operands[2]), 
           16 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
          \"lsr %%1,#%%2,%%0\;\"
          \"sl %%d1,#%ld,%%3\;\"
          \"ior %%3,%%0,%%0\",
           16 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 16) {
    switch (results) {
      case 4: 
      case 3:
        f += sprintf(f,
          \"mov %%d1,%%0\;\"
          \"mov %%t1,%%d0\;\"
          \"mul.uu %%q1,#1,%%t0\");
        break;
      case 2:
        f += sprintf(f,
          \"mov %%d1,%%0\;\"
          \"mov %%t1,%%d0\");
        break;
      case 1:
        f += sprintf(f,
          \"mov %%d1,%%0\");
        break;
     }
     if (((unsigned)(f - buffer)) > 256)
        error(\"Unexpected error during assembly generation\");
     return buffer;
  } else if (INTVAL(operands[2]) < 32) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%t1,#%ld,%%d0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"lsr %%q1,#%ld,%%t0\;\"
           \"clr %%q0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%t1,#%ld,%%d0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"lsr %%q1,#%ld,%%t0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%t1,#%ld,%%d0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 32) {
    switch (results) {
      case 4:
        f += sprintf(f,
          \"mov.d %%t1,%%0\;\"
          \"mul.uu %%t0,#0,%%t0\");
        break;
      case 3:
        f += sprintf(f,
          \"mov %%t1,%%0\;\"
          \"mul.uu %%t0,#0,%%t0\");
        break;
      case 2:
        f += sprintf(f,
          \"mov.d %%t1,%%0\");
        break;
      case 1:
        f += sprintf(f,
          \"mov.w %%t1,%%0\");
        break;
    }
    if (((unsigned)(f - buffer)) > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 48) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%q1,#%ld,%%d0\;\"
           \"mul.uu %%t0,#0,%%t0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%q1,#%ld,%%d0\;\"
           \"clr %%t0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%q1,#%ld,%%d0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 48) {
    switch (results) {
      case 4:
      case 3:
        f += sprintf(f,
          \"mul.uu %%q1,#1,%%0\;\"
          \"mul.uu %%t0,#0,%%t0\");
        break;
      case 2:
        f += sprintf(f,
          \"mul.uu %%q1,#1,%%0\");
        break;
      case 1:
        f += sprintf(f,
          \"mov %%q1,%%0\");
        break;
    }
    if (((unsigned)(f - buffer)) > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 64) {
    f += sprintf(f, \"lsr %%q1,#%ld,%%0\", INTVAL(operands[2])-48);
    switch (results) {
      case 4: 
        f += sprintf(f,
          \"\;mul.uu %%t0,#0,%%t0\;\"
          \"clr %%d0\");
        break;
      case 3:
        f += sprintf(f,
          \"\;clr %%t0\;\"
          \"clr %%d0\"); 
        break;
      case 2:
        f += sprintf(f,
          \"\;clr %%d0\"); 
        break;
    }
    if (((unsigned)(f - buffer)) > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  }
  gcc_assert(0);
  return \"nop\";
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "lshrdi3_reg_16"
  [(set (match_operand:DI 0 "pic30_register_operand"             "=r")
        (lshiftrt:DI (match_operand:DI 1 "pic30_register_operand" "0")
                     (match_operand:HI 2 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 3          "=2"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
      return 
      	      \".set ___BP___,0\n\"
              \".LB%=:\;\"
              \"dec %2,%2\;\"
              \"bra n,.LE%=\;\"
              \"lsr %q1,%q0\;\"
              \"rrc %t1,%t0\;\"
              \"rrc %d1,%d0\;\"
              \"rrc %1,%0\;\"
              \"bra .LB%=\n\"
              \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "etc")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Arithmetic shift right.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; QImode arithmetic shift right.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "ashrqi3I_16"
  [(set (match_operand:QI   0 "pic30_mode2_operand" "=r<>,r<>,R,R")
        (ashiftrt:QI 
          (match_operand:QI 1 "pic30_mode2_operand"  "r,  R<>,r,R<>")
          (match_operand:QI 2 "pic30_I_operand"      "I,  I,  I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "asr.b %1,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "ashrqi3imm_16"
  [(set (match_operand:QI   0 "pic30_register_operand" "=r")
        (ashiftrt:QI 
          (match_operand:QI 1 "pic30_register_operand" " r")
          (match_operand:QI 2 "immediate_operand"      " i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sl.w %1,#8,%0\;asr.w %0,#(%2+8),%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "ashrqi3r_16"
  [(set (match_operand:QI   0 "pic30_register_operand" "=r")
        (ashiftrt:QI 
          (match_operand:QI 1 "pic30_register_operand" " r")
          (match_operand:QI 2 "pic30_register_operand" " r")))
   (clobber 
        (match_scratch:HI   3                          "=r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add.w %2,#8,%3\;sl.w %1,#8,%0\;asr.w %0,%3,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*ashrqi3_one_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (ashiftrt:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:QI 2 "pic30_I_operand"       "I,  I,  I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "asr.b %1,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "def,defuse,use,use")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "*ashrqi3_sfr_16"
  [(set (match_operand:QI 0 "pic30_wreg_or_near_operand"     "=a,U")
        (ashiftrt:QI (match_operand:QI 1 "pic30_near_operand" "U,0")
                     (match_operand:QI 2 "pic30_I_operand"    "I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    asr.b %1,WREG
    asr.b %0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "ashrqi3_16"
  [(set (match_operand:QI   0 "pic30_register_operand"   "=r")
        (ashiftrt:QI
          (match_operand:QI 1 "pic30_register_operand"   " r")
          (match_operand:QI 2 "pic30_reg_or_imm_operand" " ri")))
  ]
  "(!pic30_isa32_target())"
  "
    if (immediate_operand(operands[2],VOIDmode)) {
      if (INTVAL(operands[2]) == 1) {
        emit(
          gen_ashrqi3I_16(operands[0],operands[1],operands[2])
        );
      } else {
        /* cannot support this natively... shift value up 8 and then down
           8+immediate_value, this will give the right answer in two
           instructions */
        emit(
          gen_ashrqi3imm_16(operands[0],operands[1],operands[2])
        );
      }
    } else {
      /* cannot support this natively... shift value up 8 and then down
         8+r, this will give the right answer in three instructions */
      emit(
        gen_ashrqi3r_16(operands[0],operands[1],operands[2])
      );
    }
    DONE;
  "
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; HImode arithmetic shift right.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "*ashrhi3_one_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (ashiftrt:HI (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                     (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "asr %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*ashrhi3_one_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (ashiftrt:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "asr %1,%0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*ashrhi3_sfr_16"
  [(set (match_operand:HI 0 "pic30_wreg_or_near_operand"     "=a,U")
        (ashiftrt:HI (match_operand:HI 1 "pic30_near_operand" "U,0")
                     (match_operand:HI 2 "pic30_I_operand"    "I,I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    asr %1,WREG
    asr %0"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashrhi3_16"
  [(set (match_operand:HI 0 "pic30_register_operand"                "=r,r,r")
        (ashiftrt:HI (match_operand:HI 1 "pic30_register_operand"   "r,r,r")
                     (match_operand:HI 2 "pic30_reg_or_imm_operand" "Kh,i,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     switch (which_alternative) {
       case 0: return \"asr %1,#%2,%0\";
       case 1: if (INTVAL(operands[2]) < 0)
                 return \"sl %1,#%J2%%16,%0\";
               else return \"asr %1,#%2%%16,%0\";
       case 2: return \"asr %1,%2,%0\";
       default: gcc_assert(0);
     }
   }"
  [
   (set_attr "cc" "math") ; CAW
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashrp16apsv3_16"
  [(set (match_operand:P16APSV   0 "pic30_register_operand"   "=r,r,r")
        (ashiftrt:P16APSV 
          (match_operand:P16APSV 1 "pic30_register_operand"   "r,r,r")
          (match_operand:P16APSV 2 "pic30_reg_or_imm_operand" "Kh,i,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     switch (which_alternative) {
       case 0: return \"asr %1,#%2,%0\";
       case 1: if (INTVAL(operands[2]) < 0)
                 return \"sl %1,#%J2%%16,%0\";
               else return \"asr %1,#%2%%16,%0\";
       case 2: return \"asr %1,%2,%0\";
       default: gcc_assert(0);
     }
   }"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashrsihi3_16"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (unspec:SI [
           (match_operand:SI  1 "pic30_register_operand" " 0,r")
           (match_operand:HI  2 "pic30_register_operand" " r,r")
        ] UNSPEC_ASHIFTSIHI))
   (clobber (match_scratch:HI 3                         "=&r,r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "@
   subr %2,#16,%3\;sl %d1,%3,%3\;asr %d1,%2,%d0\;lsr %1,%2,%0\;ior %0,%3,%0
   subr %2,#16,%3\;lsr %1,%2,%0\;sl %d1,%3,%3\;ior %0,%3,%0\;asr %d1,%2,%d0"
  [
   (set_attr "cc" "clobber")
  ]
)


(define_insn "lshrsihi3_16"
  [(set (match_operand:SI     0 "pic30_register_operand" "=r,r")
        (unspec:SI [
           (match_operand:SI  1 "pic30_register_operand" " 0,r")
           (match_operand:HI  2 "pic30_register_operand" " r,r")
        ] UNSPEC_LSHIFTSIHI))
   (clobber (match_scratch:HI 3                         "=&r,r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  ""
  "@
   subr %2,#16,%3\;sl %d1,%3,%3\;lsr %d1,%2,%d0\;lsr %1,%2,%0\;ior %0,%3,%0
   subr %2,#16,%3\;lsr %1,%2,%0\;sl %d1,%3,%3\;ior %0,%3,%0\;lsr %d1,%2,%d0"
  [
   (set_attr "cc" "clobber")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SImode arithmetic shift right.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "ashrsi3_16"
  [(set (match_operand:SI 0 "pic30_register_operand"              "")
        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand"  "")
                     (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0: emit_insn(
                  gen_movsi_16(operands[0], operands[1])
                );
                break;
        case 1: emit_insn(
                  gen_ashrsi3_imm1_16(operands[0], operands[1], operands[2])
                );
                break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
               emit_insn(
                 gen_ashrsi3_imm2to15_low_16(
                   simplify_gen_subreg(HImode, operands[0], SImode, 0), 
                   operands[1], operands[2])
               );
               emit_insn(
                 gen_ashrhi3_16(
                   simplify_gen_subreg(HImode, operands[0], SImode, 2), 
                   simplify_gen_subreg(HImode, operands[1], SImode, 2),
                   operands[2])
               );
               break;
        case 16: 
               emit_insn(
                  gen_ashrsi3_imm16plus_16(operands[0],operands[1], operands[2])
               );
               break;
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
               emit_insn(
                 gen_ashrsi3_imm16plus_16(operands[0], operands[1], operands[2])
               );
               break;
        default:
                emit_insn(
                  gen_movsi_16(operands[0], const0_rtx)
                );
                break;
      }
    } else {
      if (optimize_size) {
        emit_insn(
          gen_ashrsi3_reg_Os_16(operands[0],operands[1],operands[2])
        );
      } else {
        emit_insn(
          gen_ashrsi3_reg_16(operands[0],operands[1],operands[2])
        );
      }
    }
    DONE;
  }"
)

(define_insn "ashrsi3_imm1_16"
  [(set (match_operand:SI 0 "pic30_register_operand"             "=r")
        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand" "r")
                     (match_operand:HI 2 "pic30_I_operand"  "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "asr %d1,%d0\;rrc %1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashrsi3_imm2to15_low_16"
  [(set (match_operand:HI 0            "pic30_register_operand"        "=r")
        (unspec:HI [
          (match_operand:SI 1 "pic30_register_operand"                  "r")
          (match_operand:HI 2 "pic30_imm2to15_operand"                  "i")
        ] UNSPEC_ASHIFTSI_LOW))
   (clobber (match_scratch:HI 3                                       "=&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     return \"sl %d1,#%k2,%3\;\"
            \"lsr %1,#%2,%0\;\"
            \"ior %3,%0,%0\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "ashrsi3_imm16plus_16"
  [(set (match_operand:SI 0            "pic30_register_operand"         "=r")
        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand"        "r")
                     (match_operand:HI 2 "pic30_imm16plus_operand" "i")))
  ]
  "(!pic30_isa32_target())"
  "{
     emit_insn(
       gen_ashrhi3_16(simplify_gen_subreg(HImode, operands[0], SImode, 0),
                   simplify_gen_subreg(HImode, operands[1], SImode, 2),
                   GEN_INT(INTVAL(operands[2])-16))
     );
     emit_insn(
       gen_ashrhi3_16(simplify_gen_subreg(HImode, operands[0], SImode, 2),
                   simplify_gen_subreg(HImode, operands[1], SImode, 2),
                   GEN_INT(15))
     );
     DONE;
   }
  "
)

(define_insn "ashrsi3_reg_Os_16"
  [(set (match_operand:SI 0 "pic30_register_operand"             "=r")
        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand" "0")
                     (match_operand:HI 2 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI          3                         "=2"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target() && optimize_size)"
  "*
   {
     return 
      	      \".set ___BP___,0\n\"
              \".LB%=:\;\"
              \"dec %2,%2\;\"
              \"bra n,.LE%=\;\"
              \"asr %d1,%d0\;\"
              \"rrc %1,%0\;\"
              \"bra .LB%=\n\"
              \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashrsi3_reg_16"
  [(set (match_operand:SI 0 "pic30_register_operand"             "=&r")
        (ashiftrt:SI (match_operand:SI 1 "pic30_register_operand" " r")
                     (match_operand:HI 2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI 3                                  "=&r"))]
  "(!pic30_isa32_target() && !optimize_size)"
  "subr %2,#16,%3\;bra nn,.LB%=\;neg %3,%3\;asr %d1,%3,%0\;asr %d1,#15,%d0\;bra .LE%=\n.LB%=:\tsl %d1,%3,%3\;lsr %1,%2,%0\;ior %3,%0,%0\;asr %d1,%2,%d0\n.LE%=:"
  [
    (set_attr "cc" "clobber")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DImode arithmetic shift right.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "ashrdi3_16"
  [(set (match_operand:DI 0 "pic30_register_operand"              "")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "")
                     (match_operand:HI 2 "pic30_reg_or_imm_operand" "")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    if (GET_CODE(operands[2]) == CONST_INT) {
      if (INTVAL(operands[2]) == 0) {
        emit_insn(
          gen_movdi_16(operands[0], operands[1])
        );
      } else if (INTVAL(operands[2]) == 1) {
	emit_insn(
          gen_ashrdi3_imm1_16(operands[0], operands[1], operands[2])
        );
      } else if (INTVAL(operands[2]) >= 2 && INTVAL(operands[2]) <= 63) {
        emit_insn(
          gen_ashrdi3_immn_16(operands[0], operands[1], operands[2])
        );
      } else {
        emit_insn(
          gen_movdi_16(operands[0], const0_rtx)
        );
      }
    } else {
      emit_insn(
        gen_ashrdi3_reg_16(operands[0],operands[1],operands[2])
      );
    }
    DONE;
  }"
)

(define_insn "ashrdi3_imm1_16"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && (INTVAL(operands[2])==1)"
  "asr %q1,%q0\;rrc %t1,%t0\;rrc %d1,%d0\;rrc %1,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashrdi3_imm16_16"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))
  ]
  "(!pic30_isa32_target()) && (INTVAL(operands[2])==16)"
  "mov %d1,%0\;mov %t1,%d0\;mul.su %q1,#1,%t0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashrdi3_imm32_16"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && (INTVAL(operands[2])==32)"
  "mov.d %t1,%0\;asr %d0,#15,%t0\;mov %t0,%q0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashrdi3_imm48_16"
  [(set (match_operand:DI 0            "pic30_register_operand"   "=r")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "r")
                     (match_operand:HI 2 "immediate_operand" "i")))
  ]
  "(!pic30_isa32_target()) && (INTVAL(operands[2])==48)"
  "mul.su %q1,#1,%0\;mul.su %d0,#1,%t0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashrdi3_immn_16"
  [(set (match_operand:DI 0 "pic30_register_operand"              "=r")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand"  "0")
                     (match_operand:HI 2 "immediate_operand" "i")))
		     (clobber (match_scratch:HI 3           "=&r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{ static char buffer[256];
  char *f;
  int results = 0;
  rtx result_reg;
      
  /* how many results do we need?
     if all but the low reg is dead we can shift fewer values */
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0]));
  if (!pic30_dead_or_set_p_with_original(NEXT_INSN(insn), result_reg,
                                         operands[0]) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+1);
  if (!pic30_dead_or_set_p_with_original(NEXT_INSN(insn), result_reg,
                                          operands[0]) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+1; 
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+2);
  if (!pic30_dead_or_set_p_with_original(NEXT_INSN(insn), result_reg,
                                          operands[0]) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+2;
  result_reg = gen_rtx_REG(HImode, REGNO(operands[0])+3);
  if (!pic30_dead_or_set_p_with_original(NEXT_INSN(insn), result_reg,
                                          operands[0]) &&
      !find_regno_note(insn, REG_UNUSED, REGNO(result_reg)))
    results = 1+3;


  f = buffer;
  f += sprintf(buffer,\".set ___BP___,0 ; (%ld,%d)\;\", 
               INTVAL(operands[2]), results);
  if (INTVAL(operands[2]) < 16) {
    switch (results) {
      case 4:
        if (!optimize_size) {
          f += sprintf(f,
             \"lsr %%1,#%%2,%%0\;\"
             \"sl %%d1,#%ld,%%3\;\"
             \"ior %%3,%%0,%%0\;\"
             \"lsr %%d1,#%%2,%%d0\;\"
             \"sl %%t1,#%ld,%%3\;\"
             \"ior %%3,%%d0,%%d0\;\"
             \"lsr %%t1,#%%2,%%t0\;\"
             \"sl %%q1,#%ld,%%3\;\"
             \"ior %%3,%%t0,%%t0\;\"
             \"asr %%q1,#%%2,%%q0\",
             16 - INTVAL(operands[2]), 
             16 - INTVAL(operands[2]), 
             16 - INTVAL(operands[2]));
        } else {
          f += sprintf(f,
            \"mov #%%2,%%3\;\"
            \".LB%%=:\;\"
            \"asr %%q1,%%q0\;\"
            \"rrc %%t1,%%t0\;\"
            \"rrc %%d1,%%d0\;\"
            \"rrc %%1,%%0\;\"
            \"dec %%3,%%3\;\"
            \"bra nz,.LB%%=\");
        }
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"lsr %%1,#%%2,%%0\;\"
           \"sl %%d1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%d1,#%%2,%%d0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"lsr %%t1,#%%2,%%t0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%t0,%%t0\",
           16 - INTVAL(operands[2]), 
           16 - INTVAL(operands[2]), 
           16 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"lsr %%1,#%%2,%%0\;\"
           \"sl %%d1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%d1,#%%2,%%d0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\",
           16 - INTVAL(operands[2]), 
           16 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
          \"lsr %%1,#%%2,%%0\;\"
          \"sl %%d1,#%ld,%%3\;\"
          \"ior %%3,%%0, %%0\;\",
           16 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 16) {
    switch (results) {
      case 4:
      case 3:
        f += sprintf(f,
          \"mov %%d1,%%0\;\"
          \"mov %%t1,%%d0\;\"
          \"mul.su %%q1,#1,%%t0\");
        break;
      case 2:
        f += sprintf(f,
          \"mov %%d1,%%0\;\"
          \"mov %%t1,%%d0\");
        break;
      case 1:
        f += sprintf(f,
          \"mov %%d1,%%0\");
        break;
     }
     if (((unsigned)(f - buffer)) > 256)
        error(\"Unexpected error during assembly generation\");
     return buffer;
  } else if (INTVAL(operands[2]) < 32) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%t1,#%ld,%%d0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"asr %%q1,#%ld,%%t0\;\"
           \"asr %%q1,#15,%%q0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%t1,#%ld,%%d0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\"
           \"asr %%q1,#%ld,%%t0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"lsr %%t1,#%ld,%%d0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%d0,%%d0\;\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
           \"lsr %%d1,#%ld,%%0\;\"
           \"sl %%t1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\",
           INTVAL(operands[2]) - 16,
           32 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 32) {
    switch (results) {
      case 4:
        f += sprintf(f,
          \"mov.d %%t1,%%0\;\"
          \"asr %%t1,#15,%%t0\;\"
          \"asr %%t1,#15,%%q0\");
        break;
      case 3:
        f += sprintf(f,
          \"mov %%t1,%%0\;\"
          \"asr %%t1,#15,%%t0\");
        break;
      case 2:
        f += sprintf(f,
          \"mov.d %%t1,%%0\");
        break;
      case 1:
        f += sprintf(f,
          \"mov.w %%t1,%%0\");
        break;
    }
    if (((unsigned)(f - buffer)) > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 48) {
    switch (results) {
      case 4:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"asr %%q1,#%ld,%%d0\;\"
           \"asr %%q1,#15,%%t0\;\"
           \"asr %%q1,#15,%%q0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 3:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"asr %%q1,#%ld,%%d0\;\"
           \"asr %%q1,#15,%%t0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 2:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\;\"
           \"asr %%q1,#%ld,%%d0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]),
           INTVAL(operands[2]) - 32);
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
      case 1:
        f += sprintf(f,
           \"lsr %%t1,#%ld,%%0\;\"
           \"sl %%q1,#%ld,%%3\;\"
           \"ior %%3,%%0,%%0\",
           INTVAL(operands[2]) - 32,
           48 - INTVAL(operands[2]));
        if (((unsigned)(f - buffer)) > 256)
          error(\"Unexpected error during assembly generation\");
        return buffer;
    }
  } else if (INTVAL(operands[2]) == 48) {
    switch (results) {
      case 4:
        f += sprintf(f,
          \"mul.su %%q1,#1,%%0\;\"
          \"asr %%q1,#15,%%t0\;\"
          \"asr %%q1,#15,%%q0\");
        break;
      case 3:
        f += sprintf(f,
          \"mul.su %%q1,#1,%%0\;\"
          \"asr %%q1,#15,%%t0\");
        break;
      case 2:
        f += sprintf(f,
          \"mul.su %%q1,#1,%%0\");
        break;
      case 1:
        f += sprintf(f,
          \"mov %%q1,%%0\");
        break;
    }
    if (((unsigned)(f - buffer)) > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  } else if (INTVAL(operands[2]) < 64) {
    f += sprintf(f, \"asr %%q1,#%ld,%%0\", INTVAL(operands[2])-48);
    switch (results) {
      case 4: 
        f += sprintf(f,
          \"\;asr %%q1,#15,%%d0\;\"
          \"asr %%q1,#15,%%t0\;\"
          \"asr %%q1,#15,%%q0\;\");
        break;
      case 3:
        f += sprintf(f,
          \"\;asr %%q1,#15,%%d0\;\"
          \"asr %%q1,#15,%%t0\;\");
        break;
      case 2:
        f += sprintf(f,
          \"\;asr %%q1,#15,%%d0\;\");
        break;
    }
    if (((unsigned)(f - buffer)) > 256)
      error(\"Unexpected error during assembly generation\");
    return buffer;
  }
  gcc_assert(0);
  return \"nop\";
}"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "ashrdi3_reg_16"
  [(set (match_operand:DI 0 "pic30_register_operand"             "=r")
        (ashiftrt:DI (match_operand:DI 1 "pic30_register_operand" "0")
                     (match_operand:HI 2 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI          3                         "=2"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
      return 
      	      \".set ___BP___,0\n\"
              \".LB%=:\;\"
              \"dec %2,%2\;\"
              \"bra n,.LE%=\;\"
              \"asr %q1,%q0\;\"
              \"rrc %t1,%t0\;\"
              \"rrc %d1,%d0\;\"
              \"rrc %1,%0\;\"
              \"bra .LB%=\n\"
              \".LE%=:\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; rotate instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; rotate left
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; QImode ;;
;;;;;;;;;;;;

(define_insn "rotlqi_one_DATA_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (rotate:QI 
           (match_operand:QI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
           (const_int 1)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "rlnc.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "rotlqi_one_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (rotate:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (const_int 1)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "rlnc.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*rotlqi3_sfr_16"
  [(set (match_operand:QI 0 "pic30_wreg_or_near_operand"   "=a,U")
        (rotate:QI (match_operand:QI 1 "pic30_near_operand" "U,0")
                   (match_operand:QI 2 "pic30_I_operand"    "I,I")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    rlnc.b %1,WREG
    rlnc.b %1"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "rotlqi3_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=rR<>")
        (rotate:QI
          (match_operand:QI 1 "pic30_mode2_APSV_operand" "rR<>")
          (match_operand:QI 2 "immediate_operand" "i")))
  ]
  ""
  "
{  if (INTVAL(operands[2]) == 1) {
     if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
       emit_insn(gen_rotlqi_one_DATA_16(operands[0], operands[1]));
     else
       emit_insn(gen_rotlqi_one_APSV_16(operands[0], operands[1]));
     DONE;
   } else FAIL;
}")

;;;;;;;;;;;;
;; HImode ;;
;;;;;;;;;;;;

(define_insn "*rotlhi3_one_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (rotate:HI (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                   (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "rlnc %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*rotlhi3_one_APSV_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"           "=r<>,r<>,R,R")
        (rotate:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "rlnc %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*rotlhi3_sfr_16"
  [(set (match_operand:HI 0 "pic30_wreg_or_near_operand"   "=a,U")
        (rotate:HI (match_operand:HI 1 "pic30_near_operand" "U,0")
                   (match_operand:HI 2 "pic30_I_operand"    "I,I")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    rlnc %1,WREG
    rlnc %1"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,etc")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; rotate right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;
;; QImode ;;
;;;;;;;;;;;;

(define_insn "rotrqi_one_DATA_16"
  [(set (match_operand:QI   0 "pic30_mode2_operand" "=r<>,r<>,R,R")
        (rotatert:QI 
           (match_operand:QI 1 "pic30_mode2_operand"  "r,  R<>,r,R<>")
           (const_int 1)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "rrnc.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "rotrqi_one_APSV_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (rotatert:QI 
           (match_operand:QI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (const_int 1)))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "rrnc.b %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*rotrqi3_sfr_16"
  [(set (match_operand:QI              0 "pic30_wreg_or_near_operand" "=a,U")
        (rotatert:QI (match_operand:QI 1 "pic30_near_operand"          "U,0")
                     (match_operand:QI 2 "pic30_I_operand"             "I,I")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    rrnc.b %1,WREG
    rrnc.b %1"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,etc")
   (set_attr "op_type" "alu")
  ]
)

(define_expand "rotrqi3_16"
  [(set (match_operand:QI 0 "pic30_mode2_operand" "=rR<>")
        (rotatert:QI 
          (match_operand:QI 1 "pic30_mode2_APSV_operand" "rR<>")
          (match_operand:QI 2 "immediate_operand" "i")))
  ]
  ""
  "
{  if (INTVAL(operands[2]) == 1) {
     if (pic30_mode2_operand(operands[1],GET_MODE(operands[1])))
       emit_insn(gen_rotrqi_one_DATA_16(operands[0], operands[1]));
     else
       emit_insn(gen_rotrqi_one_APSV_16(operands[0], operands[1]));
     DONE;
   } else FAIL;
}")

;;;;;;;;;;;;
;; HImode ;;
;;;;;;;;;;;;

(define_insn "*rotrhi3_one_DATA_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (rotatert:HI (match_operand:HI 1 "pic30_mode2_operand" "r,  R<>,r,R<>")
                     (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "rrnc %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*rotrhi3_one_16"
  [(set (match_operand:HI 0 "pic30_mode2_operand"             "=r<>,r<>,R,R")
        (rotatert:HI 
           (match_operand:HI 1 "pic30_mode2_APSV_operand" "r,  R<>,r,R<>")
           (match_operand:HI 2 "pic30_I_operand"     "I,  I,  I,I")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "rrnc %1,%0"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,defuse,use,use")
   (set_attr "op_type" "alu")
  ]
)

(define_insn "*rotrhi3_sfr_16"
  [(set (match_operand:HI 0 "pic30_wreg_or_near_operand"     "=a,U")
        (rotatert:HI (match_operand:HI 1 "pic30_near_operand" "U,0")
                   (match_operand:HI 2 "pic30_I_operand"      "I,I")))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
    rrnc %1,WREG
    rrnc %1"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def,etc")
   (set_attr "op_type" "alu")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Special cases of bit-field insns which we should
;; recognize in preference to the general case.
;; These handle aligned 8-bit and 16-bit fields,
;; which can usually be done with move instructions.
;    dsPIC30: t.b.d.
;********************

;; Bit field instructions, general cases.
;; "o,d" constraint causes a nonoffsettable memref to match the "o"
;; so that its address is reloaded.

(define_insn "bfins_16"
  [(set (zero_extract:HI    
          (match_operand:HI 0 "pic30_mode2_or_near_operand" "+U, Rr,Rr,U")
          (match_operand:HI 1 "immediate_operand"           " i, i, i, i")
          (match_operand:HI 2 "immediate_operand"           " i, i, i, i"))
        (match_operand:HI 3 "pic30_reg_or_lit8"             " r, r, i, ???i"))
   (clobber (match_scratch:HI 4                             "=X, X, X, r"))
  ]
  "(pic30_isav4_target())"
  "*
{
  switch (which_alternative)
  {
    case 1: return \"bfins #%2,#%1,%3,%0\";
    case 2: return \"bfins #%2,#%1,#%3,%0\";
    case 3:
    case 0:  { /* U, i, i, r */
      /* Check to see if it is near+offset */
      if (GET_CODE(XEXP(operands[0],0)) == CONST) {
        if(GET_CODE(XEXP(XEXP(operands[0],0),0)) == PLUS) {
          int offset;
          offset = INTVAL(XEXP(XEXP(XEXP(operands[0],0),0),1));
          if (offset & 1) {
            if (which_alternative == 3) {
              return \"mov #%3,%4\;bfins #%2+8,#%1,%4,%0-1\";
            } else {
              return \"bfins #%2+8,#%1,%3,%0-1\";
            }
          } else {
            if (which_alternative == 3) {
              return \"mov #%3,%4\;bfins #%2,#%1,%4,%0\";
            } else {
              return \"bfins #%2,#%1,%3,%0\";
            }
          }
        } else {
          gcc_assert(0);
        }
      } else {
        return \"bfins #%2,#%1,%3,%0\";
      }
    }
    default:
      gcc_assert(0);
  }
}"
)

;; (define_insn "extv_16" ...

;; (define_insn "extzv_16" ...
(define_insn "bfext_16"
  [(set (match_operand:HI   0 "pic30_register_operand"      "=r,r")
        (zero_extract:HI  
          (match_operand:HI 1 "pic30_mode2_or_near_operand" "Rr,U")
          (match_operand:HI 2 "immediate_operand"           " i,i")
          (match_operand:HI 3 "immediate_operand"           " i,i")))]
  "(pic30_isav4_target())"
  "*
{
  switch(which_alternative)
  {
    case 0:  return \"bfext #%3,#%2,%1,%0\";
    case 1:  {
      /* Check to see if the near operand has an offset */
      if (GET_CODE(XEXP(operands[1],0)) == CONST) {
        if(GET_CODE(XEXP(XEXP(operands[1],0),0)) == PLUS) {
          int offset;
          offset = INTVAL(XEXP(XEXP(XEXP(operands[1],0),0),1));
          if (offset & 1) {
            return \"bfext #%3+8,#%2,%1-1,%0\";
          } else {
            return \"bfext #%3,#%2,%1,%0\";
          }
        }
      } else {
        return \"bfext #%3,#%2,%1,%0\";
      }
    }
    default:
      gcc_assert(0);
  }
}"
)
(define_expand "extzv_16"
  [(set (match_operand:HI      0 "pic30_register_operand"      "=r")
        (zero_extract:HI  
          (match_operand    1 "pic30_mode2_or_near_operand" "RrU")
          (match_operand:HI 2 "immediate_operand"           " i")
          (match_operand:HI 3 "immediate_operand"           " i")))]
  "(!pic30_isa32_target())"
  "
  { 
    if (pic30_isav4_target() &&
        pic30_mode2_or_near_operand(operands[1],VOIDmode) &&
        GET_MODE(operands[1]) == HImode) {
      emit(
        gen_bfext_16(operands[0], operands[1], operands[2], operands[3])
      );
      DONE;
    } else {
      FAIL;
    }
  }"
)

;; (define_insn "insv_16" ...

(define_expand "insv_16"
  [(set (zero_extract:HI
          (match_operand    0 "pic30_mode2_or_near_operand" "+RrU")
          (match_operand:HI 1 "immediate_operand"           "i")
          (match_operand:HI 2 "immediate_operand"           "i"))
        (match_operand:HI 3 "immediate_operand"             "i"))]
  "(!pic30_isa32_target())"
  "
{ int n;
  enum machine_mode mode;
  if (pic30_isav4_target() &&
      (pic30_register_operand(operands[0], VOIDmode) ||
       pic30_mode2_or_near_operand(operands[0], HImode)) &&
      (INTVAL(operands[1]) > 1) &&
      pic30_reg_or_lit8(operands[3], VOIDmode) &&
      (INTVAL(operands[1])+INTVAL(operands[2])<17)
     ) {
    rtx op0 = operands[0];

    if (!pic30_mode2_or_near_operand(op0,VOIDmode)) {
      op0 = force_reg(GET_MODE(op0),op0);
    }
    emit(
      gen_bfins_16(op0,operands[1],operands[2],operands[3])
    );
    if (op0 != operands[0]) {
      emit_move_insn(operands[0], op0);
    }
    DONE;
  }

  n = 4;
  mode = GET_MODE(operands[0]);
  if (pic30_volatile_operand(operands[0], mode)) n = 1;
  if ((INTVAL(operands[1]) <= n) && (GET_CODE(operands[3]) == CONST_INT) &&
      /* pic30_reg_or_near_operand is already called, but if optimization is
         on, constant addresses are forced into a register so that 'cse can
         get a chance to see them' (in fn memory_address)... thats okay, cse
         will turn them back to constants we hope */
      (pic30_reg_or_near_operand(operands[0],VOIDmode)) &&
      ((mode == HImode) || (mode == QImode)))
  {  int mask;
     rtx mask_rtx;
     int i;
     rtx modifybit = operands[0];

     /* actually operand [3] does not necessarily fit into our bitfield...
        *SIGH* */

     for (i = 0; i < INTVAL(operands[1]); i++) {
       mask =  (1 << (INTVAL(operands[2]) +i));
       if ((INTVAL(operands[3]) & (1 << i)) == 0) {
          if (pic30_mode2_operand(operands[0],VOIDmode)) {
            mask_rtx = gen_rtx_CONST_INT(HImode, ~mask);
            emit(
              gen_bitclrhi_16(operands[0], operands[0], mask_rtx)
            );
          } else {
            if (mode == HImode) {
              mask_rtx = gen_rtx_CONST_INT(HImode, ~mask);
              emit(
                gen_bitclrhi_sfr_16(operands[0], mask_rtx)
              );
            } else if (mode == QImode) {
              if (mask > 0x80) {
                FAIL;
                break;
              }
              mask_rtx = gen_rtx_CONST_INT(HImode, ~mask);
              emit(
                gen_bitclrqi_sfr_16(modifybit, mask_rtx)
              );
            }
          }
       } else {
          if (pic30_mode2_operand(operands[0],VOIDmode)) {
            mask_rtx = gen_rtx_CONST_INT(HImode, mask);
            emit(
              gen_bitsethi_16(operands[0], operands[0], mask_rtx)
            );
          } else {
            if (mode == HImode) {
              mask_rtx = gen_rtx_CONST_INT(HImode, mask);
              emit(
                gen_bitsethi_sfr_16(operands[0], mask_rtx)
              );
            } else {
              if (mask > 0x80) {
                FAIL;
                break;
              }
              mask_rtx = gen_rtx_CONST_INT(HImode, mask);
              emit(
                gen_bitsetqi_sfr_16(modifybit, mask_rtx)
              );
            }
          }
       }
     }
     DONE;
  }
  else FAIL;
}"
)

;; Now recognize bit field insns that operate on registers
;; (or at least were intended to do so).
;[unnamed only]

;; Special patterns for optimizing bit-field instructions.
;**************************************

; cc status test ops n.a. on dsPIC30 ......... e.g. "sleu" on 68k:
;  [(set (match_operand:QI 0 "pic30_general_operand" "=d")
;        (leu (cc0) (const_int 0)))]
;  ""
;  "* cc_status = cc_prev_status;
;     return \"sls %0\"; ")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Basic conditional jump instructions.
;; Every machine description must have a named pattern for each of the
;; conditional branch names "bcond"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "beq_16"
  [(set (pc)
        (if_then_else (eq (reg:CC CC_REG)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  "(!pic30_isa32_target())"
  "* return pic30_conditional_branch(EQ, operands[0],0,0);"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "bne_16"
  [(set (pc)
        (if_then_else (ne (reg:CC CC_REG)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  "(!pic30_isa32_target())"
  "* return pic30_conditional_branch(NE, operands[0],0,0);"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "bgt_16"
  [(set (pc)
        (if_then_else (gt (reg:CC CC_REG)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  "(!pic30_isa32_target())"
  "* return pic30_conditional_branch(GT, operands[0],0,0);"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "blt_16"
  [(set (pc)
        (if_then_else (lt (reg:CC CC_REG)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  "(!pic30_isa32_target())"
  "* return pic30_conditional_branch(LT, operands[0],0,0);"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "bge_16"
  [(set (pc)
        (if_then_else (ge (reg:CC CC_REG)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  "(!pic30_isa32_target())"
  "* return pic30_conditional_branch(GE, operands[0],0,0);"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "ble_16"
  [(set (pc)
        (if_then_else (le (reg:CC CC_REG)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  "(!pic30_isa32_target())"
  "* return pic30_conditional_branch(LE, operands[0],0,0);"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)


; unsigned branches:

(define_insn "bgtu_16"
  [(set (pc)
        (if_then_else (gtu (reg:CC CC_REG)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  "(!pic30_isa32_target())"
  "* return pic30_conditional_branch(GTU, operands[0],0,0);"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "bltu_16"
  [(set (pc)
        (if_then_else (ltu (reg:CC CC_REG)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  "(!pic30_isa32_target())"
  "* return pic30_conditional_branch(LTU, operands[0],0,0);"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "bgeu_16"
  [(set (pc)
        (if_then_else (geu (reg:CC CC_REG)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  "(!pic30_isa32_target())"
  "* return pic30_conditional_branch(GEU, operands[0],0,0);"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "bleu_16"
  [(set (pc)
        (if_then_else (leu (reg:CC CC_REG)
                          (const_int 0))
                      (label_ref (match_operand 0 "" ""))
                      (pc)))]
  "(!pic30_isa32_target())"
  "* return pic30_conditional_branch(LEU, operands[0],0,0);"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Every machine description must have an anonymous pattern for each of
;; the possible reverse-conditional branches.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "*bccreverse_16"
  [(set (pc)
        (if_then_else (match_operator 1 "comparison_operator" 
			[(reg:CC CC_REG) (const_int 0)])
                      (pc)
                      (label_ref (match_operand 0 "" ""))))]
  "(!pic30_isa32_target())"
  "*
   {
     return pic30_conditional_branch(
		reverse_condition(GET_CODE(operands[1])), operands[0],0,0);
   }"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; An instruction to jump to an address which is operand zero.
;; This pattern name is mandatory on all machines.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "indirect_jump_16"
 [(set (pc) 
       (match_operand:HI 0 "pic30_register_operand" "r"))
 ]
 "(!pic30_isa32_target())"
 "goto %0"
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Instruction to jump to a variable address. This is a low-level capability
;; which can be used to implement a dispatch table when there is no 'casesi'
;; pattern. This pattern requires two operands: the address or offset, and a
;; label which should immediately precede the jump table. If the macro
;; CASE_VECTOR_PC_RELATIVE evaluates to a nonzero value then the first operand
;; is an offset which counts from the address of the table; otherwise, it is
;; an absolute address to jump to. In either case, the first operand has mode
;; Pmode. The 'tablejump' insn is always the last insn before the jump table
;; it uses. Its assembler code normally has no need to use the second operand,
;; but you should incorporate it in the RTL pattern so that the jump optimizer
;; will not delete the table as unreachable code.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define_insn "tablejump_16"
  [(set (pc) (match_operand:HI 0 "pic30_register_operand" "r"))
   (use (label_ref (match_operand 1 "" "")))]
  "(!pic30_isa32_target())"
  "bra %0")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Subroutines of "casesi".
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Operand 0 is index
;; operand 1 is the minimum bound
;; operand 2 is the maximum bound - minimum bound + 1
;; operand 3 is CODE_LABEL for the table;
;; operand 4 is the CODE_LABEL to go to if index out of range.

(define_expand "casesi_16"
  [(match_operand:SI 0 "pic30_general_operand" "")
   (match_operand:SI 1 "immediate_operand" "")
   (match_operand:SI 2 "immediate_operand" "")
   (match_operand 3 "" "")
   (match_operand 4 "" "")]
  "(!pic30_isa32_target())"
  "
{
  if (INTVAL(operands[2]) >= 32767) {
    error(\"Too many case statements in switch table\");
    FAIL;
  }
  if (operands[1] != const0_rtx) {
    rtx reg = gen_reg_rtx(SImode);

    operands[1] = GEN_INT(-INTVAL(operands[1]));
    operands[1] = force_reg(SImode, operands[1]);
    emit_insn(gen_addsi3_16(reg, operands[0], operands[1]));
    operands[0] = reg;
  }
  operands[0] = force_reg(SImode, operands[0]);
  operands[2] = force_reg(SImode, operands[2]);
  emit_insn(gen_cmpsi_16(operands[0], operands[2]));
  emit_jump_insn(gen_bgtu_16(operands[4]));
  emit_jump_insn(gen_casesi0_16(operands[0], operands[3]));
  DONE;
}")

(define_insn "casesi0_16"
  [(set (pc) (plus:SI
     (mem:SI (plus:SI (pc)
               (match_operand:SI 0 "pic30_mode2_operand" "r,R")))
     (label_ref (match_operand 1 "" ""))))
     (clobber (match_scratch:HI 2  "=X,r"))
     (clobber (match_dup 0))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   { static char buffer[128];

     /*
     ** See if there is anything between us and the jump table
     ** If we could be sure there never was, then the 'clobber'
     ** of operand[0] could be removed.
     */
     rtx_insn *p;
     int fDisjoint = FALSE;
     int table_lable_ladle = CODE_LABEL_NUMBER(operands[1]);
     for (p = NEXT_INSN (insn); 
          p != (as_a <rtx_insn *> (operands[1])); 
          p = NEXT_INSN (p)) {
       if (INSN_P(p)) {
         fDisjoint = TRUE;
         break;
       }
     }
     if (fDisjoint) {
       if (which_alternative == 0) {
         sprintf(buffer,\"add #(%%1-$)/4,%%0\n\"
                        \".SS%d:\t\"
                        \"bra %%0\", table_lable_ladle);
       } else {
         sprintf(buffer,\"mov [%%0], %%2\n\t\"
                        \"add #(%%1-$)/4,%%2\n\"
                        \".SS%d:\t\"
                        \"bra %%2\", table_lable_ladle);
       }
     } else {
       if (which_alternative == 0) {
         sprintf(buffer,\"\n.SS%d:\tbra %%0\", table_lable_ladle);
       } else {
         sprintf(buffer,\"mov %%0, %%2\n\"
                        \".SS%d:\t\"
                        \"bra %%2\", table_lable_ladle);
       }
     }
     return buffer;
   }"
  [
    (set_attr "type" "etc,use")
    (set_attr "op_type" "etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Unconditional jump
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define_insn "jump_16"
  [(set (pc)
        (label_ref (match_operand 0 "" "")))]
  "(!pic30_isa32_target())"
  "bra %0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Call subroutine, returning value in operand 0
;; (which must be a hard register).
;; Operand 1 is the function to call
;; Operand 2 is the number of bytes of arguments pushed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define_expand "call_value_16"
  [(set (match_operand 0 "pic30_register_operand"        "=r,r ,r")
        (call (match_operand    1 "memory_operand"  "R,QS,m")
              (match_operand:HI 2 "pic30_general_operand" "")))]
  ;; Operand 2 not really used for dsPIC30.
  "(!pic30_isa32_target())"
  "
{
     int slot = 0;
     int set_psv;
     rtx sfr;
     rtx psv_page;
     struct saved_list *save_list = 0;
     tree save_variable_list;

     if ((GET_CODE(operands[1]) == MEM) &&
         (GET_CODE(XEXP(operands[1],0)) == SYMBOL_REF)) {
       if (!pic30_program_space_operand_p(XEXP(operands[1],0))) {
         error(\"Cannot call non-program symbol\");
       }
     }

     save_variable_list = pic30_get_save_variable_list();
     if (save_variable_list) {
       tree v;
       int args;

       for (args = 0; args < call_expr_nargs(save_variable_list); args++) {
         struct saved_list *save_item;
         tree decl;

         v = CALL_EXPR_ARG(save_variable_list, args);
         decl = pic30_get_save_variable_decl(v,NULL,NULL);
         save_item = (struct saved_list *)xmalloc(sizeof(struct saved_list));
         gcc_assert(save_item);
         save_item->saved_value = gen_reg_rtx(DECL_MODE(decl));
	 save_item->decl = decl;
         save_item->next = save_list;
         save_list = save_item;
         emit_move_insn(save_item->saved_value, DECL_RTL(save_item->decl));
       }
     }
     (void) pic30_boot_secure_access(operands[1], &slot, &set_psv);
     if ((set_psv == pic30_set_nothing) && (TARGET_TRACK_PSVPAG) &&
         TARGET_CONST_IN_CODE) {
       set_psv = pic30_set_for_tracking;
     } 
     psv_page = NULL_RTX;
     if (set_psv == pic30_set_for_tracking) {
       // set the PSV to the current page
       psv_page = pic30_get_set_psv_value(0);
     } 
     if ((set_psv == pic30_set_on_call) || (set_psv == pic30_set_for_tracking)){
       if (psv_page == 0) {
         sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
         psv_page = gen_reg_rtx(HImode);
         record_psv_tracking(0,0,
           emit(
             gen_save_const_psv_16(psv_page, sfr)
           )
         );
       } 
       set_psv_called = 1;
       record_psv_tracking(0,0,
         emit(
           gen_set_psv_16(psv_page)
         )
       );
     }
     emit(
       set_psv != pic30_set_nothing ?
       gen_call_value_helper_apsv_16(operands[0], operands[1], operands[2]) :
       gen_call_value_helper_16(operands[0], operands[1], operands[2])
     );
     if ((set_psv) && (set_psv != pic30_set_for_tracking)) {
       psv_page = pic30_get_set_psv_value(0);
       if (psv_page == NULL_RTX) {
         sfr = pic30_get_psv_value();
         psv_page = gen_reg_rtx(HImode);
         emit(
            gen_movhi_address_16(psv_page,sfr)
         );
       }
       record_psv_tracking(0,0,
         emit(
           gen_set_vpsv_16(psv_page)
         )
       );
     }    
     
     if (save_variable_list) {
       struct saved_list *l;

       for (l = save_list; l; ) {
         struct saved_list *ll = l->next;
         emit_move_insn(DECL_RTL(l->decl),l->saved_value);
         free(l);
         l = ll;
       }
     }

     DONE;
}
  "
)

(define_insn "save_const_psv_16"
  [(set (match_operand:HI 0 "pic30_register_operand"        "=r")
        (match_operand:HI 1 "pic30_symbolic_address_operand" "qs"))]
  "(!pic30_isa32_target())"
  "mov #%1,%0"
)

(define_insn "call_value_helper_16"
  [(set (match_operand 0 "pic30_register_operand"        "=r,r ,r")
        (call (match_operand    1 "memory_operand"  "R,QS,m")
              (match_operand:HI 2 "pic30_general_operand" "")))]
  ;; Operand 2 not really used for dsPIC30.
  "(!pic30_isa32_target()) && (pic30_check_for_conversion(insn))"
  "*
   static char szInsn[88];
   char *security;
   int slot = 0;
   int set_psv;
   char *this_insn = szInsn;

   pic30_clear_fn_list = 1;
   pic30_valid_call_address_operand(operands[0], Pmode);
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
    this_insn += sprintf(this_insn,\"call __c30_abi_push\n\t\");
   }
#endif
   switch (which_alternative)
   {
     case 0:
       this_insn += sprintf(this_insn,\"call %s\", reg_names[REGNO(XEXP(operands[1],0))]);
       break;
     case 1:
       /*
        ** Casts of &(int x) to function ptrs, etc.
        */
       error(\"invalid function call\");
     case 2:
       security = pic30_boot_secure_access(operands[1],&slot,&set_psv);
       if (security) {
         this_insn += sprintf(this_insn, \"%s %s(%d)\",
                         pic30_near_function_p(operands[1]) ? 
                           \"rcall\" : \"call\", security,slot);
       } else 
         this_insn += sprintf(this_insn, \"%s %%1\",
                         pic30_near_function_p(operands[1]) ? 
                           \"rcall\" : \"call\");
         break;
      default:
         gcc_assert(0);
   }
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
     this_insn += sprintf(this_insn,\"\n\tcall __c30_abi_pop\");
   }
#endif
   return szInsn ;
")

(define_insn "call_value_helper_apsv_16"
  [(set (match_operand 0 "pic30_register_operand"        "=r,r ,r")
        (call (match_operand    1 "memory_operand"  "R,QS,m")
              (match_operand:HI 2 "pic30_general_operand" "")))
   (use (reg:HI PSVPAG))
  ]
  ;; Operand 2 not really used for dsPIC30.
  "(!pic30_isa32_target()) && (pic30_check_for_conversion(insn))"
  "*
   static char szInsn[88];
   char *security;
   int slot = 0;
   int set_psv;
   char *this_insn = szInsn;

   pic30_clear_fn_list = 1;
   pic30_valid_call_address_operand(operands[0], Pmode);
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
    this_insn += sprintf(this_insn,\"call __c30_abi_push\n\t\");
   }
#endif
   switch (which_alternative)
   {
     case 0:
       this_insn += sprintf(this_insn,\"call %s\", reg_names[REGNO(XEXP(operands[1],0))]);
       break;
     case 1:
       /*
        ** Casts of &(int x) to function ptrs, etc.
        */
       error(\"invalid function call\");
     case 2:
       security = pic30_boot_secure_access(operands[1],&slot,&set_psv);
       if (security) {
         this_insn += sprintf(this_insn, \"%s %s(%d)\",
                         pic30_near_function_p(operands[1]) ? 
                           \"rcall\" : \"call\", security,slot);
       } else 
         this_insn += sprintf(this_insn, \"%s %%1\",
                         pic30_near_function_p(operands[1]) ? 
                           \"rcall\" : \"call\");
         break;
      default:
         gcc_assert(0);
   }
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
     this_insn += sprintf(this_insn,\"\n\tcall __c30_abi_pop\");
   }
#endif
   return szInsn ;
")

;; Call subroutine with no return value.
(define_expand "call_void_16"
  [ (call (match_operand:QI 0 "memory_operand"  "R,QS,m")
          (match_operand:HI 1 "pic30_general_operand" ""))]
  ;; Operand 1 not really used for dsPIC30.
  "(!pic30_isa32_target())"
  "
{
     int slot;
     int set_psv;
     rtx sfr;
     rtx psv_page;
     struct saved_list *save_list = 0;
     tree save_variable_list;

     if ((GET_CODE(operands[0]) == MEM) &&
         (GET_CODE(XEXP(operands[0],0)) == SYMBOL_REF)) {
       if (!pic30_program_space_operand_p(XEXP(operands[0],0))) {
         error(\"Cannot call non-program symbol\");
       }
     }

     save_variable_list = pic30_get_save_variable_list();
     if (save_variable_list) {
       tree v;
       int args;

       for (args = 0; args < call_expr_nargs(save_variable_list); args++) {
         struct saved_list *save_item;
         tree decl;
         
         v = CALL_EXPR_ARG(save_variable_list,args);
         decl = pic30_get_save_variable_decl(v,NULL,NULL);
         save_item = (struct saved_list *)xmalloc(sizeof(struct saved_list));
         gcc_assert(save_item);
         save_item->saved_value = gen_reg_rtx(DECL_MODE(decl));
         save_item->decl = decl;
         save_item->next = save_list;
         save_list = save_item;
         emit_move_insn(save_item->saved_value, DECL_RTL(save_item->decl));
       }
     }

     (void) pic30_boot_secure_access(operands[1], &slot, &set_psv);
     if ((set_psv == pic30_set_nothing) && (TARGET_TRACK_PSVPAG) &&
          TARGET_CONST_IN_CODE) {
       set_psv = pic30_set_for_tracking;
     }
     psv_page = NULL_RTX;
     if (set_psv == pic30_set_for_tracking) {
       // set the PSV to the current page
       psv_page = pic30_get_set_psv_value(0);
     }
     if ((set_psv == pic30_set_on_call) || (set_psv == pic30_set_for_tracking)){
       if (psv_page == 0) {
         sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
         psv_page = gen_reg_rtx(HImode);
         record_psv_tracking(0,0,
           emit(
             gen_save_const_psv_16(psv_page, sfr)
           )
         );
       }
       set_psv_called = 1;
       record_psv_tracking(0,0,
         emit(
           gen_set_nvpsv_16(psv_page)
         )
       );
     }
     emit(
       set_psv != pic30_set_nothing ?
       gen_call_void_helper_apsv_16(operands[0], operands[1]) :
       gen_call_void_helper_16(operands[0], operands[1])
     );
     if ((set_psv) && (set_psv != pic30_set_for_tracking)) {
       psv_page = pic30_get_set_psv_value(0);
       if (psv_page == NULL_RTX) {
         sfr = pic30_get_psv_value();
         psv_page = gen_reg_rtx(HImode);
         emit(
           gen_movhi_address_16(psv_page,sfr)
         );
       }
       record_psv_tracking(0,0,
         emit(
           gen_set_nvpsv_16(psv_page)
         )
       );
     }    

     if (save_variable_list) {
       struct saved_list *l;

       for (l = save_list; l; ) {
         struct saved_list *ll = l->next;
         emit_move_insn(DECL_RTL(l->decl),l->saved_value);
         free(l);
         l = ll;
       }
     }

     DONE;
}
  "
)

(define_insn "call_void_helper_16"
  [(call (match_operand:QI 0 "memory_operand" "R,QS,m")
         (match_operand:HI 1 "pic30_general_operand" ""))]
  "(!pic30_isa32_target()) && (pic30_check_for_conversion(insn))"
  "*
{
   static char szInsn[88];
   char *security;
   int slot = 0;
   char *this_insn = szInsn;

   pic30_clear_fn_list = 1;
   pic30_valid_call_address_operand(operands[0], Pmode);
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
    this_insn += sprintf(this_insn,\"call __c30_abi_push\n\t\");
   }
#endif
   switch (which_alternative)
   {
     case 0:
       this_insn += sprintf(this_insn,\"call %s\", reg_names[REGNO(XEXP(operands[0],0))]);
       break;
     case 1:
       /*
        ** Casts of &(int x) to function ptrs, etc.
        */
       error(\"invalid function call\");
     case 2:
       security = pic30_boot_secure_access(operands[0],&slot,0);
       if (security) {
         this_insn += sprintf(this_insn, \"%s %s(%d)\",
                         pic30_near_function_p(operands[0]) ? 
                           \"rcall\" : \"call\",
                         security, slot);
       } else
         this_insn += sprintf(this_insn, \"%s %%0\",
                         pic30_near_function_p(operands[0]) ? 
                           \"rcall\" : \"call\");
         break;
     default:
       gcc_assert(0);
   }
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
     this_insn += sprintf(this_insn,\"\n\tcall __c30_abi_pop\");
   }
#endif
   return szInsn ;
}")

(define_insn "call_void_helper_apsv_16"
  [(call (match_operand:QI 0 "memory_operand" "R,QS,m")
         (match_operand:HI 1 "pic30_general_operand" ""))
   (use (reg:HI PSVPAG))
  ]
  "(!pic30_isa32_target()) && (pic30_check_for_conversion(insn))"
  "*
{
   static char szInsn[88];
   char *security;
   int slot = 0;
   char *this_insn = szInsn;

   pic30_clear_fn_list = 1;
   pic30_valid_call_address_operand(operands[0], Pmode);
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
    this_insn += sprintf(this_insn,\"call __c30_abi_push\n\t\");
   }
#endif
   switch (which_alternative)
   {
     case 0:
       this_insn += sprintf(this_insn,\"call %s\", reg_names[REGNO(XEXP(operands[0],0))]);
       break;
     case 1:
       /*
        ** Casts of &(int x) to function ptrs, etc.
        */
       error(\"invalid function call\");
     case 2:
       security = pic30_boot_secure_access(operands[0],&slot,0);
       if (security) {
         this_insn += sprintf(this_insn, \"%s %s(%d)\",
                         pic30_near_function_p(operands[0]) ? 
                           \"rcall\" : \"call\",
                         security, slot);
       } else
         this_insn += sprintf(this_insn, \"%s %%0\",
                         pic30_near_function_p(operands[0]) ? 
                           \"rcall\" : \"call\");
         break;
     default:
       gcc_assert(0);
   }
#ifdef __C30_BETA__
   if (TARGET_ABI_CHECK) {
     this_insn += sprintf(this_insn,\"\n\tcall __c30_abi_pop\");
   }
#endif
   return szInsn ;
}")

;; Call subroutine with no return value.
;; This handles intrinsics, such as bcopy.

(define_expand "call_16"
 [(call (match_operand:QI 0 "" "")
        (match_operand:HI 1 "" ""))]
 "(!pic30_isa32_target())"
 "
{
  int slot = 0;
  int set_psv;
  rtx sfr;
  rtx psv_page;
  struct saved_list *save_list = 0;
  tree save_variable_list;
  if (GET_CODE (operands[0]) == MEM && 
      !pic30_call_address_operand (XEXP (operands[0], 0), FN_Pmode))
    operands[0] = gen_rtx_MEM (GET_MODE (operands[0]),
			       force_reg (FN_Pmode, XEXP (operands[0], 0)));

  if ((GET_CODE(operands[0]) == MEM) && 
      (GET_CODE(XEXP(operands[0],0)) == SYMBOL_REF)) {
    if (!pic30_program_space_operand_p(XEXP(operands[0],0))) {
      error(\"Cannot call non-program symbol\");
    }
  }

  save_variable_list = pic30_get_save_variable_list();
  if (save_variable_list) {
    tree v;
    int args;

    for (args = 0; args < call_expr_nargs(save_variable_list); args++) {
      struct saved_list *save_item;
      tree decl;

      v = CALL_EXPR_ARG(save_variable_list, args);
      decl = pic30_get_save_variable_decl(v,NULL,NULL);
      save_item = (struct saved_list *)xmalloc(sizeof(struct saved_list));
      gcc_assert(save_item);
      save_item->saved_value = gen_reg_rtx(DECL_MODE(decl));
      save_item->decl = decl;
      save_item->next = save_list;
      save_list = save_item;
      emit_move_insn(save_item->saved_value, DECL_RTL(save_item->decl));
    }
  }

  /* pic30_set_on_call => must set to .const , and pic30_set_on_return */
  /* pic30_set_on_return => must restore after call */

  (void) pic30_boot_secure_access(operands[1], &slot, &set_psv);
  if ((set_psv == pic30_set_nothing) && (TARGET_TRACK_PSVPAG) &&
       TARGET_CONST_IN_CODE) {
    set_psv = pic30_set_for_tracking;
  }
  psv_page = NULL_RTX;
  if (set_psv == pic30_set_for_tracking) {
    // set the PSV to the current page
    psv_page = pic30_get_set_psv_value(0);
  }
  if ((set_psv == pic30_set_on_call) || (set_psv == pic30_set_for_tracking)){
    if (psv_page == 0) {
      sfr = gen_rtx_SYMBOL_REF(HImode,\"_const_psvpage\");
      psv_page = gen_reg_rtx(HImode);
      record_psv_tracking(0,0,
        emit(
          gen_save_const_psv_16(psv_page, sfr)
        )
      );
    }
    set_psv_called = 1;
    record_psv_tracking(0,0,
      emit(
        gen_set_nvpsv_16(psv_page)
      )
    );
  }
  emit(
    set_psv != pic30_set_nothing ?
    gen_call_void_helper_apsv_16(operands[0], operands[1]) :
    gen_call_void_helper_16(operands[0], operands[1])
  );
  if ((set_psv) && (set_psv != pic30_set_for_tracking)) {
    psv_page = pic30_get_set_psv_value(0);
    if (psv_page == NULL_RTX) {
      sfr = pic30_get_psv_value();
      psv_page = gen_reg_rtx(HImode);
      emit(
        gen_movhi_address_16(psv_page,sfr)
      );
    }
    record_psv_tracking(0,0,
      emit(
        gen_set_nvpsv_16(psv_page)
      )
    );
  }   

  if (save_variable_list) {
     struct saved_list *l;

     for (l = save_list; l; ) {
       struct saved_list *ll = l->next;
       emit_move_insn(DECL_RTL(l->decl),l->saved_value);
       free(l);
       l = ll;
     }
   }

  DONE;
}")

(define_insn "*call_16"
  [(call (mem:QI (match_operand:QI 0 "pic30_call_address_operand" ""))
         (match_operand:HI 1 "pic30_general_operand" ""))]
  "(!pic30_isa32_target()) && (pic30_check_for_conversion(insn))"
  "*
  {
    static char szInsn[88];
    char *security;
    int slot = 0;
    char *insn = szInsn;

    pic30_clear_fn_list = 1;
    pic30_valid_call_address_operand(operands[0], FN_Pmode);
    security = pic30_boot_secure_access(operands[0],&slot,0);
#ifdef __C30_BETA__
    if (TARGET_ABI_CHECK) {
     insn += sprintf(insn,\"call __c30_abi_push\n\t\");
    }
#endif
    if (security) {
      insn += sprintf(insn, \"call %s(%d)\",security, slot);
    } else sprintf(szInsn,\"call %%0\");
#ifdef __C30_BETA__
    if (TARGET_ABI_CHECK) {
      insn += sprintf(insn,\"\n\tcall __c30_abi_pop\");
    }
#endif
    return szInsn;
  }"
)

;;
;; return
;;
(define_insn "return_16"
  [(return)]
  "(!pic30_isa32_target()) && (pic30_null_epilogue_p(0))"
  "*
{
	pic30_set_function_return(TRUE);

	return \"return\";
}"
  [
    (set_attr "cc" "clobber")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "return_from_epilogue_16"
  [(return)]
  "(!pic30_isa32_target()) && (!pic30_null_epilogue_p(0) && reload_completed)"
  "*
  { extern tree current_function_decl;
    if (pic30_interrupt_function_p(current_function_decl))
    {
      return \"retfie\";
    }
    else if (pic30_noreturn_function(current_function_decl))
    {
      return \"reset\";
    }
    else
    {
      return \"return\";
    }
  }"
  [
    (set_attr "cc" "clobber")
    (set_attr "op_type" "etc")
  ]
)

;;
;; link
;;
(define_insn "lnk_16"
 [
    (set (mem:HI (reg:HI SPREG))
         (reg:HI FPREG))
    (set (reg:HI FPREG)
         (plus:HI (reg:HI SPREG) (const_int 2)))
    (set (reg:HI SPREG)
         (plus:HI (reg:HI SPREG)
                  (plus:HI (match_operand 0 "immediate_operand" "i")
                           (const_int 2))))
 ]
 "reload_completed"
 "lnk #%0"
 [
  (set_attr "cc" "change0")
  (set_attr "type" "def")
  (set_attr "op_type" "etc")
 ]
)

; for creating a stack frame...
(define_insn "addhi3_lnk_16"
 [(set (reg:HI SPREG)
       (plus:HI (reg:HI SPREG)
                (match_operand 0 "immediate_operand" "i")))
  (clobber (reg:CC_NZC CC_REG))
 ]
 ""
 "mov.w w0,[w14]\;mov.w #%0,w0\;add.w w0,w15,w15\;mov.w [w14],w0"
)

;;
;; unlink
;;
(define_insn "ulnk_16"
  [
     (set (reg:HI SPREG)
          (minus:HI (reg:HI FPREG) (const_int 2)))
     (set (reg:HI FPREG)
          (mem:HI (reg:HI SPREG)))
  ]
  "(!pic30_isa32_target()) && reload_completed"
  "*
  {
    if ((pic30_errata_mask & busmaster_errata) && (pic30_ecore_target())) {
      return \"mov w14,w15\;mov [--w15],w14\;bclr CORCON,#2\";
    } 
    return \"ulnk\";
  }
  "
  [
   (set_attr "cc" "change0")
   (set_attr "type" "def")
   (set_attr "op_type" "etc")
  ]
)

;;
;; disi
;;
(define_insn "disi_16"
  [(unspec_volatile [(match_operand 0 "immediate_operand" "i")] UNSPECV_DISI)]
  "(!pic30_isa32_target())"
  "disi #%0")



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; prologue/epilogue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "prologue_16"
  [(const_int 1)]
  "(!pic30_isa32_target())"                           
  "
  {
     pic30_expand_prologue();
     DONE;
  }"
)

(define_expand "epilogue_16"
  [(const_int 1)]
  "(!pic30_isa32_target())"
  "
  {
     pic30_expand_epilogue();
     DONE;
  }"
)

(define_insn "profile_enter_16"
  [(unspec_volatile [(const_int 0)] UNSPECV_ENTER)]
  "(!pic30_isa32_target())"
  "call __function_level_profiling_long"
)

(define_insn "profile_exit_16"
  [(unspec_volatile [(const_int 0)] UNSPECV_EXIT)]
  "(!pic30_isa32_target())"
  "goto __function_level_profiling_long_zero"
)

(define_insn "profile_exit_call_16"
  [(unspec_volatile [(const_int 1)] UNSPECV_EXIT)]
  "(!pic30_isa32_target())"
  "call __function_level_profiling_long_zero"
)

;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and
;; all of memory.  This blocks insns from being moved across this point.

(define_insn "blockage_16"
  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]
  "(!pic30_isa32_target())"
  "")

(define_insn "pa_16"
  [(unspec_volatile [(match_operand 0 "immediate_operand" "i")] UNSPECV_PA)]
  "(!pic30_isa32_target())"
  ".set ___PA___,%0")

(define_insn "iv_16"
  [(unspec_volatile [(match_operand 0 "immediate_operand" "i")] UNSPECV_IV)]
  "(!pic30_isa32_target())"
  {
   static char szInsn[96];
	char szVector[32];
	int nVectorID;
			
	nVectorID = INTVAL(operands[0]);
	if (nVectorID < 0)
	{
		nVectorID = -nVectorID-1;
		sprintf(szVector,"__AltInterrupt%d",nVectorID);
	}
	else
	{
		sprintf(szVector, "__Interrupt%d", nVectorID);
	}
	sprintf(szInsn, ".global\t%s\n%s:", szVector, szVector);

	return szInsn;
  }
)
(define_insn "pp_16"
  [(unspec_volatile [(const_int 0)] UNSPECV_PP)]
  "(!pic30_isa32_target())"
  {
  	return pic30_interrupt_preprologue();
  }
)

;
; CAW - for RAW scheduling we could split these instructions after the
;   mov #_addr,%0
;
(define_insn "write_oscconl_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=&r")
        (unspec_volatile [
                     (match_operand 1 "pic30_register_operand" "r")
                     (match_operand 2 "pic30_register_operand" "r")
                     (match_operand 3 "pic30_register_operand" "r")]
           UNSPECV_WRITEOSCCONL)
   )]
  "(!pic30_isa32_target())"
  "mov #_OSCCON,%0\;mov.b %1,[%0]\;mov.b %2,[%0]\;mov.b %3,[%0]"
)

(define_insn "write_oscconh_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=&r")
        (unspec_volatile [
                     (match_operand 1 "pic30_register_operand" "r")
                     (match_operand 2 "pic30_register_operand" "r")
                     (match_operand 3 "pic30_register_operand" "r")]
    UNSPECV_WRITEOSCCONH)
   )]
  "(!pic30_isa32_target())"
  "mov #_OSCCON+1,%0\;mov.b %1,[%0]\;mov.b %2,[%0]\;mov.b %3,[%0]"
)

(define_insn "write_disicnt_16"
  [ (unspec_volatile [
      (match_operand 0 "pic30_register_operand" "r")] UNSPECV_WRITEDISICNT)
  ]
  "(!pic30_isa32_target())"
  "mov %0,_DISICNT\;mov w0,_WREG0"
)

(define_insn "write_pwmsfr_16"
  [ (unspec_volatile [
      (match_operand:HI 0 "pic30_near_operand"     "U,U")
      (match_operand:HI 1 "pic30_register_operand" "a,r")
      (match_operand:HI 2 "pic30_register_operand" "r,r")
      (match_operand:HI 3 "pic30_register_operand" "r,r")
      (match_operand:HI 4 "pic30_R_operand"        "R,R")
    ] UNSPECV_WRITEPWMCON)
    (clobber (match_scratch: HI  5                "=X,&r"))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %3,%4\;mov %2,%4\;mov %1,%0
   mov #%0,%5\;mov %3,%4\;mov %2,%4\;mov %1,[%5]"
  [
    (set_attr "cc" "change0")
    (set_attr "type" "use,etc")
    (set_attr "op_type" "mov")
  ]
)

;   (set (match_operand:HI 0 "pic30_register_operand" "+r")
;        (unspec_volatile [ (const_int 0) ] UNSPECV_WRITENVM))
;   (set (match_operand:HI 1 "pic30_register_operand" "+r")
;        (unspec_volatile [ (const_int 1) ] UNSPECV_WRITENVM)) ]
(define_insn "write_nvm_secure_16"
  [
    (unspec_volatile [ 
      (match_operand:HI 0 "pic30_register_operand" "+r") 
      (match_operand:HI 1 "pic30_register_operand" "+r") 
    ] UNSPECV_WRITENVM)
  ]
  "(!pic30_isa32_target())"
  ".set ___PA___,0\;mov %0,_NVMKEY\;nop\;mov %1,_NVMKEY\;bset _NVMCON,#15\;clr %0\;clr %1\;.set __PA___,1"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "write_nvm_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (unspec_volatile [ (const_int 0) ] UNSPECV_WRITENVM))]
  "(!pic30_isa32_target())"
  ".set ___PA___,0\;mov #0x55,%0\;mov %0,_NVMKEY\;mov #0xAA,%0\;mov %0,_NVMKEY\;bset _NVMCON,#15\;nop\;nop\;.set ___PA___,1"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "write_rtcwen_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=&r")
        (unspec_volatile [
           (match_operand:HI 1 "pic30_register_operand" "0")
         ] UNSPECV_WRITERTCWEN))]
  "(!pic30_isa32_target())"
  ".set ___PA___,0\;mov #0x55,%0\;mov %0,_NVMKEY\;mov #0xAA,%0\;mov %0,_NVMKEY\;bset _RCFGCAL,#13\;.set ___PA___,1"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "write_wrlock_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=&r")
        (unspec_volatile [
           (match_operand:HI 1 "pic30_register_operand" "0")
         ] UNSPECV_WRITEWRLOCK))]
  "(!pic30_isa32_target())"
  ".set ___PA___,0\;mov #0x55,%0\;mov %0,_NVMKEY\;mov #0xAA,%0\;mov %0,_NVMKEY\;bclr _RTCCON1L,#11\;.set ___PA___,1"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "write_cryotp_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=&r")
        (unspec_volatile [ (const_int 0) ] UNSPECV_WRITECRTOTP))]
  "(!pic30_isa32_target())"
  ".set ___PA___,0\;mov #0x55,%0\;mov %0,_NVMKEY\;mov #0xAA,%0\;mov %0,_NVMKEY\;nop\;bset _CRYOTP,#0\;.set ___PA___,1"
  [
    (set_attr "type" "etc")
    (set_attr "op_type" "alu")
  ]
)

(define_insn "write_dataflash_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (unspec_volatile [ (const_int 0) ] UNSPECV_WRITEDATAFLASH))
   (clobber 
        (match_scratch:HI 1                          "=&r"))
  ]
  "(!pic30_isa32_target())"
  ".set ___PA___,0\;mov _DFCON,%1\;bset %1,#7\;mov #0xEDB7,%0\;mov %0,_DFKEY\;mov #0x1248,%0\;mov %0,_DFKEY\;mov %1,_DFCON\;.set ___PA___,1"
)

(define_insn "write_dataflash_secure_16"
  [
    (unspec_volatile [ 
      (match_operand:HI 0 "pic30_register_operand" "+r") 
      (match_operand:HI 1 "pic30_register_operand" "+r") 
    ] UNSPECV_WRITEDATAFLASH)
    (clobber 
         (match_scratch:HI 2                          "=&r"))
  ]
  "(!pic30_isa32_target())"
  ".set ___PA___,0\;mov _DFCON,%2\;bset %2,#7\;mov %0,_DFKEY\;mov %1,_DFKEY\;mov %2,_DFCON\;clr %0\;clr %1\;.set ___PA___,1"
)

(define_insn "write_rpcon_16"
  [ (unspec_volatile [
      (match_operand 0 "pic30_register_operand" "r")] UNSPECV_WRITERPCON)
    (clobber
         (match_scratch:HI 1                          "=&r"))
  ]
  ""
  ".set ___PA___,0\;mov #0x55,%1\;mov %1,_NVMKEY\;mov #0xAA,%1\;mov %1,_NVMKEY\;mov %0,_RPCON\;.set ___PA___,1"
  [
    (set_attr "type" "etc")
  ]
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; nop
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "bifnop_16"
  [(unspec_volatile [(const_int 0)] UNSPECV_NOP)]
  "(!pic30_isa32_target())"
  "nop"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "pwrsav_16"
  [
   (unspec_volatile 
     [(match_operand:HI 0 "immediate_operand" "i")]
    UNSPECV_PWRSAV)
  ]
  "(!pic30_isa32_target())"
  "pwrsav #%0"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

(define_insn "clrwdt_16"
  [
   (unspec_volatile
     [(const_int 0)]
   UNSPECV_CLRWDT)
  ]
  "(!pic30_isa32_target())"
  "clrwdt"
  [
    (set_attr "cc" "unchanged")
    (set_attr "op_type" "etc")
  ]
)

;
;; misc
;

(define_insn "section_begin_16"
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
        (unspec:SI [ 
          (match_operand 1 "immediate_operand" "i")
        ] UNSPEC_SECTION_BEGIN))]
  "(!pic30_isa32_target())"
  "*
  { static char *buffer = 0;
    static int buffer_size;
    int len;

    tree t = (tree)(INTVAL(operands[1]));
    const char *section_name = TREE_STRING_POINTER(t);
    len = sizeof (\"mov.w #.startof.(),%0\;mov.w #.startof_hi.(),%d0\");
    len += strlen(section_name)*2;
    len++;
    if (buffer_size < len) {
      if (buffer) free(buffer);
      buffer = (char *)xmalloc(len+50);
      buffer_size = len+50;
    }
    sprintf(buffer, \"mov.w #.startof.(%s),%%0\;mov.w #.startof_hi.(%s),%%d0\",
            section_name, section_name);
    return buffer;
  }"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "section_end_16"
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
        (unspec:SI [ 
          (match_operand 1 "immediate_operand" "i")
        ] UNSPEC_SECTION_END))]
  "(!pic30_isa32_target())"
  "*
  { static char *buffer = 0;
    static int buffer_size;
    int len;

    tree t = (tree)(INTVAL(operands[1]));
    const char *section_name = TREE_STRING_POINTER(t);
    len = sizeof (\"mov.w #.endof.(),%0\;mov.w #.endof_hi.(),%d0\");
    len += strlen(section_name)*2;
    len++;
    if (buffer_size < len) {
      if (buffer) free(buffer);
      buffer = (char *)xmalloc(len+50);
      buffer_size = len+50;
    }
    sprintf(buffer, \"mov.w #.endof.(%s),%%0\;mov.w #.endof_hi.(%s),%%d0\",
            section_name, section_name);
    return buffer;
  }"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

(define_insn "section_size_16"
  [(set (match_operand:SI 0 "pic30_register_operand" "=r")
        (unspec:SI [ 
          (match_operand 1 "immediate_operand" "i")
        ] UNSPEC_SECTION_SIZE))]
  "(!pic30_isa32_target())"
  "*
  { static char *buffer = 0;
    static int buffer_size;
    int len;

    tree t = (tree)(INTVAL(operands[1]));
    const char *section_name = TREE_STRING_POINTER(t);
    len = sizeof (\"mov.w #.sizeof.(),%0\;mov.w #.sizeof_hi.(),%d0\");
    len += strlen(section_name)*2;
    len++;
    if (buffer_size < len) {
      if (buffer) free(buffer);
      buffer = (char *)xmalloc(len+50);
      buffer_size = len+50;
    }
    sprintf(buffer, \"mov.w #.sizeof.(%s),%%0\;mov.w #.sizeof_hi.(%s),%%d0\",
            section_name, section_name);
    return buffer;
  }"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "movlit")
  ]
)

; define [sg]et_isr_state as an expand, in so that we can generate less
;   code if we don't actually 'use' the value (apart from to re-set it)
;   if unless we say if (__builtin_get_isr_state() == n) there is no need
;   to shift the value

(define_insn "get_isr_state_helper_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (unspec_volatile:HI [ (const_int 0) ] UNSPEC_GET_ISR_STATE))]
  "(!pic30_isa32_target())"
  "mov _SR,%0"
  [
    (set_attr "type" "def")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "extract_gie_16"
  [(set (match_operand:HI 0 "pic30_register_operand" "=r")
        (unspec_volatile:HI [ (match_dup 0) ] UNSPEC_EXTRACT_GIE))
  ]
  "(!pic30_isa32_target())"
  "bclr %0,#3\;btsc _INTCON2,#15\;bset %0,#3"
)

(define_expand "get_isr_state_16"
 [(set (match_operand:HI 0 "pic30_register_operand" "=r")
       (unspec_volatile:HI [(const_int 0)] UNSPEC_GET_ISR_STATE))]
 "(!pic30_isa32_target())"
 "{ rtx reg = operands[0];

    if (!pic30_register_operand(operands[0], HImode)) {
      reg = force_reg (HImode, operands[0]);
    }
    emit_insn(
      gen_get_isr_state_helper_16(reg)
    );
    emit_insn(
      gen_ashrhi3_16(reg, reg, GEN_INT(5))
    );
    emit_insn(
      gen_andhi3_16(reg, reg, GEN_INT(7))
    );
    if (pic30_device_has_gie()) {
      emit_insn(
        gen_extract_gie_16(reg)
      );
    }
    if (reg != operands[0]) {
      emit_move_insn(operands[0], reg);
    }
    DONE;
  }")

(define_insn "set_isr_state_helper_16"
  [(unspec_volatile [
      (match_operand:HI 0 "pic30_register_operand" "r")
    ] UNSPECV_SET_ISR_STATE)
   (clobber (match_scratch:HI 1                    "=&r"))
   (clobber (match_scratch:HI 2                    "=&r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "mov _SR,%1\;and.b #0x1F,%1\;ior %1,%0,%1\;mov %1,_SR"
  [
    (set_attr "cc" "clobber")
    (set_attr "op_type" "mov")
  ]
)

(define_insn "insert_gie_16"
  [(unspec_volatile [ 
      (match_operand:HI 0 "pic30_register_operand" "r")] UNSPEC_INSERT_GIE)
   (clobber (match_scratch:HI 1                    "=r"))
  ]
  "(!pic30_isa32_target())"
  "btsc %0,#3\;bset _INTCON2,#15\;btss %0,#3\;bclr _INTCON2,#15\;nop\;nop"
)


(define_expand "set_isr_state_16"
 [(unspec_volatile [ 
     (match_operand:HI 0 "pic30_register_operand" "=r")] UNSPECV_SET_ISR_STATE)]
 "(!pic30_isa32_target())"
 "{ rtx reg = operands[0];
    rtx reg2 = gen_reg_rtx(HImode);

    if (!pic30_register_operand(operands[0], HImode)) {
      reg = force_reg (HImode, operands[0]);
    }
    emit_insn(
      gen_andhi3_16(reg2, reg, GEN_INT(7))
    );
    emit_insn(
      gen_ashlhi3_16(reg2, reg2, GEN_INT(5))
    );
    emit_insn(
      gen_set_isr_state_helper_16(reg2)
    );
    if (pic30_device_has_gie()) {
      emit_insn(
        gen_insert_gie_16(reg)
      );
    }
    DONE;
  }")

(define_insn "disable_isr_gie_16"
  [(unspec_volatile [(const_int 0)] UNSPECV_DISABLE_ISR_GIE)]
  "(!pic30_isa32_target())"
  "*
   {
     if (pic30_device_has_gie()) {
       /* clear the GIE */
       return \"bclr _INTCON2,#15\;nop\;nop\";
     } else {
       error(\"This device has no GIE\");
       return \"; This device has no GIE\";
     }
   }"
)

(define_insn "enable_isr_gie_16"
  [(unspec_volatile [(const_int 0)] UNSPECV_ENABLE_ISR_GIE)]
  "(!pic30_isa32_target())"
  "*
   {
     if (pic30_device_has_gie()) {
       /* set the GIE */
       return \"bset _INTCON2,#15\;nop\;nop\";
     } else {
       error(\"This device has no GIE\");
       return \"; This device has no GIE\";
     }
   }"
)  

(define_insn "disable_isr_ipl_16"
  [(unspec_volatile [(const_int 0)] UNSPECV_DISABLE_ISR)
   (clobber (match_scratch:HI 0  "=a,r"))
   (clobber (match_scratch:HI 1  "=r,r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     if (which_alternative == 0) {
       return \"disi #0x4\;mov #0xE0,%0\;ior _SR\";
     } else {
       return \"disi #0x6\;mov _SR,%1\;ior #0xE0,%1\;mov %1,_SR\";
     }
   }"
)

(define_insn "enable_isr_ipl_16"
  [(unspec_volatile [(const_int 0)] UNSPECV_ENABLE_ISR)
   (clobber (match_scratch:HI 0  "=r"))
   (clobber (match_scratch:HI 1  "=r"))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(!pic30_isa32_target())"
  "disi #0x6\;mov _SR,%0\;and.b #0x1F,%0\;mov %0,_SR"
)

(define_expand "disable_isr_16"
  [(const_int 0)]
  "(!pic30_isa32_target())"
  "{
     if (pic30_device_has_gie()) {
       emit_insn(
         gen_disable_isr_gie_16()
       );
     } else {
       emit_insn(
         gen_disable_isr_ipl_16()
       );
     }
     DONE;
   }"
)

(define_expand "enable_isr_16"
  [(const_int 0)]
  "(!pic30_isa32_target())"
  "{
     if (pic30_device_has_gie()) {
       emit_insn(
         gen_enable_isr_gie_16()
       );
     } else {
       emit_insn(
         gen_enable_isr_ipl_16()
       );
     }
     DONE;
   }"
)

(define_insn "software_break_16"
  [(unspec_volatile [(const_int 0)] UNSPECV_SOFTWARE_BREAK)]
  "(!pic30_isa32_target())"
  "break"
)
 
;; Fixed Point

;; Use mode iterators alot here, because they are "new" and these are new
;;   patterns (and because most of our Fract/Accum types are the same size

;; *** helper patterns

; for use in the prologue to set the right initial value
(define_insn "setCORCON_16"
  [(set (reg:HI CORCON)
        (match_operand:HI 0 "pic30_register_operand" "r"))]
  "(!pic30_isa32_target())"
  "mov %0,_CORCON"
)

(define_insn "abs<mode>2_16"
  [(set (match_operand:Q15   0 "pic30_register_operand" "=r")
        (abs:Q15 
          (match_operand:Q15 1 "pic30_register_operand"  "0")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "btsc %1,#15\;neg %1,%0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "bsetCORCON_16"
  [(set (reg:HI CORCON)
        (ior:HI (reg:HI CORCON)
                (match_operand 0 "const_int_operand"      "i,i,i")))]
  "(pic30_one_bit_set_p(INTVAL(operands[0])&0xffff))"
  "bset _CORCON,#%b0"
)

(define_insn "bclrCORCON_16"
  [(set (reg:HI CORCON)
        (and:HI (reg:HI CORCON)
                (match_operand 0 "const_int_operand"      "i,i,i")))]
  "(pic30_one_bit_set_p(((~INTVAL(operands[0]))&0xffff)))"
  "bclr.b _CORCON,#%B0"
)

;; *** load/store

(define_insn "mov<mode>_rimm_16"
   [(set (match_operand:QUQ15 0 "pic30_register_operand" "=r")
         (match_operand:QUQ15 1 "immediate_operand" "i"))]
   "(!pic30_isa32_target())"
   "mov #%1,%0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "mov<mode>_gen_16"
  [
    (set 
       (match_operand:QUQ15 0 "pic30_move_operand" "=rR<>, Q,r, TU,r, !TUrR<>,w,Q,w,TU,w,r,w,   R<>")
       (match_operand:QUQ15 1 "pic30_move_operand" " rR<>, r,Q, r,TU, TUrR<>, w,w,Q,w,TU,w,rR<>,w"))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   mov %1,%0
   push %1\;pop %0
   clr %0\;add %0
   mov %m1H,%0
   lac %1,%0
   push %m1H\;pop %0
   clr %0\;push %1\;pop %m0H
   mov %m1H,%0
   lac %1,%0
   push %m1H\;pop %0"
  [
    (set_attr "type" "defuse,use,defuse,etc,def,defuse,etc,use,use,etc,etc,def,use,use")
  ]
)

(define_expand "mov<mode>_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand" "")
        (match_operand:QUQ15 1 "pic30_move_operand" ""))]
  "(!pic30_isa32_target())"
  "
{ int result;

  result = pic30_emit_move_sequence(operands, <MODE>mode);

  if (result > 0) DONE;
  if (immediate_operand(operands[1],VOIDmode)) {
    rtx reg = operands[0];

    if (!pic30_register_operand(operands[0],<MODE>mode)) {
      reg = gen_reg_rtx(<MODE>mode);
      emit(
        gen_mov<mode>_rimm_16(reg,operands[1])
      );
      emit_move_insn(operands[0], reg);
      DONE;
    }
  }
}")

;;
;; larger moves cannot use the 'k'

(define_insn "mov<mode>_rimm_16"
  [
    (set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
         (match_operand:QUQ31 1 "immediate_operand" "i"))
  ]
  "(!pic30_isa32_target())"
  "mov #%1,%0\;mov #%y1,%d0"
  [
    (set_attr "type" "def")
  ]
)

(define_insn "mov<mode>_gen_16"
  [
    (set 
      (match_operand:QUQ31 0 "pic30_move_operand" "=rR<>, r, r,   Q, r, TU,r, TU,R, w,TU,w,r,w,R,w,R")
      (match_operand:QUQ31 1 "pic30_move_operand" " r,    R, <>,  r, Q, r,TU, R,TU, w,w,TU,w,r,w,R,R"))
  ]
  ""
  "*
   {
     const char *patterns[] = {
       \"mov.d %1,%0\",
       \"mov.d %1,%0\",
       \"mov.d %1,%0\",
       \"mov.w %1,%0\;mov.w %d1,%Q0\",
       \"mov.w %1,%0\;mov.w %Q1,%d0\",               /* =r,Q */
       \"push.d %1\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop.d %0\",
       \"push %I1\;push %D1\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop %P0\;pop %p0\",
       \"clr %0\;add %0\",
       \"push %m1L\;push %m1H\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop %m0H\;pop %m0L\",
       \"mov %m1L,%0\;mov %m1H,%d0\",
       \"mov %1,%m0L\;mov %d1,%m0H\",
       \"push %m1H\;push %m1L\;pop %I0\;pop %D0\",
       \"push %I1\;push %D1\;pop %m0H\;pop %m0L\",
       \"mov %I1,%I0\;mov %D1,%D0\"
     };

     const char *psrd_psrd_patterns[] = {
       \"mov.d %1,%0\",
       \"mov.w %1,%0\;mov.w %Q1,%d0\",
       \"mov.w %1,%0\;mov.w %1,%d0\",
       \"mov.w %1,%0\;mov.w %d1,%Q0\",
       \"mov.w %1,%0\;mov.w %Q1,%d0\",               /* =r,Q */
       \"push.d %1\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop.d %0\",
       \"push %I1\;push %D1\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop %P0\;pop %p0\",
       \"clr %0\;add %0\",
       \"push %m1L\;push %m1H\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop %m0H\;pop %m0L\",
       \"mov %m1L,%0\;mov %m1H,%d0\",
       \"mov %1,%m0L\;mov %d1,%m0H\",
       \"push %m1H\;push %m1L\;pop %I0\;pop %D0\",
       \"push %I1\;push %D1\;pop %m0H\;pop %m0L\",
       \"mov %I1,%I0\;mov %D1,%D0\"
     };


     /* check for early clobber */
     int src_regno,dst_regno;
     int overlap;

     dst_regno = REGNO(operands[0]);

     switch (which_alternative) {
       default: /* no overlap possible */
                break;
       case 4: {
         /* mem  plus reg, */
         rtx inner = XEXP(operands[1],0);
         src_regno = REGNO(XEXP(inner,0));
         overlap = src_regno-dst_regno;
         switch (overlap) {
           default: /* no overlap */
             break;
           case 0:  /* src == dst */
             return \"mov.w %Q1,%d0\;mov.w %1,%0\";
             break;
         }
         break;
       }
     }
     if ((pic30_psrd_psrd_errata(operands[0],operands[1]) == 0) &&
         (pic30_psrd_psrd_errata_movd(operands[0],operands[1]) == 0)) {
       return patterns[which_alternative];
     } else {
       if (which_alternative == 1) {
         // check for overlap
         src_regno = REGNO(XEXP(operands[1],0));
         overlap = src_regno-dst_regno;
         if (overlap == 0) {
           return \"mov.w %Q1,%d0\;mov.w %1,%0\";
         }
       }
       return psrd_psrd_patterns[which_alternative];
     }
   }"
  [
    (set_attr "type" "def,defuse,defuse,use,use,etc,def,use,use,etc,etc,etc,def,etc,use,use,use")
  ]
)

(define_insn "mov<mode>_gen_APSV_16"
  [
    (set 
      (match_operand:QUQ31 0 "pic30_move_operand" "=rR<>, r,   Q, r, TU,r, TU,R, w,TU,w,r,w,R,w,R")
      (match_operand:QUQ31 1 "pic30_move_operand" " r,    R<>, r, Q, r,TU, R,TU, w,w,TU,w,r,w,R,R"))
    (use (reg:HI PSVPAG))
  ]
  "(pic30_psrd_psrd_errata(operands[0],operands[1]) == 0) &&
   (pic30_psrd_psrd_errata_movd(operands[0],operands[1]) == 0)"
  "*
   {
     const char *patterns[] = {
       \"mov.d %1,%0\",
       \"mov.d %1,%0\",
       \"mov.w %1,%0\;mov.w %d1,%Q0\",
       \"mov.w %1,%0\;mov.w %Q1,%d0\",               /* =r,Q */
       \"push.d %1\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop.d %0\",
       \"push %I1\;push %D1\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop %P0\;pop %p0\",
       \"clr %0\;add %0\",
       \"push %m1L\;push %m1H\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop %m0H\;pop %m0L\",
       \"mov %m1L,%0\;mov %m1H,%d0\",
       \"mov %1,%m0L\;mov %d1,%m0H\",
       \"push %m1H\;push %m1L\;pop %I0\;pop %D0\",
       \"push %I1\;push %D1\;pop %m0H\;pop %m0L\",
       \"mov %I1,%I0\;mov %D1,%D0\"
     };

     /* check for early clobber */
     int src_regno,dst_regno;
     int overlap;

     dst_regno = REGNO(operands[0]);

     switch (which_alternative) {
       default: /* no overlap possible */
                break;
       case 3: {
         /* mem  plus reg, */
         rtx inner = XEXP(operands[1],0);
         src_regno = REGNO(XEXP(inner,0));
         overlap = src_regno-dst_regno;
         switch (overlap) {
           default: /* no overlap */
             break;
           case 0:  /* src == dst */
             return \"mov.w %Q1,%d0\;mov.w %1,%0\";
             break;
         }
         break;
       }
     }
     return patterns[which_alternative];
   }"
  [
    (set_attr "type" "def,defuse,use,use,etc,def,use,use,etc,etc,etc,def,etc,use,use,use")
  ]
)

(define_insn "mov<mode>_psrd_psrd_movd_errata_gen_16"
  [
    (set 
      (match_operand:QUQ31 0 "pic30_move_operand" "=rR<>, r,&r, Q, r, TU,r, TU,R, w,TU,w,r,w,R,w")
      (match_operand:QUQ31 1 "pic30_move_operand" " r,    R,<>, r, Q, r,TU, R,TU, w,w,TU,w,r,w,R"))
  ]
  "(pic30_psrd_psrd_errata_movd(operands[0],operands[1]) == 1)"
  "*
   {
     const char *patterns[] = {
       \"mov.d %1,%0\",
       \"mov %1,%0\;mov %Q1,%d0\",                    /* =r,R */
       \"mov %1,%0\;mov %1,%d0\",
       \"mov.w %1,%0\;mov.w %d1,%Q0\",
       \"mov.w %1,%0\;mov.w %Q1,%d0\",                /* =r,Q */
       \"push.d %1\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop.d %0\",
       \"push %I1\;push %D1\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop %P0\;pop %p0\",
       \"clr %0\;add %0\",
       \"push %m1L\;push %m1H\;pop %0+2\;pop %0\",
       \"push %1\;push %1+2\;pop %m0H\;pop %m0L\",
       \"mov %m1L,%0\;mov %m1H,%d0\",
       \"mov %1,%m0L\;mov %d1,%m0H\",
       \"push %m1H\;push %m1L\;pop %I0\;pop %D0\",
       \"push %I1\;push %D1\;pop %m0H\;pop %m0L\"
     };

     /* check for early clobber */
     int src_regno,dst_regno;
     int overlap;

     /* mem ( reg */
     rtx inner = operands[1];

     dst_regno = REGNO(operands[0]);


     switch (which_alternative) {
       default: /* no overlap possible */
                break;
       case 4: 
         /* mem ( plus (reg */
         inner = XEXP(operands[1],0);
         /* FALLSTHROUGH */
       case 1: {
         src_regno = REGNO(XEXP(inner,0));
         overlap = src_regno-dst_regno;
         switch (overlap) {
           default: /* no overlap */
             break;
           case 0:  /* src == dst */
             return \"mov.w %Q1,%d0\;mov.w %1,%0\";    
             break;
         }
         break;
       }
     }
     return patterns[which_alternative];
   }"
  [
    (set_attr "type" "def,defuse,defuse,use,use,etc,def,use,use,etc,etc,etc,def,etc,use,use")
  ]
)

(define_expand "mov<mode>_16"
  [(set (match_operand:QUQ31 0 "pic30_move_d_operand" "")
        (match_operand:QUQ31 1 "pic30_move_d_operand" ""))]
  "(!pic30_isa32_target())"
  "
{ int result = pic30_emit_move_sequence(operands, <MODE>mode);

  if (result > 0) DONE;
  
  if (immediate_operand(operands[1],VOIDmode)) {
    rtx reg = operands[0];

    if (!pic30_register_operand(operands[0],<MODE>mode)) {
      reg = gen_reg_rtx(<MODE>mode);
      emit(
        gen_mov<mode>_rimm_16(reg,operands[1])
      );
      emit_move_insn(operands[0], reg);
      DONE;
    }
  }

  /* we may need a clobber here */
  if (pic30_move_d_operand(operands[1],<MODE>mode)) {
    emit(
      gen_mov<mode>_gen_16(operands[0], operands[1])
    );
    DONE;
  }
 
}")

;; *** add/sub
;  16-bit
(define_insn "add<mode>3_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=r")
        (plus:QUQ15
           (match_operand:QUQ15 1 "pic30_register_operand" "r")
           (match_operand:QUQ15 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add %1,%2,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

(define_insn "sub<mode>3_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=r")
        (minus:QUQ15
           (match_operand:QUQ15 1 "pic30_register_operand" "r")
           (match_operand:QUQ15 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sub %1,%2,%0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

;  signed saturating
(define_insn "ssadd<mode>3_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (ss_plus:QUQ15
           (match_operand:QUQ15 1 "pic30_register_operand" "r")
           (match_operand:QUQ15 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "add %1,%2,%0\;bra nov,.L1_%=\;mov #0x7FFF,%0\;btsc %2,#15\;com %0,%0\n.L1_%=:\;"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

(define_insn "sssub<mode>3_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (ss_minus:QUQ15
           (match_operand:QUQ15 1 "pic30_register_operand" "r")
           (match_operand:QUQ15 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "sub %1,%2,%0\;bra nov,.L1_%=\;mov #0x7FFF,%0\;btss %2,#15\;com %0,%0\n.L1_%=:\;"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

;  unsigned saturating - our unsigned mode really is the same width as signed
(define_insn "usadd<mode>3_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (us_plus:QUQ15
           (match_operand:QUQ15 1 "pic30_register_operand" "r")
           (match_operand:QUQ15 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add %1,%2,%0\;btsc _SR,#2\;mov #0x7FFF,%0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

(define_insn "ussub<mode>3_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (us_minus:QUQ15
           (match_operand:QUQ15 1 "pic30_register_operand" "r")
           (match_operand:QUQ15 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sub %1,%2,%0\;btsc _SR,#3\;clr %0"
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

;  32-bit
(define_insn "add<mode>3_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (plus:QUQ31
           (match_operand:QUQ31 1 "pic30_register_operand" "r")
           (match_operand:QUQ31 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add %1,%2,%0\;addc %d1,%d2,%d0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

(define_insn "sub<mode>3_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (minus:QUQ31
           (match_operand:QUQ31 1 "pic30_register_operand" "r")
           (match_operand:QUQ31 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sub %1,%2,%0\;subb %d1,%d2,%d0"
  [
    (set_attr "cc" "math")
    (set_attr "type" "etc")
  ]
)

;  signed saturating
(define_insn "ssadd<mode>3_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=&r")
        (ss_plus:QUQ31
           (match_operand:QUQ31 1 "pic30_register_operand" "r")
           (match_operand:QUQ31 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   return \"add %1,%2,%0\;\"
          \"addc %d1,%d2,%d0\;\"
          \"bra nov,.L1_%=\;\"
          \"setm %0\;\"
          \"mov #0x7FFF,%d0\;\"
          \"btst.c %d2,#15\;\"
          \"bra nc,.L1_%=\;\"
          \"com %d0,%d0\;\"
          \"com %0,%0\n\"
          \".L1_%=:\";
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

(define_insn "sssub<mode>3_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=&r")
        (ss_minus:QUQ31
           (match_operand:QUQ31 1 "pic30_register_operand" "r")
           (match_operand:QUQ31 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   return \"sub %1,%2,%0\;\"
          \"subb %d1,%d2,%d0\;\"
          \"bra nov,.L1_%=\;\"
          \"setm %0\;\"
          \"mov #0x7FFF,%d0\;\"
          \"btst.c %d2,#15\;\"
          \"bra c,.L1_%=\;\"
          \"com %d0,%d0\;\"
          \"com %0,%0\n\"
          \".L1_%=:\";
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

;  unsigned saturating - our unsigned mode really is the same width as signed
(define_insn "usadd<mode>3_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=&r")
        (us_plus:QUQ31
           (match_operand:QUQ31 1 "pic30_register_operand" "r")
           (match_operand:QUQ31 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   return \"add %1,%2,%0\;\"
          \"addc %d1,%d2,%d0\;\"
          \"bra nov,.L1_%=\;\"
          \"setm %0\;\"
          \"mov #0x7FFF,%d0\n\"
          \".L1_%=:\";
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

(define_insn "ussub<mode>3_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=&r")
        (us_minus:QUQ31
           (match_operand:QUQ31 1 "pic30_register_operand" "r")
           (match_operand:QUQ31 2 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   return \"sub %1,%2,%0\;\"
          \"subb %d1,%d2,%d0\;\"
          \"btsc _SR,#3\;\"
          \"mul.uu %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "etc")
  ]
)

;; *** multiply
;  16-bit

/*
 * do not know if this will be successful
 */
(define_insn "mul<mode>3_helper_trunc_dsp_A_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (mult:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand" " za")
          (match_operand:QUQ15 2 "pic30_register_operand" " za")))
   (clobber (reg:SQ A_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_truncation) || 
    (pic30_fp_round_p() == pic30_fastest))"
  "mpy %1,%2,A\;sac A,#0,%0"
)

(define_insn "mul<mode>3_helper_trunc_dsp_B_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (mult:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand" " za")
          (match_operand:QUQ15 2 "pic30_register_operand" " za")))
   (clobber (reg:SQ B_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_truncation) || 
    (pic30_fp_round_p() == pic30_fastest))"
  "mpy %1,%2,B\;sac B,#0,%0"
)

(define_insn "mul<mode>3_helper_rnd_dsp_A_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " za")
          (match_operand:QUQ15 2 "pic30_register_operand" " za")))
   (clobber (reg:SQ A_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_convergent) ||
    (pic30_fp_round_p() == pic30_conventional))"
  "mpy %1,%2,A\;sac.r A,#0,%0"
)

(define_insn "mul<mode>3_helper_rnd_dsp_B_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " za")
          (match_operand:QUQ15 2 "pic30_register_operand" " za")))
   (clobber (reg:SQ B_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_convergent) ||
    (pic30_fp_round_p() == pic30_conventional))"
  "mpy %1,%2,B\;sac.r B,#0,%0"
)
/* If it is, we should remove the middle alternative here */

(define_insn "mul<mode>3_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=rR<>,r,QST")
        (mult:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand" " r,za,r")
          (match_operand:QUQ15 2 "pic30_register_operand" " r,za,r")))
   (clobber (match_scratch:SQ  3                         "=&r,&w,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   { 
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       static const char *patterns[] = {
         \"mul.ss %1,%2,%3\;sl %3,%3\;rlc %d3,%0\",
         \"mpy %1,%2,%3\;sac %3,#0,%0\",
         \"mul.ss %1,%2,%3\;sl %3,%3\;rlc %d3,%d3\;mov %d3,%0\"
       };

       return patterns[which_alternative];
     } else if (pic30_fp_round_p() == pic30_conventional) {
       static const char *patterns[] = {
         \"mul.ss %1,%2,%3\;\"
             \"sl %3,%3\;\"
             \"rlc %d3,%d3\;\"
             \"sl %3,[w15]\;\"
             \"addc %d3,#0,%0\",

         \"mpy %1,%2,%3\;\"
             \"sac.r %3,#0,%0\",

         \"mul.ss %1,%2,%3\;\"
             \"sl %3,%3\;\"
             \"rlc %d3,%d3\;\"
             \"sl %3,[w15]\;\"
             \"addc %d3,#0,%d3\;\"
             \"mov %d3,%0\"
       };

       return patterns[which_alternative];
     } else if (pic30_fp_round_p() == pic30_convergent) {
       /* convergent rounding, doing it without branches appears to be
        * simpler. And quicker, especially on EP parts;
        *
        * For rounding, we do the add and if the remainer is 0 we mask of the
        * low bit.  Ie:
        *  res rem
        *  xx1 100 will round to xx1+1
        *  xx0 100 will round to xx0+1 (xx1) then mask back to (xx0) 
        *
        * Listen very carefully, I shall say this only wance
        */
       static const char *patterns[] = {
         \"mul.ss %1,%2,%3\;\"     /* multipy */
           \"sl %3,%3\;\"          /* shift 32-bit result left to reposition */
           \"rlc %d3,%d3\;\"       /*   binary point */
           \"sl %3,%3\;\"          /* round shift remainder up, like convgnt */
           \"bra nc,.L1_%=\;\"     /* if no carry, finish */
           \"btsc _SR,#1\;\"       /* if round word == 0 */
           \"btst.c %d3,#0\;\"     /* mov low result bit to C */
                                   /*  1 + 1 = 0 (even) */
           \"addc %d3,#0,%d3\n\"
           \".L1_%=:\;\"
           \"mov %d3,%0\",

         \"mpy %1,%2,%0\;\"        /* ensure CORCONbits.US == 0? */
           \"sac.r %3,#0,%0\",

         \"mul.ss %1,%2,%3\;\"
           \"sl %3,%3\;\"
           \"rlc %d3,%d3\;\"
           \"sl %3,%3\;\"          /* round */
           \"bra nc,.L1_%=\;\"     /* if no carry, finish */
           \"btsc _SR,#1\;\"       /* if round word == 0 */
           \"btst.c %d3,#0\;\"     /* mov low result bit to C */
           \"addc %d3,#0,%d3\;\"
           \".L1_%=:\;\"
           \"mov %d3,%0\" 
       };

       return patterns[which_alternative];
     } else return \"Cannot generate pattern\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "mul<mode>3_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand" "=rRQST<>")
        (mult:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand" "=r")
          (match_operand:QUQ15 2 "pic30_register_operand" "=r")))]
  "(!pic30_isa32_target())"
  "
  {  rtx ra,rb;

     /* for no fp inline big patterns; lets fail and call the routine */
     if (!pic30_fp_inline_p() && (pic30_fp_round_p() != pic30_truncation) &&
         (pic30_fp_round_p() != pic30_fastest))
       FAIL;
 
     /* set round mode and saturation mode 
      *   the optimizer should discard the things we don't use - ie
      *   an accumulator is not used or the saturation is already correct
      */
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode)) 
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode)) 
       rb = force_reg(<MODE>mode, rb);
     emit(
       gen_mul<mode>3_helper_16(operands[0],ra,rb)
     );
     DONE;
  }"
)

/*
 * do not know if this will be successful
 */
(define_insn "ssmul<mode>3_helper_trunc_dsp_A_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (ss_mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " za")
          (match_operand:QUQ15 2 "pic30_register_operand" " za")))
   (clobber (reg:SQ A_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_truncation) ||
    (pic30_fp_round_p() == pic30_fastest))"
  "mpy %1,%2,A\;sac A,#0,%0"
)

(define_insn "ssmul<mode>3_helper_trunc_dsp_B_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (ss_mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " za")
          (match_operand:QUQ15 2 "pic30_register_operand" " za")))
   (clobber (reg:SQ B_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_truncation) ||
    (pic30_fp_round_p() == pic30_fastest))"
  "mpy %1,%2,B\;sac B,#0,%0"
)

(define_insn "ssmul<mode>3_helper_rnd_dsp_A_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (ss_mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " za")
          (match_operand:QUQ15 2 "pic30_register_operand" " za")))
   (clobber (reg:SQ A_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_convergent) ||
    (pic30_fp_round_p() == pic30_conventional))"
  "mpy %1,%2,A\;sac.r A,#0,%0"
)

(define_insn "ssmul<mode>3_helper_rnd_dsp_B_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand"       "=r")
        (ss_mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " za")
          (match_operand:QUQ15 2 "pic30_register_operand" " za")))
   (clobber (reg:SQ B_REGNO))
   (use (reg:HI CORCON))
  ]
  "((pic30_fp_round_p() == pic30_convergent) ||
    (pic30_fp_round_p() == pic30_conventional))"
  "mpy %1,%2,B\;sac.r B,#0,%0"
)
/* If it is, we should remove the middle alternative here */

(define_insn "ssmul<mode>3_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand" "=&r,r,RQST<>")
        (ss_mult:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand" " r,za,r")
          (match_operand:QUQ15 2 "pic30_register_operand" " r,za,r")))
   (clobber (match_scratch:SQ  3                         "=&r,w,&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   { 
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       static const char *patterns[] = {
         \"mul.ss %1,%2,%3\;\"
           \"sl %3,%3\;\"
           \"rlc %d3,%0\;\"
           \"xor %1,%2,%3\;\"
           \"bra n,.L1_%=\;\"
           \"btsc %0,#15\;\"
           \"com %0,%0\n\"
           \".L1_%=:\",

         \"mpy %1,%2,%3\;sac %3,#0,%0\",  /* ensure CORCONbits.US == 0? */

         \"mul.ss %1,%2,%3\;\"
           \"sl %3,%3\;\"
           \"rlc %d3,%d3\;\"
           \"xor %1,%2,%3\;\"
           \"bra n,.L1_%=\;\"
           \"btsc %d3,#15\;\"
           \"com %d3,%d3\n\"
           \".L1_%=:\;\"
           \"mov %d3,%0\"
       };

       return patterns[which_alternative];
     } else if (pic30_fp_round_p() == pic30_conventional) {
       static const char *patterns[] = {
         \"mul.ss %1,%2,%3\;\"
           \"sl %3,%3\;\"
           \"rlc %d3,%d3\;\"
           \"sl %3,[w15]\;\"
           \"addc %d3,#0,%0\;\"
           \"xor %1,%2,%3\;\"
           \"bra n,.L1_%=\;\"
           \"btsc %0,#15\;\"
           \"com %0,%0\n\"
           \".L1_%=:\",

         \"mpy %1,%2,%0\;sac.r %3,#0,%0\",  /* ensure CORCONbits.US == 0? */

         \"mul.ss %1,%2,%3\;\"
           \"sl %3,%3\;\"
           \"rlc %d3,%d3\;\"
           \"sl %3,[w15]\;\"
           \"addc %d3,#0,%d3\;\"
           \"xor %1,%2,%3\;\"
           \"bra n,.L1_%=\;\"
           \"btsc %d3,#15\;\"
           \"com %d3,%d3\n\"
           \".L1_%=:\;\"
           \"mov %d3,%0\"
       };

       return patterns[which_alternative];
     } else if (pic30_fp_round_p() == pic30_convergent) {
       static const char *patterns[] = {
         \"mul.ss %1,%2,%3\;\"                    /* multiply */
           \"sl %3,%3\;\"                         /* fix binary point */
           \"rlc %d3,%0\;\"
           \"sl %3,%3\;\"                         /* move round into carry */
           \"bra nc,.L1_%=\;\"                    /* if no carry, finish */
           \"btsc _SR,#1\;\"                      /* if round word == 0 */
           \"btst.c %0,#0\;\"                     /* mov low result bit to C */
                                                  /*  1 + 1 = 0 (even) */
           \"addc %0,#0,%0\n\"                    /* add carry */
           \".L1_%=:\;\"
           \"xor %1,%2,%3\;\"
           \"bra n,.L2_%=\;\"
           \"btsc %0,#15\;\"
           \"com %0,%0\n\"
           \".L2_%=:\",

         \"mpy %1,%2,%0\;sac.r %3,#0,%0\",  /* ensure CORCONbits.US == 0? */

         \"mul.ss %1,%2,%3\;\"
           \"sl %3,%3\;\"
           \"rlc %d3,%d3\;\"
           \"sl %3,%3\;\"                         /* round */
           \"bra nc,.L1_%=\;\"                    /* if no carry, finish */
           \"btsc _SR,#1\;\"                      /* if round word == 0 */
           \"btst.c %d3,#0\;\"                    /* mov low result bit to C */
                                                  /*  1 + 1 = 0 (even) */
           \"addc %d3,#0,%d3\n\"
           \".L1_%=:\;\"
           \"xor %1,%2,%3\;\"
           \"bra n,.L2_%=\;\"
           \"btsc %d3,#15\;\"
           \"com %d3,%d3\n\"
           \".L2_%=:\;\"
           \"mov %d3,%0\"
       };

       return patterns[which_alternative];
     } else return \"Cannot generate pattern\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "ssmul<mode>3_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand" "=rRQST<>")
        (ss_mult:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand" "=r")
          (match_operand:QUQ15 2 "pic30_register_operand" "=r")))]
  "(!pic30_isa32_target())"
  "
  {  rtx ra,rb;

     /* for no fp inline big patterns; lets fail and call the routine */
     if (!pic30_fp_inline_p() && (pic30_fp_round_p() != pic30_truncation) &&
         (pic30_fp_round_p() != pic30_fastest))
       FAIL;

     /* set round mode and saturation mode
      *   the optimizer should discard the things we don't use - ie
      *   an accumulator is not used or the saturation is already correct
      */
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode)) 
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode)) 
       rb = force_reg(<MODE>mode, rb);
     emit(
       gen_ssmul<mode>3_helper_16(operands[0],ra,rb)
     );
     DONE;
  }"
)

(define_expand "usmul<mode>3_16"
  [(set (match_operand:QUQ15 0 "pic30_move_operand" "=rRQST<>")
        (us_mult:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" "=r")
          (match_operand:QUQ15 2 "pic30_register_operand" "=r")))]
  "(!pic30_isa32_target())"
  "
  {  rtx ra,rb;

     /* for no fp inline big patterns; lets fail and call the routine */
     if (!pic30_fp_inline_p() && (pic30_fp_round_p() != pic30_truncation) &&
         (pic30_fp_round_p() != pic30_fastest))
       FAIL;

     /* set round mode and saturation mode
      *   the optimizer should discard the things we don't use - ie
      *   an accumulator is not used or the saturation is already correct
      */

     /* unsigned multiply on this device cannot over-flow
        so we don't need to do saturation - translate it to the unsaturating
        signed multiply */
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode))
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode))
       rb = force_reg(<MODE>mode, rb);
     emit(
       gen_mul<mode>3_helper_16(operands[0],ra,rb)
     );
     DONE;
  }"
)

;; *** multiply
;  32-bit
; handled by helper routines in libfx

;; *** divide
;  16-bit

(define_insn "udiv<mode>3_helper_16"
  [(set (match_operand:UQ15 0 "pic30_register_operand"    "=a,?b,??&e")
        (udiv:UQ15 
          (match_operand:UQ15 1 "pic30_register_operand"   "r, r,  r")
          (match_operand:UQ15 2 "pic30_ereg_operand"       "e, e,  e")))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     rtx w0 = gen_rtx_REG(HImode, WR0_REGNO);
     rtx w1 = gen_rtx_REG(HImode, WR1_REGNO);
     static char buffer[512];
     char *c = buffer;
     const char *repeat_errata_push = pic30_repeat_errata_push_init();
     const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       switch (which_alternative) {
         case 0:  /*
                  ** wm/wn -> w0
                  */
                  if (pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w1,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"mov [--w15],w1\",
                           repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"mov w0,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"mov w0,%%0\;\"
                            \"mov [--w15],w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"mov w0,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov.d w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"mov w0,%%0\;\"
                            \"mov.d [--w15],w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_conventional) {
       switch (which_alternative) {
         case 0:  /*
                  ** wm/wn -> w0
                  */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* all follow sim. flow */
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"            /* compare 2*remainder */
                            \"addc %%0,#0,%%0\",        /* inc if carry */
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;        
                  } else {
                    sprintf(c,\"mov w1,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"
                            \"addc %%0,#0,%%0\;\"
                            \"mov [--w15],w1\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,w1\;\"
                            \"mov w0,%%0\;\"
                            \"cp w1,%%2\;\"
                            \"addc %%0,#0,%%0\;\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,w1\;\"
                            \"mov w0,%%0\;\"
                            \"cp w1,%%2\;\"
                            \"addc %%0,#0,%%0\;\"
                            \"mov [--w15],w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"
                            \"mov w0,%%0\;\"
                            \"addc %%0,#0,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov.d w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,w1\;\"
                            \"mov w0,%%0\;\"
                            \"cp w1,%%2\;\"
                            \"addc %%0,#0,%%0\;\" 
                            \"mov.d [--w15],w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_convergent) {
       switch (which_alternative) {
         case 0:  /*
                  ** wm/wn -> w0
                  */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* convergent follows this
                                                        form */
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"           /* cp divisor w/ 2*rem */
                            \"btsc _SR,#1\;\"        /* if zero ... */
                            \"btst.c w0,#0\;\"       /*   copy low bit to c */
                                                     /*   ie if low bit == 0 */
                                                     /*      don't add */
                            \"addc.w w0,#0,%%0\",     /* add carry */
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w1,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"
                            \"addc.w w0,#0,%%0\;\" 
                            \"mov [--w15],w1\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"
                            \"addc.w w0,#0,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w0,[w15++]\;\"
                            \"sl %%2,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,w1\;\"
                            \"cp w1,[--w15]\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"
                            \"addc.w w0,#0,%%0\;\" 
                            \"mov [--w15],w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 2 : /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"
                            \"addc.w w0,#0,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov.d w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"
                            \"addc.w w0,#0,%%0\;\" 
                            \"mov.d [--w15],w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         default: gcc_assert(0);
       }
     }
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

; check for == and return 0x8000 in all cases (if sign is positive then 
;   its an valid invalid answer)

(define_insn "div<mode>3_helper_16"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"  "=a,?b,??&e")
        (div:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand"   "r, r,  r")
          (match_operand:QUQ15 2 "pic30_ereg_operand"       "e, e,  e")))
   (match_operand:HI           3 "pic30_register_operand"   "e, e,  e")
   (clobber (match_scratch:HI  4                          "=&e,&e, &e"))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     rtx w0 = gen_rtx_REG(HImode, WR0_REGNO);
     rtx w1 = gen_rtx_REG(HImode, WR1_REGNO);
     static char buffer[512];
     char *c = buffer;
     const char *repeat_errata_push = pic30_repeat_errata_push_init();
     const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"com w0,%%4\;\"              /* complement in case
                                                             of negate */
                            \"ff1r w1,w1\;\"             /* C = w1 == 0 */
                            \"btsc %%3,#15\;\"            /* if negative, neg */
                            \"addc %%4,#0,%%0\n\"
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"mov w1,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"com w0,%%4\;\"              /* complement in case
                                                             of negate */
                            \"ff1r w1,w1\;\"             /* C = w1 == 0 */
                            \"btsc %%3,#15\;\"          /* if negative, neg */
                            \"addc %%4,#0,%%0\;\"
                            \"mov [--w15],w1\n\"
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"com w0,%%4\;\"              /* complement in case
                                                             of negate */
                            \"ff1r w1,w1\;\"             /* C = w1 == 0 */
                            \"btsc %%3,#15\;\"            /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"mov w0,%%0\n\"
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"mov w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"com w0,%%4\;\"              /* complement in case
                                                             of negate */
                            \"ff1r w1,w1\;\"             /* C = w1 == 0 */
                            \"btsc %%3,#15\;\"            /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"mov w0,%%0\;\"
                            \"mov [--w15],w0\n\"
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 2 : /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"com w0,%%4\;\"              /* complement in case
                                                             of negate */
                            \"ff1r w1,w1\;\"             /* C = w1 == 0 */
                            \"btsc %%3,#15\;\"            /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"mov w0,%%0\n\"
                            \".LE%%=\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"mov.d w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"com w0,%%4\;\"              /* complement in case
                                                             of negate */
                            \"ff1r w1,w1\;\"             /* C = w1 == 0 */
                            \"btsc %%3,#15\;\"            /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"mov w0,%%0\;\"
                            \"mov.d [--w15],w0\n\"
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_conventional) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* all follow . flow */
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\" 
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc w0,#0,%%0\n\"       /* add in round */
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"mov w1,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc w0,#0,%%0\;\"       /* add in round */
                            \"mov [--w15],w1\n\"
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc w0,#0,%%0\n\"       /* add in round */
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"mov w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc w0,#0,%%0\;\"       /* add in round */
                            \"mov [--w15],w0\n\"
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc w0,#0,%%0\n\"       /* add in round */
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"mov.d w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc w0,#0,%%0\;\"       /* add in round */
                            \"mov.d [--w15],w0\n\"
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_convergent) {
       switch (which_alternative) {
         case 0:  /*
                  ** wm/wn -> w0
                  */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* convergent follows this
                                                        form */
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                      /*   ie if low bit == 0 */
                                                      /*      don't add */
                            \"rlc w0,w0\;\"           /* put R in low bit */

                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc.w w0,#0,%%0\n\"     /* add carry */
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"mov w1,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                      /*   ie if low bit == 0 */
                                                      /*      don't add */
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc.w w0,#0,%%0\;\"     /* add carry */
                            \"mov [--w15],w1\n\"
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                      /*   ie if low bit == 0 */
                                                      /*      don't add */
                            \"rlc w0,w0\;\"           /* put R in low bit */

                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"sl w1,w1\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc.w w0,#0,%%0\n\"     /* add carry */
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"mov w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                      /*   ie if low bit == 0 */
                                                      /*      don't add */
                            \"rlc w0,w0\;\"           /* put R in low bit */

                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc.w w0,#0,%%0\;\"     /* add carry */
                            \"mov [--w15],w0\n\"
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                      /*   ie if low bit == 0 */
                                                      /*      don't add */
                            \"rlc w0,w0\;\"           /* put R in low bit */

                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc.w w0,#0,%%0\n\"     /* add carry */
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"sub %%1,%%2,[w15]\;\"
                            \"mov #0x8000,%%0\;\"
                            \"bra z,.LE%%=\;\"
                            \"mov.d w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                      /*   ie if low bit == 0 */
                                                      /*      don't add */
                            \"rlc w0,w0\;\"           /* put R in low bit */

                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"sl w1,w1\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc.w w0,#0,%%0\;\"     /* add carry */
                            \"mov.d [--w15],w0\n\"
                            \".LE%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         default: gcc_assert(0);
       }
     }
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "usatdiv<mode>3_helper_16"
  [(set (match_operand:UQ15 0 "pic30_register_operand"    "=a,?b,??&e")
        (us_div:UQ15 
          (match_operand:UQ15 1 "pic30_register_operand"   "r, r,  r")
          (match_operand:UQ15 2 "pic30_ereg_operand"       "e, e,  e")))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     rtx w0 = gen_rtx_REG(HImode, WR0_REGNO);
     rtx w1 = gen_rtx_REG(HImode, WR1_REGNO);
     static char buffer[512];
     char *c = buffer;
     const char *repeat_errata_push = pic30_repeat_errata_push_init();
     const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w1,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"mov [--w15],w1\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"mov w0,%%0\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"mov w0,%%0\;\"
                            \"mov [--w15],w0\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } 
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"mov w0,%%0\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov.d w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"mov w0,%%0\;\"
                            \"mov.d [--w15],w0\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_conventional) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* all follow sim. flow */
                    sprintf(c,\"%s\" 
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"            /* compare 2*remainder */
                            \"addc %%0,#0,%%0\n\"           /* inc if carry */
                            \".OV%%=:\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w1,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"
                            \"addc %%0,#0,%%0\n\"
                            \".OV%%=:\;\"
                            \"mov [--w15],w1\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    sprintf(c,\"%s\" 
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,w1\;\"
                            \"mov w0,%%0\;\"
                            \"cp w1,%%2\;\"
                            \"addc %%0,#0,%%0\n\"
                            \".OV%%=:\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,w1\;\"
                            \"mov w0,%%0\;\"
                            \"cp w1,%%2\;\"
                            \"addc %%0,#0,%%0\n\"
                            \".OV%%=:\;\"
                            \"mov [--w15],w0\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"%s\" 
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,w1\;\"
                            \"mov w0,%%0\;\"
                            \"cp w1,%%2\;\"
                            \"addc %%0,#0,%%0\n\"
                            \".OV%%=:\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov.d w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,w1\;\"
                            \"mov w0,%%0\;\"
                            \"cp w1,%%2\;\"
                            \"addc %%0,#0,%%0\n\" 
                            \".OV%%=:\;\"
                            \"mov.d [--w15],w0\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_convergent) {
       switch (which_alternative) {
         case 0:  /*
                  ** wm/wn -> w0
                  */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* convergent follows this
                                                        form */
                    sprintf(c,\"%s\" 
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"            /* cp divisor w/ 2*rem */
                            \"btsc _SR,#1\;\"         /* if zero ... */
                            \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                      /*   ie if low bit == 0 */
                                                      /*      don't add */
                            \"addc.w w0,#0,%%0\n\"     /* add carry */
                            \".OV%%=:\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w1,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"
                            \"addc.w w0,#0,%%0\n\" 
                            \".OV%%=:\;\"
                            \"mov [--w15],w1\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    sprintf(c,\"%s\" 
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"
                            \"addc.w w0,#0,%%0\n\"
                            \".OV%%=:\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"
                            \"addc.w w0,#0,%%0\n\" 
                            \".OV%%=:\;\"
                            \"mov [--w15],w0\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"%s\" 
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"
                            \"addc.w w0,#0,%%0\n\"
                            \".OV%%=:\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov.d w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,w1\;\"
                            \"cp w1,%%2\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"
                            \"addc.w w0,#0,%%0\n\" 
                            \".OV%%=:\;\"
                            \"mov.d [--w15],w0\;\"
                            \"btsc _SR,#2\;\"
                            \"mov #0x7FFF,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         default: gcc_assert(0);
       }
     }
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_insn "ssatdiv<mode>3_helper_16"
  [(set (match_operand:Q15    0 "pic30_register_operand"  "=a,?b,??&e")
        (ss_div:Q15 
          (match_operand:Q15  1 "pic30_register_operand"   "r, r,  r")
          (match_operand:Q15  2 "pic30_ereg_operand"       "e, e,  e")))
   (match_operand:HI          3 "pic30_register_operand"   "e, e,  e")
   (clobber (match_scratch:HI 4                          "=&e,&e, &e"))
   (clobber (reg:HI RCOUNT))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     rtx w0 = gen_rtx_REG(HImode, WR0_REGNO);
     rtx w1 = gen_rtx_REG(HImode, WR1_REGNO);
     static char buffer[512];
     char *c = buffer;
     const char *repeat_errata_push = pic30_repeat_errata_push_init();
     const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra nov,.NOV%%=\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"setm w1\n\"                /* force C == 0 */
                            \".NOV%%=:\;\"
                            \"ff1r w1,%%4\;\"             /* C = w1 == 0 */
                            \"com w0,%%4\;\"              /* complement in case
                                                             of negate */
                            \"btsc %%3,#15\;\"            /* if negative, neg */
                            \"addc %%4,#0,w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w1,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra nov,.NOV%%=\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"setm w1\n\"              /* force C == 0 */
                            \".NOV%%=:\;\"
                            \"ff1r w1,%%4\;\"           /* C = w1 == 0 */
                            \"com w0,%%4\;\"            /* complement in case
                                                           of negate */
                            \"btsc %%3,#15\;\"          /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"mov [--w15],w1\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra nov,.NOV%%=\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"setm w1\n\"                /* force C == 0 */
                            \".NOV%%=:\;\"
                            \"ff1r w1,%%4\;\"             /* C = w1 == 0 */
                            \"com w0,%%4\;\"              /* complement in case
                                                             of negate */
                            \"btsc %%3,#15\;\"            /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"mov  w0,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra nov,.NOV%%=\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"setm w1\n\"                /* force C == 0 */
                            \".NOV%%=:\;\"
                            \"ff1r w1,%%4\;\"             /* C = w1 == 0 */
                            \"com w0,%%4\;\"              /* complement in case
                                                             of negate */
                            \"btsc %%3,#15\;\"            /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"mov w0,%%0\;\"
                            \"mov [--w15],w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } 
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra nov,.NOV%%=\;\"
                            \"mov #0x7FFF,%%0\"
                            \"setm w1\n\"                /* force C == 0 */
                            \".NOV%%=:\;\"
                            \"ff1r w1,%%4\;\"             /* C = w1 == 0 */
                            \"com w0,%%4\;\"              /* complement in case
                                                             of negate */
                            \"btsc %%3,#15\;\"            /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"mov w0,%%0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov.d w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra nov,.NOV%%=\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"setm w1\n\"                /* force C == 0 */
                            \".NOV%%=:\;\"
                            \"ff1r w1,%%4\;\"             /* C = w1 == 0 */
                            \"com w0,%%4\;\"              /* complement in case
                                                             of negate */
                            \"btsc %%3,#15\;\"            /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"mov w0,%%0\;\"
                            \"mov.d [--w15],w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_conventional) {
       switch (which_alternative) {
         case 0:  /*
                ** wm/wn -> w0
                */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* all follow sim. flow */
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"rlc w0,w0\;\"           /* put R in low bit */

                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc w0,#0,%%0\;\"       /* add in round */
                            \"bra nov,.NOV%%=\n\"
                            \".OV%%=:\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"btsc %%3,#15\;\"
                            \"com %%0,%%0\n\"
                            \".NOV%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w1,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"      /* compare 2*remainder */
                            \"btss _SR,#0\;\"       /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"rlc w0,w0\;\"         /* put R in low bit */
                            \"ff1r w1,%%4\;\"        /* C = w1 == 0 */ 
                            \"com w0,%%4\;\"         /* complement in case
                                                       of negate */
                            \"btsc %%3,#15\;\"       /* if negative, neg */ 
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc w0,#0,%%0\;\"       /* add in round */
                            \"bra nov,.NOV%%=\n\"
                            \".OV%%=:\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"btsc %%3,#15\;\"
                            \"com %%0,%%0\n\"
                            \".NOV%%=:\;\"
                            \"mov [--w15],w1\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */ 
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */ 
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc w0,#0,%%0\;\"       /* add in round */
                            \"bra nov,.NOV%%=\n\"
                            \".OV%%=:\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"btsc %%3,#15\;\"
                            \"com %%0,%%0\n\"
                            \".NOV%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */ 
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */ 
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc w0,#0,%%0\;\"       /* add in round */
                            \"bra nov,.NOV%%=\n\"
                            \".OV%%=:\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"btsc %%3,#15\;\"
                            \"com %%0,%%0\n\"
                            \".NOV%%=:\;\"
                            \"mov [--w15],w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */ 
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */ 
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc w0,#0,%%0\;\"       /* add in round */
                            \"bra nov,.NOV%%=\n\"
                            \".OV%%=:\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"btsc %%3,#15\;\"
                            \"com %%0,%%0\n\"
                            \".NOV%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov.d w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */ 
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */ 
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc w0,#0,%%0\;\"       /* add in round */
                            \"bra nov,.NOV%%=\n\"
                            \".OV%%=:\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"btsc %%3,#15\;\"
                            \"com %%0,%%0\n\"
                            \".NOV%%=:\;\"
                            \"mov.d [--w15],w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         default: gcc_assert(0);
       }
     } else if (pic30_fp_round_p() == pic30_convergent) {
       switch (which_alternative) {
         case 0:  /*
                  ** wm/wn -> w0
                  */
                  if (pic30_dead_or_set_p(insn, w1)) {
                                                     /* convergent follows this
                                                        form */
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                      /*   ie if low bit == 0 */
                                                      /*      don't add */
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */ 
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */ 
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc.w w0,#0,%%0\;\"     /* add carry */
                            \"bra nov,.NOV%%=\n\"
                            \".OV%%=:\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"btsc %%3,#15\;\"
                            \"com %%0,%%0\n\"
                            \".NOV%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w1,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"      /* compare 2*remainder */
                            \"btss _SR,#0\;\"       /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"      /*   copy low bit to c */
                                                    /*   ie if low bit == 0 */
                                                    /*      don't add */
                            \"rlc w0,w0\;\"         /* put R in low bit */
                            \"ff1r w1,%%4\;\"        /* C = w1 == 0 */ 
                            \"com w0,%%4\;\"         /* complement in case
                                                       of negate */
                            \"btsc %%3,#15\;\"       /* if negative, neg */ 
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"      /* get sign in carry */
                            \"rrc w0,w0\;\"         /* div by 2 again */
                            \"addc.w w0,#0,%%0\;\" 
                            \"bra nov,.NOV%%=\n\"
                            \".OV%%=:\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"btsc %%3,#15\;\"
                            \"com %%0,%%0\n\"
                            \".NOV%%=:\;\"
                            \"mov [--w15],w1\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 1:  /*
                  ** wm/wn -> w1
                  */
                  if (pic30_dead_or_set_p(insn, w0)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                      /*   ie if low bit == 0 */
                                                      /*      don't add */
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */ 
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */ 
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc.w w0,#0,%%0\;\"
                            \"bra nov,.NOV%%=\n\"
                            \".OV%%=:\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"btsc %%3,#15\;\"
                            \"com %%0,%%0\n\"
                            \".NOV%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                      /*   ie if low bit == 0 */
                                                      /*      don't add */
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */ 
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */ 
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc.w w0,#0,%%0\;\" 
                            \"bra nov,.NOV%%=\n\"
                            \".OV%%=:\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"btsc %%3,#15\;\"
                            \"com %%0,%%0\n\"
                            \".NOV%%=:\;\"
                            \"mov [--w15],w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         case 2:  /*
                  ** wm/wn -> we
                  */
                  if (pic30_dead_or_set_p(insn, w0) &&
                      pic30_dead_or_set_p(insn, w1)) {
                    sprintf(c,\"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"bra ov,.OV%%=\;\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                      /*   ie if low bit == 0 */
                                                      /*      don't add */
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */ 
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */ 
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc.w w0,#0,%%0\;\"
                            \"bra nov,.NOV%%=\n\"
                            \".OV%%=:\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"btsc %%3,#15\;\"
                            \"com %%0,%%0\n\"
                            \".NOV%%=:\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  } else {
                    sprintf(c,\"mov.d w0,[w15++]\;\"
                            \"%s\"
                            \"repeat #__TARGET_DIVIDE_CYCLES\;\"
                            \"divf %%1,%%2\;\"
                            \"%s\"
                            \"sl w1,%%4\;\"
                            \"sub %%4,%%2,%%4\;\"        /* compare 2*remainder */
                            \"btss _SR,#0\;\"         /* carry set, use new val*/
                            \"mov %%4,w1\;\"
                            \"btsc _SR,#1\;\"
                            \"btst.c w0,#0\;\"        /*   copy low bit to c */
                                                      /*   ie if low bit == 0 */
                                                      /*      don't add */
                            \"rlc w0,w0\;\"           /* put R in low bit */
                            \"bra ov,.OV%%=\;\"
                            \"ff1r w1,%%4\;\"          /* C = w1 == 0 */ 
                            \"com w0,%%4\;\"           /* complement in case
                                                         of negate */
                            \"btsc %%3,#15\;\"         /* if negative, neg */ 
                            \"addc %%4,#0,w0\;\"
                            \"rlc %%3,[w15]\;\"        /* get sign in carry */
                            \"rrc w0,w0\;\"           /* div by 2 again */
                            \"addc.w w0,#0,%%0\;\" 
                            \"bra nov,.NOV%%=\n\"
                            \".OV%%=:\;\"
                            \"mov #0x7FFF,%%0\;\"
                            \"btsc %%3,#15\;\"
                            \"com %%0,%%0\n\"
                            \".NOV%%=:\;\"
                            \"mov.d [--w15],w0\",
                            repeat_errata_push,repeat_errata_pop);
                    return buffer;
                  }
         default: gcc_assert(0);
       }
     }
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
    (set_attr "type" "def")
  ]
)

(define_expand "udiv<mode>3_16"
  [(set (match_operand:UQ15 0 "pic30_register_operand"    "=a,?b,??e")
        (udiv:UQ15
          (match_operand:UQ15 1 "pic30_register_operand"   "r, r,  r")
          (match_operand:UQ15 2 "pic30_ereg_operand"       "e, e,  e")))]
  "(!pic30_isa32_target())"
  "
  {  rtx ra,rb;

     /* divf is not valid on 24F targets */
     if (!pic30_dsp_target()) FAIL;
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode))
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode))
       rb = force_reg(<MODE>mode, rb);
     emit(
       gen_udiv<mode>3_helper_16(operands[0],ra,rb)
     );
     DONE;
  }"
)

(define_expand "div<mode>3_16"
  [(set (match_operand:Q15 0 "pic30_register_operand"    "=a,?b,??e")
        (div:Q15
          (match_operand:Q15 1 "pic30_register_operand"   "r, r,  r")
          (match_operand:Q15 2 "pic30_ereg_operand"       "e, e,  e")))]
  "(!pic30_isa32_target())"
  "
  {  rtx ra,rb;
     rtx ura,urb;
     rtx sign, hi1,hi2;

     /* divf is not valid on 24F targets */
     if (!pic30_dsp_target()) FAIL;
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode))
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode))
       rb = force_reg(<MODE>mode, rb);
     sign = gen_reg_rtx(HImode);
     hi1 = gen_rtx_SUBREG(HImode, ra, 0);
     hi2 = gen_rtx_SUBREG(HImode, rb, 0);
     emit(
       gen_xorhi3_16(sign,hi1,hi2)
     );
     ura = gen_reg_rtx(<MODE>mode);
     urb = gen_reg_rtx(<MODE>mode);
     emit(
       gen_abs<mode>2_16(ura,ra)
     );
     emit(
       gen_abs<mode>2_16(urb,rb)
     );
     emit(
       gen_div<mode>3_helper_16(operands[0],ura,urb,sign)
     );
     DONE;
  }"
)

(define_insn "sssaturate<mode>_16"
  [(set (match_operand:QUQ15    0 "pic30_register_operand" "=&r")
        (unspec:QUQ15 [
           (match_operand:QUQ15 1 "pic30_register_operand" "0")
           (match_operand:HI    2 "pic30_register_operand" "r")
         ] UNSPEC_SATURATE)
   ) 
   (clobber (match_scratch:HI 3                        "=&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return \"xor %1,%2,%3\;\"    /* test result sign with expected */
          \"btss %3,#15\;\"
          \"bra .SAT%=\;\"        /* if they are the same we are done */
          \"mov #0x8000,%0\;\"  /* otherwise saturate to the expected sign */
          \".SAT%=:\";
  "
)

(define_expand "usdiv<mode>3_16"
  [(set (match_operand:UQ15 0 "pic30_register_operand"    "=a,?b,??e")
        (us_div:UQ15
          (match_operand:UQ15 1 "pic30_register_operand"   "r, r,  r")
          (match_operand:UQ15 2 "pic30_ereg_operand"       "e, e,  e")))]
  "(!pic30_isa32_target())"
  "
  {  rtx ra,rb;

     /* divf is not valid on 24F targets */
     if (!pic30_dsp_target()) FAIL;
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode))
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode))
       rb = force_reg(<MODE>mode, rb);
     emit(
       gen_usatdiv<mode>3_helper_16(operands[0],ra,rb)
     );
     DONE;
  }"
)

(define_expand "ssdiv<mode>3_16"
  [(set (match_operand:Q15    0 "pic30_register_operand"  "=a,?b,??e")
        (ss_div:Q15
          (match_operand:Q15  1 "pic30_register_operand"   "r, r,  r")
          (match_operand:Q15  2 "pic30_ereg_operand"       "e, e,  e")))
   (clobber (match_scratch:HI 3                           "=r, r,  r"))
  ]
  "(!pic30_isa32_target())"
  "
  {  rtx ra,rb;
     rtx ura,urb;
     rtx sign,hi1,hi2;

     /* divf is not valid on 24F targets */
     if (!pic30_dsp_target()) FAIL;
     ra = operands[1];
     rb = operands[2];
     if (!pic30_register_operand(ra,<MODE>mode))
       ra = force_reg(<MODE>mode, ra);
     if (!pic30_register_operand(rb,<MODE>mode))
       rb = force_reg(<MODE>mode, rb);
     hi1 = gen_rtx_SUBREG(HImode, ra, 0);
     hi2 = gen_rtx_SUBREG(HImode, rb, 0);
     sign = gen_reg_rtx(HImode);
     emit(
       gen_xorhi3_16(sign,hi1, hi2)
     );
     ura = gen_reg_rtx(<MODE>mode);
     urb = gen_reg_rtx(<MODE>mode);
     emit(
       gen_abs<mode>2_16(ura,ra)
     );
     emit(
       gen_abs<mode>2_16(urb,rb)
     );
     emit(
       gen_ssatdiv<mode>3_helper_16(operands[0],ura,urb,sign)
     );
     DONE;
  }"
)

;; *** multiply
;  32-bit
; handled by helper routines in libfx

;; *** conversions
; 16-bit

;  [sat]fract[uns]mn2
;
;    These patterns handle modes m,n where m,n are any combination of
;      fixed-point, floating-point, [un]signed integer
;  
;    One of the modes is fixed.
;

; integer (IMODE) modes
;  from Q15

(define_insn "fract<mode>qi2_helper_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (fract_convert:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>qi2_convergent_16"
  [(set (match_operand:QI      0 "pic30_register_operand" "=&r")
        (fract_convert:QI
          (match_operand:QUQ15   1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:QUQ15 2                           "=r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>qi2_16"
  [(set (match_operand:QI    0 "pic30_register_operand" "=r")
        (fract_convert:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>qi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>qi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>hi2_helper_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (fract_convert:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>hi2_convergent_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (fract_convert:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>hi2_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (fract_convert:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>hi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>hi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>si2_helper_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (fract_convert:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%d0\;asr %1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr %0\;asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>si2_convergent_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (fract_convert:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\" /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>si2_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (fract_convert:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>si2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>si2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>di2_helper_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (fract_convert:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%q0\;asr %1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>di2_convergent_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (fract_convert:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>di2_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (fract_convert:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
        ((pic30_fp_round_p() == pic30_convergent) ||
         (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>di2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>di2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; from Q31

(define_insn "fract<mode>qi2_helper_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (fract_convert:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>qi2_convergent_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (fract_convert:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>qi2_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=r")
        (fract_convert:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>qi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>qi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>hi2_helper_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (fract_convert:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>hi2_convergent_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (fract_convert:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>hi2_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (fract_convert:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>hi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>hi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>si2_helper_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (fract_convert:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%d0\;asr %d1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>si2_convergent_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (fract_convert:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>si2_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (fract_convert:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>si2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>si2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>di2_helper_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (fract_convert:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%q0\;asr %d1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>di2_convergent_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (fract_convert:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>di2_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (fract_convert:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_convergent)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fract<mode>di2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fract<mode>di2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; from ACC

(define_insn "fract<mode>qi2_helper_16"
  [(set (match_operand:QI    0 "pic30_register_operand"   "=&r,r")
        (fract_convert:QI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "r,w")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc.b %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>qi2_convergent_16"
  [(set (match_operand:QI     0 "pic30_register_operand" "=&r")
        (fract_convert:QI
          (match_operand:ACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI 2                           "=&r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return \"sl %d1,%2\;\"
          \"rlc.b %t1,%0\;\"
          \"sl %2,%2\;\"
          \"ior %2,%1,[w15]\;\"
          \"btsc _SR,#0\;\"   /* carry clear? */
          \"bset _SR,#0\;\"
          \"btsc _SR,#1\;\"
          \"btst.c %0,#0\;\"
          \"addc.b %0,#0,%0\";

  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>qi2_16"
  [(set (match_operand:QI    0 "pic30_register_operand"    "=r")
        (fract_convert:QI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "rw")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>qi2_convergent_16(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>qi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>hi2_helper_16"
  [(set (match_operand:HI    0 "pic30_register_operand"   "=&r,r")
        (fract_convert:HI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "r,w")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"se %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\;\";
       else 
         return \"mov %m1U,%0\;\"
                \"se %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"se %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"se %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>hi2_convergent_16"
  [(set (match_operand:HI     0 "pic30_register_operand" "=&r")
        (fract_convert:HI
          (match_operand:ACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI 2                           "=&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return \"se %t1,%0\;\"
          \"sl %d1,%2\;\"
          \"rlc %0,%0\;\"
          \"sl %2,%2\;\"
          \"ior %2,%1,[w15]\;\"
          \"btsc _SR,#0\;\"   /* carry clear? */
          \"bset _SR,#0\;\"
          \"btsc _SR,#1\;\"
          \"btst.c %0,#0\;\"
          \"addc %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>hi2_16"
  [(set (match_operand:HI    0 "pic30_register_operand"    "=r")
        (fract_convert:HI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "rw")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>hi2_convergent_16(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>hi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>qi2_helper_16"
  [(set (match_operand:QI     0 "pic30_register_operand"   "=&r,r")
        (fract_convert:QI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "r,w")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc.b %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>qi2_convergent_16"
  [(set (match_operand:QI      0 "pic30_register_operand" "=&r")
        (fract_convert:QI
          (match_operand:UACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI 2                           "=&r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sl %d1,%2\;rlc %t1,%0\;sl %2,%2\;ior %2,%1,[w15]\;btst.c %d1,#14\;btsc _SR,#1\;bclr _SR,#0\;addc %0,#0,%0"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>qi2_16"
  [(set (match_operand:QI     0 "pic30_register_operand"    "=r")
        (fract_convert:QI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "rw")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>qi2_convergent_16(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>qi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fract<mode>hi2_helper_16"
  [(set (match_operand:HI     0 "pic30_register_operand"   "=&r,r")
        (fract_convert:HI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "r,w")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"ze %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"ze %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"ze %t0,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"ze %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fract<mode>hi2_convergent_16"
  [(set (match_operand:HI      0 "pic30_register_operand" "=&r")
        (fract_convert:HI
          (match_operand:UACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI  2                           "=&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return \"ze %t1,%0\;\"
          \"sl %d1,%2\;\"
          \"rlc %0,%0\;\"
          \"sl %2,%2\;\"
          \"ior %2,%1,[w15]\;\"
          \"btsc _SR,#0\;\"   /* carry clear? */
          \"bset _SR,#0\;\"
          \"btsc _SR,#1\;\"
          \"btst.c %0,#0\;\"
          \"addc %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fract<mode>hi2_16"
  [(set (match_operand:HI     0 "pic30_register_operand"    "=r")
        (fract_convert:HI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "rw")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>hi2_convergent_16(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fract<mode>hi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; To SI and DI done by function only

; to Q15

(define_insn "fractqi<mode>2_16"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q15
          (match_operand:QI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov #0x8000,%0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fracthi<mode>2_16"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q15
          (match_operand:HI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {
      return 
             \"cp0  %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractsi<mode>2_16"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q15
          (match_operand:SI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"    /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractdi<mode>2_16"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q15
          (match_operand:DI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"    /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractqi<mode>2_16"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ15
          (match_operand:QI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"  /* assume ~1 */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fracthi<mode>2_16"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ15
          (match_operand:HI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
      return 
             \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"  /* assume ~1 */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractsi<mode>2_16"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ15
          (match_operand:SI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"    /* assume ~1 */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractdi<mode>2_16"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ15
          (match_operand:DI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"    /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to Q31

(define_insn "fractqi<mode>2_16"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q31
          (match_operand:QI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fracthi<mode>2_16"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q31
          (match_operand:HI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractsi<mode>2_16"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q31
          (match_operand:SI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractdi<mode>2_16"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (fract_convert:Q31
          (match_operand:DI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractqi<mode>2_16"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ31
          (match_operand:QI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"      /* if zero */
             \"mul.uu %0,#0,%0\";   /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fracthi<mode>2_16"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ31
          (match_operand:HI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"      /* if zero */
             \"mul.uu %0,#0,%0\";   /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractsi<mode>2_16"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ31
          (match_operand:SI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"       /* if zero */
             \"mul.uu %0,#0,%0\";    /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractdi<mode>2_16"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (fract_convert:UQ31
          (match_operand:DI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"       /* if zero */
             \"mul.uu %0,#0,%0\";    /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to ACC

(define_insn "fractqi<mode>2_16"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:ACC
          (match_operand:QI 1 "pic30_register_operand"    "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov.b %1,%t0\;\"     /* copy integer portion into upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fracthi<mode>2_16"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:ACC
          (match_operand:HI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractsi<mode>2_16"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:ACC
          (match_operand:SI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractdi<mode>2_16"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:ACC
          (match_operand:DI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractqi<mode>2_16"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:UACC
          (match_operand:QI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov.b %1,%t0\;\"     /* copy integer portion into upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fracthi<mode>2_16"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:UACC
          (match_operand:HI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractsi<mode>2_16"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:UACC
          (match_operand:SI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractdi<mode>2_16"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (fract_convert:UACC
          (match_operand:DI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; unsigned integer (IMODE) modes
;  from Q15

(define_insn "fractuns<mode>qi2_helper_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       return \"asr %1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>qi2_convergent_16"
  [(set (match_operand:QI      0 "pic30_register_operand" "=&r")
        (unsigned_fract_convert:QI
          (match_operand:QUQ15   1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:QUQ15 2                           "=r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>qi2_16"
  [(set (match_operand:QI    0 "pic30_register_operand" "=r")
        (unsigned_fract_convert:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>qi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>qi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>hi2_helper_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>hi2_convergent_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>hi2_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>hi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>hi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>si2_helper_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%d0\;asr %1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr %0\;asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>si2_convergent_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\" /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>si2_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>si2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>si2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>di2_helper_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%q0\;asr %1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>di2_convergent_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>di2_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
        ((pic30_fp_round_p() == pic30_convergent) ||
         (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>di2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>di2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; from Q31

(define_insn "fractuns<mode>qi2_helper_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>qi2_convergent_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>qi2_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>qi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>qi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>hi2_helper_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>hi2_convergent_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>hi2_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>hi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>hi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>si2_helper_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%d0\;asr %d1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>si2_convergent_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>si2_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>si2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>si2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>di2_helper_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%q0\;asr %d1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>di2_convergent_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>di2_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (unsigned_fract_convert:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_convergent)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractuns<mode>di2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fractuns<mode>di2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; from ACC

(define_insn "fractuns<mode>qi2_helper_16"
  [(set (match_operand:QI    0 "pic30_register_operand"   "=&r,r")
        (unsigned_fract_convert:QI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "r,w")))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H\;\"
                \"inc %0,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc.b %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>qi2_convergent_16"
  [(set (match_operand:QI     0 "pic30_register_operand" "=&r")
        (unsigned_fract_convert:QI
          (match_operand:ACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI 2                           "=&r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return \"sl %d1,%2\;\"
          \"rlc.b %t1,%0\;\"
          \"sl %2,%2\;\"
          \"ior %2,%1,[w15]\;\"
          \"btsc _SR,#0\;\"   /* carry clear? */
          \"bset _SR,#0\;\"
          \"btsc _SR,#1\;\"
          \"btst.c %0,#0\;\"
          \"addc.b %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>qi2_16"
  [(set (match_operand:QI    0 "pic30_register_operand"    "=r")
        (unsigned_fract_convert:QI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "rw")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>qi2_convergent_16(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>qi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>hi2_helper_16"
  [(set (match_operand:HI    0 "pic30_register_operand"   "=&r,r")
        (unsigned_fract_convert:HI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "r,w")))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"ze %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"ze %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H\;\"
                \"inc %0,%0\;\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"ze %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"ze %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>hi2_convergent_16"
  [(set (match_operand:HI     0 "pic30_register_operand" "=&r")
        (unsigned_fract_convert:HI
          (match_operand:ACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI 2                           "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return \"ze %t1,%0\;\"
          \"sl %d1,%2\;\"
          \"rlc %0,%0\;\"
          \"sl %2,%2\;\"
          \"ior %2,%1,[w15]\;\"
          \"btsc _SR,#0\;\"   /* carry clear? */
          \"bset _SR,#0\;\"
          \"btsc _SR,#1\;\"
          \"btst.c %0,#0\;\"
          \"addc %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>hi2_16"
  [(set (match_operand:HI    0 "pic30_register_operand"    "=r")
        (unsigned_fract_convert:HI
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" "rw")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>hi2_convergent_16(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>hi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>qi2_helper_16"
  [(set (match_operand:QI     0 "pic30_register_operand"   "=&r,r")
        (unsigned_fract_convert:QI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "r,w")))
   (clobber (reg:CC CC_REG))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H\;\"
                \"inc %0,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"sl %d1,[w15]\;\"
                \"rlc %t1,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc.b %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>qi2_convergent_16"
  [(set (match_operand:QI      0 "pic30_register_operand" "=&r")
        (unsigned_fract_convert:QI
          (match_operand:UACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI 2                           "=&r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sl %d1,%2\;rlc %t1,%0\;sl %2,%2\;ior %2,%1,[w15]\;btst.c %d1,#14\;btsc _SR,#1\;bclr _SR,#0\;addc %0,#0,%0"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>qi2_16"
  [(set (match_operand:QI     0 "pic30_register_operand"    "=r")
        (unsigned_fract_convert:QI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "rw")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>qi2_convergent_16(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>qi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractuns<mode>hi2_helper_16"
  [(set (match_operand:HI     0 "pic30_register_operand"   "=&r,r")
        (unsigned_fract_convert:HI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "r,w")))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits; remember with 9.31 the lowest order  */
       /*  integer bit is in the 15th bit of 2nd word */
       if (which_alternative == 0)
         return \"ze %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\;\";
       else 
         return \"mov %m1U,%0\;\"
                \"ze %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H\;\"
                \"inc %0,%0\;\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       if (which_alternative == 0)
         return \"ze %t1,%0\;\"
                \"sl %d1,[w15]\;\"
                \"rlc %0,%0\;\"
                \"btst.c %d1,#14\;\"
                \"addc %0,#0,%0\";
       else 
         return \"mov %m1U,%0\;\"
                \"ze %0,%0\;\"
                \"sl %0,%0\;\"
                \"btsc %m1H,#15\;\"
                \"inc %0,%0\;\"
                \"btsc %m1H,#14\;\"
                \"inc %0,%0\;\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractuns<mode>hi2_convergent_16"
  [(set (match_operand:HI      0 "pic30_register_operand" "=&r")
        (unsigned_fract_convert:HI
          (match_operand:UACC  1 "pic30_register_operand"   "r")))
   (clobber (match_scratch:HI  2                           "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return \"ze %t1,%0\;\"
          \"sl %d1,%2\;\"
          \"rlc %0,%0\;\"
          \"sl %2,%2\;\"
          \"ior %2,%1,[w15]\;\"
          \"btsc _SR,#0\;\"   /* carry clear? */
          \"bset _SR,#0\;\"
          \"btsc _SR,#1\;\"
          \"btst.c %0,#0\;\"
          \"addc %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "fractuns<mode>hi2_16"
  [(set (match_operand:HI     0 "pic30_register_operand"    "=r")
        (unsigned_fract_convert:HI
          (match_operand:UACC 1 "pic30_accum_or_reg_operand" "rw")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      if (!pic30_accum_or_reg_operand(r1,<MODE>mode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>hi2_convergent_16(r0,r1)
      );
    } else {
      if (!pic30_register_operand(r1,VOIDmode)) {
        r1 = force_reg(<MODE>mode, r1);
      }
      emit(
        gen_fractuns<mode>hi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; To SI and DI done by function only

; to Q15

(define_insn "fractunsqi<mode>2_16"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q15
          (match_operand:QI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov #0x8000,%0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunshi<mode>2_16"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q15
          (match_operand:HI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {
      return 
             \"cp0  %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunssi<mode>2_16"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q15
          (match_operand:SI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"    /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsdi<mode>2_16"
  [(set (match_operand:Q15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q15
          (match_operand:DI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"    /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsqi<mode>2_16"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ15
          (match_operand:QI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"  /* assume ~1 */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunshi<mode>2_16"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ15
          (match_operand:HI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
      return 
             \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"  /* assume ~1 */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunssi<mode>2_16"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ15
          (match_operand:SI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"    /* assume ~1 */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsdi<mode>2_16"
  [(set (match_operand:UQ15  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ15
          (match_operand:DI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%0\;\"    /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %0\";             /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to Q31

(define_insn "fractunsqi<mode>2_16"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q31
          (match_operand:QI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunshi<mode>2_16"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q31
          (match_operand:HI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunssi<mode>2_16"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q31
          (match_operand:SI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsdi<mode>2_16"
  [(set (match_operand:Q31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:Q31
          (match_operand:DI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsqi<mode>2_16"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ31
          (match_operand:QI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"      /* if zero */
             \"mul.uu %0,#0,%0\";   /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunshi<mode>2_16"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ31
          (match_operand:HI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"      /* if zero */
             \"mul.uu %0,#0,%0\";   /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunssi<mode>2_16"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ31
          (match_operand:SI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"       /* if zero */
             \"mul.uu %0,#0,%0\";    /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsdi<mode>2_16"
  [(set (match_operand:UQ31  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UQ31
          (match_operand:DI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"setm %0\;\"
             \"btsc _SR,#1\;\"       /* if zero */
             \"mul.uu %0,#0,%0\";    /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to ACC

(define_insn "fractunsqi<mode>2_16"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:ACC
          (match_operand:QI 1 "pic30_register_operand"    "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov.b %1,%t0\;\"     /* copy integer portion into upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunshi<mode>2_16"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:ACC
          (match_operand:HI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunssi<mode>2_16"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:ACC
          (match_operand:SI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsdi<mode>2_16"
  [(set (match_operand:ACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:ACC
          (match_operand:DI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsqi<mode>2_16"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UACC
          (match_operand:QI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov.b %1,%t0\;\"     /* copy integer portion into upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunshi<mode>2_16"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UACC
          (match_operand:HI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunssi<mode>2_16"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UACC
          (match_operand:SI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "fractunsdi<mode>2_16"
  [(set (match_operand:UACC  0 "pic30_register_operand"  "=&r")
        (unsigned_fract_convert:UACC
          (match_operand:DI  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {  
      return 
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov %1,%t0\;\"       /* copy low integer portion to upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)


;; conversions back and forth to floating point or double will be done by
;;  out of line functions only

; conversions to and from fractional types
;; awkward - we can only move through one iterator, these are all 
;;   coppies of each other with a different source mode

(define_insn "fractsq<mode>2_helper_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:SQ 1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"
             \"addc %d1,#0,%0\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "fractsq<mode>2_convergent_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:SQ   1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_expand "fractsq<mode>2_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (fract_convert:QUQ15
          (match_operand:SQ  1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractsq<mode>2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fractsq<mode>2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractusq<mode>2_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:USQ 1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"
             \"addc %d1,#0,%0\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "fractusq<mode>2_convergent_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:USQ  1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_expand "fractusq<mode>2_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (fract_convert:QUQ15
          (match_operand:USQ 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractusq<mode>2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fractusq<mode>2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fracttq<mode>2_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:TQ  1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"
             \"addc %d1,#0,%0\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "fracttq<mode>2_convergent_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:TQ  1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_expand "fracttq<mode>2_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (fract_convert:QUQ15
          (match_operand:TQ 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fracttq<mode>2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fracttq<mode>2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractutq<mode>2_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:UTQ 1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"
             \"addc %d1,#0,%0\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "fractutq<mode>2_convergent_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:UTQ  1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_expand "fractutq<mode>2_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (fract_convert:QUQ15
          (match_operand:UTQ 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fracttq<mode>2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fracttq<mode>2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractdq<mode>2_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:DQ  1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"
             \"addc %d1,#0,%0\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "fractdq<mode>2_convergent_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:DQ   1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
)

(define_expand "fractdq<mode>2_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (fract_convert:QUQ15
          (match_operand:DQ  1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractdq<mode>2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fractdq<mode>2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractudq<mode>2_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:UDQ 1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"
             \"addc %d1,#0,%0\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "fractudq<mode>2_convergent_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (fract_convert:QUQ15
          (match_operand:UDQ  1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "math")
  ]
)

(define_expand "fractudq<mode>2_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (fract_convert:QUQ15
          (match_operand:UDQ 1 "pic30_register_operand"   "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_fractudq<mode>2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_fractudq<mode>2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "fractqq<mode>2_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (fract_convert:QUQ31
          (match_operand:QQ  1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "fractuqq<mode>2_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (fract_convert:QUQ31
          (match_operand:UQQ 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "fracthq<mode>2_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (fract_convert:QUQ31
          (match_operand:HQ 1 "pic30_register_operand"   "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "fractuhq<mode>2_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (fract_convert:QUQ31
          (match_operand:UHQ 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

; conversions between signed/unsigned 'self'

(define_insn "fractqquqq2_16"
  [(set (match_operand:UQQ  0 "register_operand" "=r")
       (unsigned_fract_convert:UQQ
         (match_operand:QQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractuqqqq2_16"
  [(set (match_operand:QQ    0 "register_operand" "=r")
       (fract_convert:QQ
         (match_operand:UQQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fracthquhq2_16"
  [(set (match_operand:UHQ  0 "register_operand" "=r")
       (unsigned_fract_convert:UHQ
         (match_operand:HQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractuhqhq2_16"
  [(set (match_operand:HQ    0 "register_operand" "=r")
       (fract_convert:HQ
         (match_operand:UHQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractsqusq2_16"
  [(set (match_operand:USQ  0 "register_operand" "=r")
       (unsigned_fract_convert:USQ
         (match_operand:SQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractusqsq2_16"
  [(set (match_operand:SQ    0 "register_operand" "=r")
       (fract_convert:SQ
         (match_operand:USQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractdqudq2_16"
  [(set (match_operand:UDQ  0 "register_operand" "=r")
       (unsigned_fract_convert:UDQ
         (match_operand:DQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractudqdq2_16"
  [(set (match_operand:DQ    0 "register_operand" "=r")
       (fract_convert:DQ
         (match_operand:UDQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fracttqutq2_16"
  [(set (match_operand:UTQ  0 "register_operand" "=r")
       (unsigned_fract_convert:UTQ
         (match_operand:TQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractutqtq2_16"
  [(set (match_operand:TQ    0 "register_operand" "=r")
       (fract_convert:TQ
         (match_operand:UTQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fracthauha2_16"
  [(set (match_operand:UHA  0 "register_operand" "=r")
       (unsigned_fract_convert:UHA
         (match_operand:HA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractuhaha2_16"
  [(set (match_operand:HA    0 "register_operand" "=r")
       (fract_convert:HA
         (match_operand:UHA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractsausa2_16"
  [(set (match_operand:USA  0 "register_operand" "=r")
       (unsigned_fract_convert:USA
         (match_operand:SA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractusasa2_16"
  [(set (match_operand:SA    0 "register_operand" "=r")
       (fract_convert:SA
         (match_operand:USA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractdauda2_16"
  [(set (match_operand:UDA  0 "register_operand" "=r")
       (unsigned_fract_convert:UDA
         (match_operand:DA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractudada2_16"
  [(set (match_operand:DA    0 "register_operand" "=r")
       (fract_convert:DA
         (match_operand:UDA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fracttauta2_16"
  [(set (match_operand:UTA  0 "register_operand" "=r")
       (unsigned_fract_convert:UTA
         (match_operand:TA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "fractutata2_16"
  [(set (match_operand:TA    0 "register_operand" "=r")
       (fract_convert:TA
         (match_operand:UTA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

; saturating conversions
;   not all conversions saturate (but we seem to need them all)
;   many of these are copies of the "non-saturating" versions

(define_insn "satfract<mode>qi2_helper_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (sat_fract:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>qi2_convergent_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (sat_fract:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>qi2_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=r")
        (sat_fract:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>qi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>qi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfract<mode>hi2_helper_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (sat_fract:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>hi2_convergent_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (sat_fract:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>hi2_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (sat_fract:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>hi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>hi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfract<mode>si2_helper_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (sat_fract:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%d0\;asr %1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>si2_convergent_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (sat_fract:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\" /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>si2_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (sat_fract:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>si2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>si2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfract<mode>di2_helper_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (sat_fract:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%q0\;asr %1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>di2_convergent_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (sat_fract:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>di2_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (sat_fract:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
        ((pic30_fp_round_p() == pic30_convergent) ||
         (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>di2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>di2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; from Q31

(define_insn "satfract<mode>qi2_helper_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (sat_fract:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>qi2_convergent_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (sat_fract:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>qi2_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=r")
        (sat_fract:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>qi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>qi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfract<mode>hi2_helper_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (sat_fract:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>hi2_convergent_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (sat_fract:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>hi2_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (sat_fract:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>hi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>hi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfract<mode>si2_helper_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (sat_fract:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%d0\;asr %d1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>si2_convergent_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (sat_fract:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>si2_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (sat_fract:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>si2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>si2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfract<mode>di2_helper_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (sat_fract:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%q0\;asr %d1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfract<mode>di2_convergent_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (sat_fract:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfract<mode>di2_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (sat_fract:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_convergent)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfract<mode>di2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfract<mode>di2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; to Q15

(define_insn "satfractqi<mode>2_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:QI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov  #0x8000,%0\;\" /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfracthi<mode>2_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:HI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {
      return \"cp0  %1\;\"         /* compare input with 0 */
             \"mov  #0x8000,%0\;\" /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractsi<mode>2_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:SI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return \"subr %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subbr %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov  #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"        /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"     /*   load .99... */
             \"btsc _SR,#1\;\"        /* if zero */
             \"clr %0\";              /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractdi<mode>2_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:DI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return \"subr %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subbr %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subbr %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subbr %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov  #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"        /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"     /*   load .99... */
             \"btsc _SR,#1\;\"        /* if zero */
             \"clr %0\";              /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to Q31

(define_insn "satfractqi<mode>2_16"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ31
          (match_operand:QI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfracthi<mode>2_16"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ31
          (match_operand:HI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractsi<mode>2_16"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ31
          (match_operand:SI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractdi<mode>2_16"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ31
          (match_operand:DI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to ACC

; cannot saturate
(define_insn "satfractqi<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_register_operand"  "=&r")
        (sat_fract:AUACC
          (match_operand:QI  1 "pic30_register_operand"    "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
   {
      return
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov.b %1,%t0\;\"     /* copy integer portion into upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunsqi<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:AUACC
          (match_operand:QI  1 "pic30_register_operand"    "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
  {
      return
             \"mul.uu %0,#0,%0\;\"  /* clear low bits */
             \"mov.b %1,%t0\;\"     /* copy integer portion into upper byte */
             \"asr.b %t0,%t0\;\"    /* shift it into position */
             \"rrc %d0,%d0\";
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; the rest are function only

; unsigned

(define_insn "satfractuns<mode>qi2_helper_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>qi2_convergent_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>qi2_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractuns<mode>qi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractuns<mode>qi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractuns<mode>hi2_helper_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>hi2_convergent_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>hi2_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:HI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractuns<mode>hi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractuns<mode>hi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractuns<mode>si2_helper_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%d0\;asr %1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>si2_convergent_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\" /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>si2_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:SI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractuns<mode>si2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractuns<mode>si2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractuns<mode>di2_helper_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %1,#15,%q0\;asr %1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>di2_convergent_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ15 2                         "=r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 15);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"    /*   always rounds to even 0 */
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>di2_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:DI
          (match_operand:QUQ15 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
        ((pic30_fp_round_p() == pic30_convergent) ||
         (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractuns<mode>di2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractuns<mode>di2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; from Q31

(define_insn "satfractuns<mode>qi2_helper_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr.b %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>qi2_convergent_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
   (clobber (reg:CC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr.b %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>qi2_16"
  [(set (match_operand:QI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,QImode)) {
      r0 = gen_reg_rtx(QImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractuns<mode>qi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractuns<mode>qi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractuns<mode>hi2_helper_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%0\"; 
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;btss %0,#0\;clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>hi2_convergent_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"  
              \"btsc _SR,#1\;\"
              \"clr %0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>hi2_16"
  [(set (match_operand:HI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:HI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,HImode)) {
      r0 = gen_reg_rtx(HImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractuns<mode>hi2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractuns<mode>hi2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractuns<mode>si2_helper_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%d0\;asr %d1,#15,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>si2_convergent_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>si2_16"
  [(set (match_operand:SI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:SI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && (pic30_fp_round_p() == pic30_convergent))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(SImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractuns<mode>si2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractuns<mode>si2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractuns<mode>di2_helper_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       /* chop the low order bits, signed results are either 0 or -1 */
       return \"asr %d1,#15,%q0\;asr %d1,#15,%t0\;mul.su %t0,#1,%0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       /* [-1,-.5] round to -1, (-.5,.5) round to 0, otherwise 1? */
       return \"asr %d1,#14,%0\;\"
              \"btss %0,#0\;\"
              \"clr %0\;\"
              \"asr %0,#15,%d0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";
  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractuns<mode>di2_convergent_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=&r")
        (unsigned_sat_fract:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))
   (clobber (match_scratch:QUQ31 2                         "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
     gcc_assert(GET_MODE_FBIT(<MODE>mode) == 31);
     if (pic30_fp_round_p() == pic30_convergent) {
       return \"asr %d1,#14,%0\;\"  /* as conventional */
              \"btss %0,#0\;\"
              \"clr  %0\;\"
              \"asr %0,#15,%d0\;\"
              \"sl %d1,#2,%2\;\"    /* x.yz13 where z13 == 0 */
              \"btsc _SR,#1\;\"     /*   always rounds to even 0 */
              \"cp0 %1\;\"
              \"btsc _SR,#1\;\"
              \"mul.uu %0,#0,%0\;\"
              \"mul.su %d0,#1,%t0\";
     } else {
       error(\"Invalid fixed-point rounding mode specified\");
     }
     gcc_assert(0);
     return \"nop\";

  }"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractuns<mode>di2_16"
  [(set (match_operand:DI    0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:DI
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_convergent)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,DImode)) {
      r0 = gen_reg_rtx(DImode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractuns<mode>di2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractuns<mode>di2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

; to Q15

(define_insn "satfractunsqi<mode>2_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ15
          (match_operand:QI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return \"cp0.b %1\;\"        /* compare input with 0 */
             \"mov  #0x8000,%0\;\" /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunshi<mode>2_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ15
          (match_operand:HI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {
      return \"cp0  %1\;\"         /* compare input with 0 */
             \"mov  #0x8000,%0\;\" /* assume -1 */
             \"btsc _SR,#0\;\"     /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"     /* if zero */
             \"clr %0\";           /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunssi<mode>2_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ15
          (match_operand:SI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return \"subr %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subbr %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov  #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"        /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"     /*   load .99... */
             \"btsc _SR,#1\;\"        /* if zero */
             \"clr %0\";              /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunsdi<mode>2_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ15
          (match_operand:DI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return \"subr %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subbr %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subbr %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subbr %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov  #0x8000,%0\;\"    /* assume -1 */
             \"btsc _SR,#0\;\"        /* positive => 0 or .99 */
             \"mov #0x7FFF,%0\;\"     /*   load .99... */
             \"btsc _SR,#1\;\"        /* if zero */
             \"clr %0\";              /*   load zero */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; to Q31

(define_insn "satfractunsqi<mode>2_16"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ31
          (match_operand:QI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC CC_REG))]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunshi<mode>2_16"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ31
          (match_operand:HI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {
      return 
             \"cp0.b %1\;\"         /* compare input with 0 */
             \"mov #0x8000,%d0\;\"  /* assume -1 */
             \"btsc _SR,#0\;\"      /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"  /*   load .99... */
             \"btsc _SR,#1\;\"      /* if zero */
             \"clr %d0\;\"          /*   load zero */
             \"sl  %d0,%0\;\"       /* form low word by propagating non sign */
             \"asr %0,#15,%0\";     /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunssi<mode>2_16"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ31
          (match_operand:SI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractunsdi<mode>2_16"
  [(set (match_operand:QUQ31  0 "pic30_register_operand"  "=r")
        (unsigned_sat_fract:QUQ31
          (match_operand:DI 1 "pic30_register_operand"  "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   {  
      return 
             \"sub %1,#0,[w15]\;\"   /* compare input with 0 */
             \"subb %d1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %t1,#0,[w15]\;\" /* compare input with 0 */
             \"subb %q1,#0,[w15]\;\" /* compare input with 0 */
             \"mov #0x8000,%d0\;\"   /* assume -1 */
             \"btsc _SR,#0\;\"       /* positive => 0 or .99 */
             \"mov #0x7FFF,%d0\;\"   /*   load .99... */
             \"btsc _SR,#1\;\"       /* if zero */
             \"clr %d0\;\"           /*   load zero */
             \"sl  %d0,%0\;\"        /* form low word by propagating non sign */
             \"asr %0,#15,%0\";      /*   bits into low word */
   }
  "
  [
    (set_attr "cc" "clobber")
  ]
)


;; conversions back and forth to floating point or double will be done by
;;  out of line functions only

;; conversions to and from fractional types
;;   some of these can actually cause saturation

(define_insn "satfractsq<mode>2_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:SQ  1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"       /* shift overflow bit to carry */
             \"addc %d1,#0,%0\;\"    /* add */
             \"bra nov,.L1_%=\;\"    /* no overflow? finished */
             \"mov #0x7FFF,%0\;\"    /* return ~1 */
             \"btsc %d1,#15\;\"
             \"com %0,%0\n\"         /* or -1 */
             \".L1_%=:\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractsq<mode>2_convergent_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:SQ   1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"bra nov,.L1_%=\;\"       /* nov ? continue */
             \"mov #0x7FFF,%0\;\"       /* return ~1 */
             \"btsc %d1,#15\;\"
             \"com %0,%0\;\"            /* or -1 */
             \"setm %2\;\"              /* prevent mask */
             \".L1_%=:\;\"
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_expand "satfractsq<mode>2_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:SQ  1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractsq<mode>2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractsq<mode>2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractusq<mode>2_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:USQ 1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"       /* shift overflow bit to carry */
             \"addc %d1,#0,%0\;\"    /* add */
             \"bra nov,.L1_%=\;\"    /* no overflow? finished */
             \"mov #0x7FFF,%0\;\"    /* return ~1 */
             \"btsc %d1,#15\;\"      
             \"com %0,%0\n\"         /* or -1 */
             \".L1_%=:\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractusq<mode>2_convergent_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:USQ  1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"bra nov,.L1_%=\;\"       /* nov ? continue */
             \"mov #0x7FFF,%0\;\"       /* return ~1 */
             \"btsc %d1,#15\;\" 
             \"com %0,%0\;\"            /* or -1 */
             \"setm %2\n\"              /* prevent mask */
             \".L1_%=:\;\"
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else { 
       error(\"Invalid fixed-point rounding mode specified\");
    }  
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
  ]
) 

(define_expand "satfractusq<mode>2_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:USQ 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"      
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    } 
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    } 
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractusq<mode>2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractusq<mode>2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractdq<mode>2_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:DQ  1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"       /* shift overflow bit to carry */
             \"addc %d1,#0,%0\;\"    /* add */
             \"bra nov,.L1_%=\;\"    /* no overflow? finished */
             \"mov #0x7FFF,%0\;\"    /* return ~1 */
             \"btsc %d1,#15\;\"      
             \"com %0,%0\n\"         /* or -1 */
             \".L1_%=:\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractdq<mode>2_convergent_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:DQ   1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"bra nov,.L1_%=\;\"       /* nov ? continue */
             \"mov #0x7FFF,%0\;\"       /* return ~1 */
             \"btsc %d1,#15\;\" 
             \"com %0,%0\;\"            /* or -1 */
             \"setm %2\n\"              /* prevent mask */
             \".L1_%=:\;\"
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else { 
       error(\"Invalid fixed-point rounding mode specified\");
    }  
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
  ]
) 

(define_expand "satfractdq<mode>2_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:DQ  1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"      
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    } 
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    } 
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractdq<mode>2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractdq<mode>2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)
(define_insn "satfractudq<mode>2_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:UDQ 1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"       /* shift overflow bit to carry */
             \"addc %d1,#0,%0\;\"    /* add */
             \"bra nov,.L1_%=\;\"    /* no overflow? finished */
             \"mov #0x7FFF,%0\;\"    /* return ~1 */
             \"btsc %d1,#15\;\"      
             \"com %0,%0\n\"         /* or -1 */
             \".L1_%=:\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractudq<mode>2_convergent_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:UDQ   1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"bra nov,.L1_%=\;\"       /* nov ? continue */
             \"mov #0x7FFF,%0\;\"       /* return ~1 */
             \"btsc %d1,#15\;\" 
             \"com %0,%0\;\"            /* or -1 */
             \"setm %2\n\"              /* prevent mask */
             \".L1_%=:\;\"
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else { 
       error(\"Invalid fixed-point rounding mode specified\");
    }  
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
  ]
) 

(define_expand "satfractudq<mode>2_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:UDQ 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"      
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    } 
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    } 
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractudq<mode>2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractudq<mode>2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfracttq<mode>2_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:TQ  1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"       /* shift overflow bit to carry */
             \"addc %d1,#0,%0\;\"    /* add */
             \"bra nov,.L1_%=\;\"    /* no overflow? finished */
             \"mov #0x7FFF,%0\;\"    /* return ~1 */
             \"btsc %d1,#15\;\"      
             \"com %0,%0\n\"         /* or -1 */
             \".L1_%=:\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfracttq<mode>2_convergent_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:TQ   1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"bra nov,.L1_%=\;\"       /* nov ? continue */
             \"mov #0x7FFF,%0\;\"       /* return ~1 */
             \"btsc %d1,#15\;\" 
             \"com %0,%0\;\"            /* or -1 */
             \"setm %2\n\"              /* prevent mask */
             \".L1_%=:\;\"
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else { 
       error(\"Invalid fixed-point rounding mode specified\");
    }  
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
  ]
) 

(define_expand "satfracttq<mode>2_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:TQ  1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"      
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    } 
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    } 
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfracttq<mode>2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfracttq<mode>2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractutq<mode>2_helper_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:UTQ 1 "pic30_register_operand" "r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \"mov %d1,%0\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \"sl %1,[w15]\;\"       /* shift overflow bit to carry */
             \"addc %d1,#0,%0\;\"    /* add */
             \"bra nov,.L1_%=\;\"    /* no overflow? finished */
             \"mov #0x7FFF,%0\;\"    /* return ~1 */
             \"btsc %d1,#15\;\"      
             \"com %0,%0\n\"         /* or -1 */
             \".L1_%=:\";
    } else {
       error(\"Invalid fixed-point rounding mode specified\");
    }
     gcc_assert(0);
     return \"nop\";
  }
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "satfractutq<mode>2_convergent_16"
  [(set (match_operand:QUQ15  0 "pic30_register_operand" "=&r")
        (sat_fract:QUQ15
          (match_operand:UTQ  1 "pic30_register_operand" "r")))
   (clobber (match_scratch:HI 2                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent) {
      return \"setm %2\;\"
             \"sl %1,[w15]\;\"          /* get top bit into carry */
             \"btsc _SR,#1\;\"          /* if the result is 0 */
             \"mov #0xFFFE,%2\;\"       /*   mask off low bit */
             \"addc %d1,#0,%0\;\"       /* add in 'overflow' */
             \"bra nov,.L1_%=\;\"       /* nov ? continue */
             \"mov #0x7FFF,%0\;\"       /* return ~1 */
             \"btsc %d1,#15\;\" 
             \"com %0,%0\;\"            /* or -1 */
             \"setm %2\n\"              /* prevent mask */
             \".L1_%=:\;\"
             \"and %0,%2,%0\";          /* maybe mask off low bit */
    } else { 
       error(\"Invalid fixed-point rounding mode specified\");
    }  
     gcc_assert(0);
     return \"nop\";
  } 
  "
  [
    (set_attr "cc" "clobber")
  ]
) 

(define_expand "satfractutq<mode>2_16"
  [(set (match_operand:QUQ15 0 "pic30_register_operand"  "=r")
        (sat_fract:QUQ15
          (match_operand:UTQ 1 "pic30_register_operand"  "r")))]
  "(!pic30_isa32_target())"      
  "
  { rtx r0,r1;

    if (!pic30_fp_inline_p() && 
         ((pic30_fp_round_p() == pic30_convergent) ||
          (pic30_fp_round_p() == pic30_conventional)))
      FAIL;
    r0 = operands[0];
    r1 = operands[1];
    if (!pic30_register_operand(r0,SImode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    } 
    if (!pic30_register_operand(r1,VOIDmode)) {
      r1 = force_reg(<MODE>mode, r1);
    } 
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_satfractutq<mode>2_convergent_16(r0,r1)
      );
    } else {
      emit(
        gen_satfractutq<mode>2_helper_16(r0,r1)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }
  "
)

(define_insn "satfractqq<mode>2_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (sat_fract:QUQ31
          (match_operand:QQ  1 "pic30_register_operand" "r")))]
  "(!pic30_isa32_target())"
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "satfractuqq<mode>2_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (sat_fract:QUQ31
          (match_operand:UQQ 1 "pic30_register_operand" "r")))]
  "(!pic30_isa32_target())"
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "satfracthq<mode>2_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (sat_fract:QUQ31
          (match_operand:HQ  1 "pic30_register_operand" "r")))]
  "(!pic30_isa32_target())"
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

(define_insn "satfractuhq<mode>2_16"
  [(set (match_operand:QUQ31 0 "pic30_register_operand" "=r")
        (sat_fract:QUQ31
          (match_operand:UHQ 1 "pic30_register_operand" "r")))]
  "(!pic30_isa32_target())"
  "mov %1,%d0\;clr %0"
  [
    (set_attr "cc" "change0")
  ]
)

;; conversions between different fractional modes of the same size
;;   these are nops but must exist

(define_insn "satfract<mode>sq2_16"
  [(set (match_operand:SQ      0 "pic30_register_operand" "=r,r")
        (sat_fract:SQ
          (match_operand:QUQ31 1 "pic30_register_operand" "r,0")))]
  "(!pic30_isa32_target())"
  "@
   mov.d %1,%0
   ; nop"
  [
    (set_attr "cc" "change0,unchanged")
  ]
)

(define_insn "satfract<mode>dq2_16"
  [(set (match_operand:DQ      0 "pic30_register_operand" "=r,r")
        (sat_fract:DQ
          (match_operand:QUQ31 1 "pic30_register_operand" "r,0")))]
  "(!pic30_isa32_target())"
  "@
   mov.d %1,%0
   ; nop"
  [
    (set_attr "cc" "change0,unchanged")
  ]
)

(define_insn "satfract<mode>tq2_16"
  [(set (match_operand:TQ      0 "pic30_register_operand" "=r,r")
        (sat_fract:TQ
          (match_operand:QUQ31 1 "pic30_register_operand" "r,0")))]
  "(!pic30_isa32_target())"
  "@
   mov.d %1,%0
   ; nop"
  [
    (set_attr "cc" "change0,unchanged")
  ]
)

(define_insn "satfract<mode>qq2_16"
  [(set (match_operand:QQ      0 "pic30_register_operand" "=r,r")
        (sat_fract:QQ
          (match_operand:QUQ15 1 "pic30_register_operand" "r,0")))]
  "(!pic30_isa32_target())"
  "@
   mov %1,%0
   ; nop"
  [
    (set_attr "cc" "change0,unchanged")
  ]
)

(define_insn "satfract<mode>hq2_16"
  [(set (match_operand:HQ      0 "pic30_register_operand" "=r,r")
        (sat_fract:HQ
          (match_operand:QUQ15 1 "pic30_register_operand" "r,0")))]
  "(!pic30_isa32_target())"
  "@
   mov %1,%0
   ; nop"
  [
    (set_attr "cc" "change0,unchanged")
  ]
)

; missing conversions between signed/unsigned 'self'

(define_insn "satfractqquqq2_16"
  [(set (match_operand:UQQ  0 "register_operand" "=r")
       (unsigned_sat_fract:UQQ
         (match_operand:QQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "satfracthquhq2_16"
  [(set (match_operand:UHQ  0 "register_operand" "=r")
       (unsigned_sat_fract:UHQ
         (match_operand:HQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "satfractsqusq2_16"
  [(set (match_operand:USQ  0 "register_operand" "=r")
       (unsigned_sat_fract:USQ
         (match_operand:SQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "satfractdqudq2_16"
  [(set (match_operand:UDQ  0 "register_operand" "=r")
       (unsigned_sat_fract:UDQ
         (match_operand:DQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "satfracttqutq2_16"
  [(set (match_operand:UTQ  0 "register_operand" "=r")
       (unsigned_sat_fract:UTQ
         (match_operand:TQ 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "satfracthauha2_16"
  [(set (match_operand:UHA  0 "register_operand" "=r")
       (unsigned_sat_fract:UHA
         (match_operand:HA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "satfractuhaha2_16"
  [(set (match_operand:HA    0 "register_operand" "=r")
       (sat_fract:HA
         (match_operand:UHA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "satfractsausa2_16"
  [(set (match_operand:USA  0 "register_operand" "=r")
       (unsigned_sat_fract:USA
         (match_operand:SA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "satfractusasa2_16"
  [(set (match_operand:SA    0 "register_operand" "=r")
       (sat_fract:SA
         (match_operand:USA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "satfractdauda2_16"
  [(set (match_operand:UDA  0 "register_operand" "=r")
       (unsigned_sat_fract:UDA
         (match_operand:DA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "satfractudada2_16"
  [(set (match_operand:DA    0 "register_operand" "=r")
       (sat_fract:DA
         (match_operand:UDA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "satfracttauta2_16"
  [(set (match_operand:UTA  0 "register_operand" "=r")
       (unsigned_sat_fract:UTA
         (match_operand:TA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

(define_insn "satfractutata2_16"
  [(set (match_operand:TA    0 "register_operand" "=r")
       (sat_fract:TA
         (match_operand:UTA 1 "register_operand" "0")))]
  "(!pic30_isa32_target())"
  "; nop"
)

;; negate

(define_insn "neg<mode>2_16"
  [(set (match_operand:QUQ15   0 "pic30_mode2_operand" "=rR<>")
        (neg:QUQ15
          (match_operand:QUQ15 1 "pic30_mode2_operand" " rR<>")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "neg %1,%0"
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "ssneg<mode>2_16"
  [(set (match_operand:QUQ15   0 "pic30_register_operand" "=&r")
        (ss_neg:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand" " r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   return \"neg %1,%0\;\"
          \"bra nov,.L1_%=\;\"
          \"mov #0x7FFF,%0\;\"
          \"btss %1,#15\;\"
          \"com %0,%0\n\"
          \".L1_%=:\;\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "usneg<mode>2_16"
  [(set (match_operand:Q15   0 "pic30_register_operand" "=&r")
        (us_neg:Q15
          (match_operand:Q15 1 "pic30_register_operand" " r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "neg %1,%0;\;btsc _SR,#2\;mov #0x7FFF,%0\;btsc _SR,#3\;clr %0"
  [
    (set_attr "cc" "clobber")
  ]
)

; cannot negate with unigned saturation a positive value
(define_insn "usneg<mode>2_16"
  [(set (match_operand:UQ15   0 "pic30_register_operand" "=&r")
        (us_neg:UQ15
          (match_operand:UQ15 1 "pic30_register_operand" " r")))]
  "(!pic30_isa32_target())"
  "clr %0"
  [
    (set_attr "cc" "clobber")
  ]
)


(define_insn "neg<mode>2_16"
  [(set (match_operand:QUQ31   0 "pic30_mode2_operand" "=r<>,R")
        (neg:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand" " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   subr %1,#0,%0\;subbr %d1,#0,%d0
   subr %1,#0,%I0\;subbr %d1,#0,%D0"
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "ssneg<mode>2_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (ss_neg:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand" " r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   return \"subr %1,#0,%0\;\"
          \"subbr %d1,#0,%d0\;\"
          \"bra nov,.L1_%=\;\"
          \"setm %0\;\"
          \"mov #0x7FFF,%d0\;\"
          \"btst.c %d1,#15\;\"
          \"bra c,.L1_%=\;\"
          \"com %d0,%d0\;\"
          \"com %0,%0\n\"
          \".L1_%=:\;\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "usneg<mode>2_16"
  [(set (match_operand:Q31   0 "pic30_register_operand" "=r")
        (us_neg:Q31
          (match_operand:Q31 1 "pic30_register_operand" " r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   return \"subr %1,#0,%0\;\"
          \"subbr %d1,#0,%d0\;\"
          \"bra nov,.L1_%=\;\"
          \"setm %0\;\"
          \"mov #0x7FFF,%d0\n\"
          \".L1_%=:\;\"
          \"btsc _SR,#3\;\"
          \"mul.uu %0,#0,%0\";
  "
  [
    (set_attr "cc" "clobber")
  ]
)

; cannot negate with unigned saturation a positive value
(define_insn "usneg<mode>2_16"
  [(set (match_operand:UQ31   0 "pic30_register_operand" "=&r")
        (us_neg:UQ31
          (match_operand:UQ31 1 "pic30_register_operand" " r")))]
  "(!pic30_isa32_target())"
  "mul.uu %0,#0,%0"
  [
    (set_attr "cc" "clobber")
  ]
)

;; shift

(define_insn "ashl<mode>3_16"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"       "=r")
        (ashift:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand"       "r")
          (match_operand:HI    2 "pic30_register_operand"       "r")))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sl %1,%2,%0"
  [ 
   (set_attr "cc" "math")
  ]
)

(define_insn "ssashl<mode>3_16"
  [(set (match_operand:Q15   0 "pic30_register_operand"     "=&r")
        (ss_ashift:Q15
          (match_operand:Q15 1 "pic30_register_operand"       "r")
          (match_operand:HI  2 "pic30_register_operand"       "r")))
   (clobber (match_scratch:HI 3                              "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return \"mov #0x8000,%3\;\"        /* create mask for bits */
          \"asr %3,%2,%3\;\"          /*   that drop off */
          \"sl  %1,%2,%0\;\"          /* shift */
          \"and %3,%1,%3\;\"          /* mask input and mask */
          \"bra z,.L1_%=\;\"          /* non-zero means bits drop off */
          \"mov #0x7FFF,%0\;\"        /* Saturate to ~.99 */
          \"btsc %1,#15\;\"
          \"com %0,%0\n\"             /* or -1 */
          \".L1_%=:\";
  "
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ssashl<mode>3_16"
  [(set (match_operand:UQ15   0 "pic30_register_operand"     "=&r")
        (ss_ashift:UQ15
          (match_operand:UQ15 1 "pic30_register_operand"       "r")
          (match_operand:HI   2 "pic30_register_operand"       "r")))
   (clobber (match_scratch:HI 3                              "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return \"mov #0x8000,%3\;\"        /* create mask for bits */
          \"asr %3,%2,%3\;\"          /*   that drop off */
          \"sl  %1,%2,%0\;\"          /* shift */
          \"and %3,%1,%3\;\"          /* mask input and mask */
          \"btss _SR,#1\;\"           /* non-zero means bits drop off */
          \"mov #0x7FFF,%0\;\";
  "
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "usashl<mode>3_16"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"     "=&r")
        (us_ashift:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand"       "r")
          (match_operand:HI    2 "pic30_register_operand"       "r")))
   (clobber (match_scratch:HI 3                               "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return \"mov #0x8000,%3\;\"        /* create mask for bits */
          \"asr %3,%2,%3\;\"          /*   that drop off */
          \"sl  %1,%2,%0\;\"          /* shift */
          \"and %3,%1,%3\;\"          /* mask input and mask */
          \"btss _SR,#1\;\"           /* non-zero means bits drop off */
          \"mov #0x7FFF,%0\";
  "
  [
   (set_attr "cc" "clobber")
  ]
)

; 32-bit shift left

(define_insn "ashl<mode>3_imm1_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_I_operand"         "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "add %1,%1,%0\;addc %d1,%d1,%d0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm1_16"
  [(set (match_operand:Q31   0 "pic30_register_operand" "=&r")
        (ss_ashift:Q31 
          (match_operand:Q31 1 "pic30_register_operand"   "r")
          (match_operand:HI  2 "pic30_I_operand"          "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   return \"add %1,%1,%0\;\"          /* shift */
          \"addc %d1,%d1,%d0\;\"
          \"bra nov,.L1_%=\;\"        /* but if the sign changes ... */
          \"mov #0x7FFF,%d0\;\"       /* Saturate to ~.99 */
          \"btsc %d1,#15\;\"
          \"com %d0,%d0\;\"           /* or -1 */
          \"sl  %d0,%0\;\"            /* form low word by propagating nonsign */
          \"asr %0,#15,%0\n\"         /*   bits into low word */
          \".L1_%=:\;\";
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm1_16"
  [(set (match_operand:UQ31   0 "pic30_register_operand" "=&r")
        (ss_ashift:UQ31
          (match_operand:UQ31 1 "pic30_register_operand"   "r")
          (match_operand:HI   2 "pic30_I_operand"          "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   return \"add %1,%1,%0\;\"          /* shift */
          \"addc %d1,%d1,%d0\;\"
          \"bra nov,.L1_%=\;\"        /* but if the sign changes ... */
          \"mov #0x7FFF,%d0\;\"       /* Saturate to ~.99 */
          \"setm %0\";                /*   bits into low word */
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "usashl<mode>3_imm1_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (us_ashift:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand"   "r")
          (match_operand:HI    2 "pic30_I_operand"          "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target()) && pic30_fp_inline_p()"
  "*
   return \"add %1,%1,%0\;\"          /* shift */
          \"addc %d1,%d1,%d0\;\"
          \"bra nov,.L1_%=\;\"        /* but if the sign changes ... */
          \"mov #0x7FFF,%d0\;\"       /* Saturate to ~.99 */
          \"setm %0\;\"               /*   bits into low word */
          \".L1_%=:\";
          
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashl<mode>3_imm8_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"   "r")
          (match_operand:HI    2 "pic30_imm8_operand"       "i")))
   (clobber (match_dup 1))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    int idDst = REGNO(operands[0]);
    int idSrc = REGNO(operands[1]);
    if (idDst == idSrc) {
      return \"sl %d1,#%2,%d0\;\"
             \"swap %1\;\"
             \"mov.b %0,%d0\;\"
             \"clr.b %0\";
    } else {
      return \"sl %d1,#%2,%0\;\"
             \"lsr %1,#%k2,%d0\;\"
             \"ior %0,%d0,%d0\;\"
             \"sl %1,#%2,%0\";
    }
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm8_16"
  [(set (match_operand:Q31   0 "pic30_register_operand" "=&r")
        (ss_ashift:Q31
          (match_operand:Q31 1 "pic30_register_operand"   "r")
          (match_operand:HI  2 "pic30_imm8_operand"       "i")))
   (clobber (match_dup 1))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    int idDst = REGNO(operands[0]);
    int idSrc = REGNO(operands[1]);
    if (idDst == idSrc) {
      return 
             \"asr %d1,#(16-9),%0\;\"    /* test the bits that drop off */
             \"asr %d1,#15,%d0\;\"       /* or move into sign */
             \"xor %d0,%0,%0\;\"         /* match the original sign */
             \"bra z,.L1_%=\;\"          /* normal shift if zero */
             \"mov #0x7FFF,%d0\;\"       /* assume ~.99 if ... */
             \"btsc %d1,#15\;\"
             \"com %d0,%d0\;\"
             \"sl  %d0,%0\;\"
             \"asr %0,#15,%0\;\"
             \"bra .L2_%=\n\"
	     \".L1_%=:\;\"               /* safe to shift ... */
	     \"sl %d1,#%2,%d0\;\"
             \"swap %1\;\"
             \"mov.b %0,%d0\;\"
             \"clr.b %0\n\"
             \".L2_%=:\;\";
    } else {
      return 
             \"asr %d1,#(16-9),%0\;\"    /* test the bits that drop off */
             \"asr %d1,#15,%d0\;\"       /* or move into sign */
             \"xor %d0,%0,%0\;\"         /* match the original sign */
             \"bra z,.L1_%=\;\"          /* normal shift if zero */
             \"mov #0x7FFF,%d0\;\"       /* assume ~.99 if ... */
             \"btsc %d1,#15\;\"
             \"com %d0,%d0\;\"
             \"sl  %d0,%0\;\"
             \"asr %0,#15,%0\;\"
             \"bra .L2_%=\n\"
             \".L1_%=:\;\"               /* safe to shift ... */
             \"sl %d1,#%2,%0\;\"
             \"lsr %1,#%k2,%d0\;\"
             \"ior %0,%d0,%d0\;\"
             \"sl %1,#%2,%0\n\"
             \".L2_%=:\;\";
    }
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm8_16"
  [(set (match_operand:UQ31   0 "pic30_register_operand" "=&r")
        (ss_ashift:UQ31
          (match_operand:UQ31 1 "pic30_register_operand"   "r")
          (match_operand:HI   2 "pic30_imm8_operand"       "i")))
   (clobber (match_dup 1))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    int idDst = REGNO(operands[0]);
    int idSrc = REGNO(operands[1]);
    if (idDst == idSrc) {
      return
             \"mov #0xFF10, %0\;\"       /* test the bits that drop off */
             \"and %d1,%0,%0\;\"         /* or move into sign for zero */
             \"bra z,.L1_%=\;\"          /* normal shift if zero */
             \"mov #0x7FFF,%d0\;\"       /* return ~.99  */
             \"setm %0\;\"
             \"bra .L2_%=\n\"
             \".L1_%=:\;\"               /* safe to shift ... */
             \"sl %d1,#%2,%d0\;\"        
             \"swap %1\;\"
             \"mov.b %0,%d0\;\"
             \"clr.b %0\n\"
             \".L2_%=:\;\";
    } else { 
      return 
             \"mov #0xFF10, %0\;\"       /* test the bits that drop off */
             \"and %d1,%0,%0\;\"         /* or move into sign for zero */
             \"bra z,.L1_%=\;\"          /* normal shift if zero */
             \"mov #0x7FFF,%d0\;\"       /* return ~.99 ... */
             \"setm %d0\;\"
             \"bra .L2_%=\n\"
             \".L1_%=:\;\"               /* safe to shift ... */
             \"sl %d1,#%2,%0\;\"
             \"lsr %1,#%k2,%d0\;\"
             \"ior %0,%d0,%d0\;\"
             \"sl %1,#%2,%0\n\"
             \".L2_%=:\;\";
    }
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "usashl<mode>3_imm8_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (us_ashift:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand"   "r")
          (match_operand:HI    2 "pic30_imm8_operand"       "i")))
   (clobber (match_dup 1))
  
   (clobber (reg:CC_NZC CC_REG))
  ]       
  "(!pic30_isa32_target())"
  "*
  {
    int idDst = REGNO(operands[0]);
    int idSrc = REGNO(operands[1]);
    if (idDst == idSrc) {
      return
             \"mov #0xFF10, %0\;\"       /* test the bits that drop off */
             \"and %d1,%0,%0\;\"         /* or move into sign for zero */
             \"bra z,.L1_%=\;\"          /* normal shift if zero */
             \"mov #0x7FFF,%d0\;\"       /* return ~.99  */
             \"setm %0\;\"
             \"bra .L2_%=\n\"
             \".L1_%=:\;\"               /* safe to shift ... */
             \"sl %d1,#%2,%d0\;\"
             \"swap %1\;\"
             \"mov.b %0,%d0\;\"
             \"clr.b %0\n\"
             \".L2_%=:\;\";
    } else {
      return  
             \"mov #0xFF10, %0\;\"       /* test the bits that drop off */
             \"and %d1,%0,%0\;\"         /* or move into sign for zero */
             \"bra z,.L1_%=\;\"          /* normal shift if zero */
             \"mov #0x7FFF,%d0\;\"       /* return ~.99 ... */
             \"setm %d0\;\"
             \"bra .L2_%=\n\"
             \".L1_%=:\;\"               /* safe to shift ... */
             \"sl %d1,#%2,%0\;\"
             \"lsr %1,#%k2,%d0\;\"
             \"ior %0,%d0,%d0\;\"
             \"sl %1,#%2,%0\n\"
             \".L2_%=:\;\";
    }
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashl<mode>3_imm16plus_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand"  "=r")
        (ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"   "r")
          (match_operand:HI    2 "pic30_imm16plus_operand"  "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "sl %1,#%K2,%d0\;mov #0,%0"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm16plus_16"
  [(set (match_operand:Q31   0 "pic30_register_operand"  "=&r")
        (ss_ashift:Q31
          (match_operand:Q31 1 "pic30_register_operand"    "r")
          (match_operand:HI  2 "pic30_imm16plus_operand"   "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return 
          \"asr %d1,#15,%d0\;\"       /* for signed we care about 1s */
          \"asr %1,#(16-%K2),%0\;\"   /* for unsigned we care about 0s */
          \"xor %0,%d0,[w15]\;\"      /* shifting bits out? */
          \"btsc _SR,#1\;\"           /*  yes? don't compare the high word */
          \"cp %d0,%d1\;\"
          \"bra z,.L1_%=\;\"          /* if not losing bits, shift as normal */
          \"mov #0x7FFF,%d0\;\"       /* assume ~.9999 */
          \"btsc %d1,#15\;\"          /* if negatvie */
          \"com %d0,%d0\;\"           /* make -1 */
          \"sl %d0,%0\;\"             /* propagate non sign bits */
          \"asr %0,#15,%0\;\"
          \"bra .L2_%=\n\"
          \".L1_%=:\;\"               /* shift as normal */
          \"sl %1,#%K2,%d0\;\" 
          \"mov #0,%0\n\"
          \".L2_%=:\;\";
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm16plus_16"
  [(set (match_operand:UQ31   0 "pic30_register_operand"  "=&r")
        (ss_ashift:UQ31
          (match_operand:UQ31 1 "pic30_register_operand"    "r")
          (match_operand:HI   2 "pic30_imm16plus_operand"   "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return
          \"asr %1,#(16-%K2),%0\;\"   /* for unsigned we care about 0s */
          \"btsc _SR,#1\;\"           /*  yes? don't compare the high word */
          \"cp0 %d1\;\"
          \"bra z,.L1_%=\;\"          /* if not losing bits, shift as normal */
          \"mov #0x7FFF,%d0\;\"       /* make ~.9999 */
          \"setm %d0\;\"
          \"bra .L2_%=\n\"
          \".L1_%=:\;\"               /* shift as normal */
          \"sl %1,#%K2,%d0\;\" 
          \"mov #0,%0\n\"
          \".L2_%=:\;\";
  " 
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "usashl<mode>3_imm16plus_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand"  "=&r")
        (us_ashift:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand"    "r")
          (match_operand:HI    2 "pic30_imm16plus_operand"   "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   return
          \"asr %1,#(16-%K2),%0\;\"   /* for unsigned we care about 0s */
          \"btsc _SR,#1\;\"           /*  yes? don't compare the high word */
          \"cp0 %d1\;\"
          \"bra z,.L1_%=\;\"          /* if not losing bits, shift as normal */
          \"mov #0x7FFF,%d0\;\"       /* make ~.9999 */
          \"setm %d0\;\"
          \"bra .L2_%=\n\"
          \".L1_%=:\;\"               /* shift as normal */
          \"sl %1,#%K2,%d0\;\"
          \"mov #0,%0\n\"
          \".L2_%=:\;\";
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashl<mode>3_imm2to15_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r,&r")
        (ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r, r")
          (match_operand:HI    2 "pic30_imm2to15_operand"  "i, i")))
   (clobber (match_scratch:HI 3                          "=&r, X"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  { int idDst, idSrc;

    switch (which_alternative) {
      case 0:
        /*
        ** Take care that the source and dest don't overlap
        */
        idDst = REGNO(operands[0]);
        idSrc = REGNO(operands[1]);
        if (idDst >= idSrc) {
          return \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\;\"
                 \"sl %1,#%2,%0\";
        } else {
          return \"sl %1,#%2,%0\;\"
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\";
        }
      case 2:
        /*
        ** The dest and source don't overlap
        ** so use dest lsw as a temporary
        */
        return \"sl %d1,#%2,%0\;\"
               \"lsr %1,#%k2,%d0\;\"
               \"ior %0,%d0,%d0\;\"
               \"sl %1,#%2,%0\";
      default: gcc_assert(0);
    }
    return \"nop\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm2to15_16"
  [(set (match_operand:Q31    0 "pic30_register_operand" "=r,&r")
        (ss_ashift:Q31 
          (match_operand:Q31  1 "pic30_register_operand"  "r, r")
          (match_operand:HI   2 "pic30_imm2to15_operand"  "i, i")))
   (clobber (match_scratch:HI 3                         "=&r, X"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  { int idDst, idSrc;

    switch (which_alternative) {
      case 0:
        /* 
        ** Take care that the source and dest don't overlap
        */
        idDst = REGNO(operands[0]);
        idSrc = REGNO(operands[1]);
        if (idDst >= idSrc) {
          return 
                 \"asr %d1,#15,%d0\;\"       /* for signed we care about 1s */
                 \"asr %d1,#(15-%2),%0\;\"   /* for unsigned we care about 0s */
                 \"xor %0,%d0,%d0\;\"        /* shifting bits out? */
                 \"bra z,.L1_%=\;\"          /* if not, shift as normal */
                 \"mov #0x7FFF,%d0\;\"       /* assume ~.9999 */
                 \"btsc %d1,#15\;\"          /* if negatvie */
                 \"com %d0,%d0\;\"           /* make -1 */
                 \"sl %d0,%0\;\"             /* propagate non sign bits */
                 \"asr %0,#15,%0\;\"
                 \"bra .L2_%=\n\"
                 \".L1_%=:\;\"               /* shift as normal */
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\;\"
                 \"sl %1,#%2,%0\n\"
                 \".L2_%=:\;\";
        } else {
          return
                 \"asr %d1,#15,%d0\;\"       /* for signed we care about 1s */
                 \"asr %d1,#(15-%2),%0\;\"   /* for unsigned we care about 0s */
                 \"xor %0,%d0,%d0\;\"        /* shifting bits out? */
                 \"bra z,.L1_%=\;\"          /* if not, shift as normal */
                 \"mov #0x7FFF,%d0\;\"       /* assume ~.9999 */
                 \"btsc %d1,#15\;\"          /* if negatvie */
                 \"com %d0,%d0\;\"           /* make -1 */
                 \"sl %d0,%0\;\"             /* propagate non sign bits */
                 \"asr %0,#15,%0\;\"
                 \"bra .L2_%=\n\"
                 \".L1_%=:\;\"               /* shift as normal */
                 \"sl %1,#%2,%0\;\"
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\n\"
                 \".L2_%=:\;\";
        }
      case 2:
        /*
        ** The dest and source don't overlap
        ** so use dest lsw as a temporary
        */
        return
               \"asr %d1,#15,%d0\;\"         /* for signed we care about 1s */
               \"asr %d1,#(15-%2),%0\;\"     /* for unsigned we care about 0s */
               \"xor %0,%d0,%d0\;\"          /* shifting bits out? */
               \"bra z,.L1_%=\;\"            /* if not, shift as normal */
               \"mov #0x7FFF,%d0\;\"         /* assume ~.9999 */
               \"btsc %d1,#15\;\"            /* if negatvie */
               \"com %d0,%d0\;\"             /* make -1 */
               \"sl %d0,%0\;\"               /* propagate non sign bits */
               \"asr %0,#15,%0\;\"
               \"bra .L2_%=\n\"
               \".L1_%=:\;\"                 /* shift as normal */
               \"sl %d1,#%2,%0\;\"
               \"lsr %1,#%k2,%d0\;\"
               \"ior %0,%d0,%d0\;\"
               \"sl %1,#%2,%0\n\"
               \".L2_%=:\;\";

      default: gcc_assert(0);
    }
    return \"nop\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_imm2to15_16"
  [(set (match_operand:UQ31   0 "pic30_register_operand" "=r,&r")
        (ss_ashift:UQ31
          (match_operand:UQ31 1 "pic30_register_operand"  "r, r")
          (match_operand:HI   2 "pic30_imm2to15_operand"  "i, i")))
   (clobber (match_scratch:HI 3                         "=&r, X"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  { int idDst, idSrc;

    switch (which_alternative) {
      case 0:
        /*
        ** Take care that the source and dest don't overlap
        */
        idDst = REGNO(operands[0]);
        idSrc = REGNO(operands[1]);
        if (idDst >= idSrc) {
          return
                 \"asr %d1,#(15-%2),%0\;\"   /* for unsigned we care about 0s */
                 \"bra z,.L1_%=\;\"          /* if not, shift as normal */
                 \"mov #0x7FFF,%d0\;\"       /* return ~.9999 */
                 \"setm %0\;\"
                 \"bra .L2_%=\n\"
                 \".L1_%=:\;\"               /* shift as normal */
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\;\"
                 \"sl %1,#%2,%0\n\"
                 \".L2_%=:\;\";
        } else {
          return
                 \"asr %d1,#(15-%2),%0\;\"   /* for unsigned we care about 0s */
                 \"bra z,.L1_%=\;\"          /* if not, shift as normal */
                 \"mov #0x7FFF,%d0\;\"       /* return ~.9999 */
                 \"setm %0\;\"
                 \"bra .L2_%=\n\"
                 \".L1_%=:\;\"               /* shift as normal */
                 \"sl %1,#%2,%0\;\"
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\n\"
                 \".L2_%=:\;\";
        }
      case 2:
        /*
        ** The dest and source don't overlap
        ** so use dest lsw as a temporary
        */
        return 
               \"asr %d1,#(15-%2),%0\;\"     /* for unsigned we care about 0s */
               \"bra z,.L1_%=\;\"            /* if not, shift as normal */
               \"mov #0x7FFF,%d0\;\"         /* return ~.9999 */
               \"setm %0\;\"
               \"bra .L2_%=\n\"
               \".L1_%=:\;\"                 /* shift as normal */
               \"sl %d1,#%2,%0\;\"
               \"lsr %1,#%k2,%d0\;\"
               \"ior %0,%d0,%d0\;\"
               \"sl %1,#%2,%0\n\"
               \".L2_%=:\;\";
      default: gcc_assert(0);
    }
    return \"nop\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "usashl<mode>3_imm2to15_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r,&r")
        (us_ashift:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand"  "r, r")
          (match_operand:HI    2 "pic30_imm2to15_operand"  "i, i")))
   (clobber (match_scratch:HI  3                         "=&r, X"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  { int idDst, idSrc;

    switch (which_alternative) {
      case 0:
        /*
        ** Take care that the source and dest don't overlap
        */
        idDst = REGNO(operands[0]);
        idSrc = REGNO(operands[1]);
        if (idDst >= idSrc) {
          return
                 \"asr %d1,#(15-%2),%0\;\"   /* for unsigned we care about 0s */
                 \"bra z,.L1_%=\;\"          /* if not, shift as normal */
                 \"mov #0x7FFF,%d0\;\"       /* return ~.9999 */
                 \"setm %0\;\"
                 \"bra .L2_%=\n\"
                 \".L1_%=:\;\"               /* shift as normal */
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\;\"
                 \"sl %1,#%2,%0\n\"
                 \".L2_%=:\;\";
        } else {
          return
                 \"asr %d1,#(15-%2),%0\;\"   /* for unsigned we care about 0s */
                 \"bra z,.L1_%=\;\"          /* if not, shift as normal */
                 \"mov #0x7FFF,%d0\;\"       /* return ~.9999 */
                 \"setm %0\;\"
                 \"bra .L2_%=\n\"
                 \".L1_%=:\;\"               /* shift as normal */
                 \"sl %1,#%2,%0\;\"
                 \"sl %d1,#%2,%3\;\"
                 \"lsr %1,#%k2,%d0\;\"
                 \"ior %3,%d0,%d0\n\"
                 \".L2_%=:\;\";
        }
      case 2:
        /*
        ** The dest and source don't overlap
        ** so use dest lsw as a temporary
        */
        return
               \"asr %d1,#(15-%2),%0\;\"     /* for unsigned we care about 0s */
               \"bra z,.L1_%=\;\"            /* if not, shift as normal */
               \"mov #0x7FFF,%d0\;\"         /* return ~.9999 */
               \"setm %0\;\"
               \"bra .L2_%=\n\"
               \".L1_%=:\;\"                 /* shift as normal */
               \"sl %d1,#%2,%0\;\"
               \"lsr %1,#%k2,%d0\;\"
               \"ior %0,%d0,%d0\;\"
               \"sl %1,#%2,%0\n\"
               \".L2_%=:\;\";
      gcc_assert(0);
    }
    return \"nop\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashl<mode>3_reg_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand" " 0")
          (match_operand:HI    2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI  3                          "=2"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    return
           \".set ___BP___,0\n\"
           \".LB%=:\;\"
           \"dec %2,%2\;\"
           \"bra n,.LE%=\;\"
           \"add %1,%1,%0\;\"
           \"addc %d1,%d1,%d0\;\"
           \"bra .LB%=\n\"
           \".LE%=:\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_reg_16"
  [(set (match_operand:Q31    0 "pic30_register_operand" "=&r")
        (ss_ashift:Q31
          (match_operand:Q31  1 "pic30_register_operand" " r")
          (match_operand:HI   2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI 3                          "=2"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    return
           \".set ___BP___,0\n\"
           \"mov.d %1,%0\;\"
           \".LB%=:\;\"
           \"dec %2,%2\;\"
           \"bra n,.LE%=\;\"
           \"add %0,%0,%0\;\"
           \"addc %d0,%d0,%d0\;\"
           \"bra nov,.LB%=\;\"        /* if we drop a bit into the sign */
           \"mov #0x7FFF,%d0\;\"      /* assume ~.9999 */
           \"btsc %d1,#15\;\"
           \"com %d0,%d0\;\"
           \"sl %d0,%0\;\"
           \"asr %0,#15,%0\n\"
           \".LE%=:\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ssashl<mode>3_reg_16"
  [(set (match_operand:UQ31   0 "pic30_register_operand" "=r")
        (ss_ashift:UQ31
          (match_operand:UQ31 1 "pic30_register_operand" " 0")
          (match_operand:HI   2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI 3                          "=2"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    return
           \".set ___BP___,0\n\"
           \".LB%=:\;\"
           \"dec %2,%2\;\"
           \"bra n,.LE%=\;\"
           \"add %1,%1,%0\;\"
           \"addc %d1,%d1,%d0\;\"
           \"bra nov,.LB%=\;\"        /* if we drop a bit into the sign */
           \"mov #0x7FFF,%d0\;\"      /* return ~.9999 */
           \"setm %0\;\"
           \".LE%=:\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "usashl<mode>3_reg_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (us_ashift:QUQ31
          (match_operand:QUQ31 1 "pic30_register_operand" " 0")
          (match_operand:HI    2 "pic30_register_operand" " r")))
   (clobber (match_scratch:HI  3                          "=2"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    return
           \".set ___BP___,0\n\"
           \".LB%=:\;\"
           \"dec %2,%2\;\"
           \"bra n,.LE%=\;\"
           \"add %1,%1,%0\;\"
           \"addc %d1,%d1,%d0\;\"
           \"bra nov,.LB%=\;\"        /* if we drop a bit into the sign */
           \"mov #0x7FFF,%d0\;\"      /* return ~.9999 */
           \"setm %0\;\"
           \".LE%=:\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_expand "ashl<mode>3_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "")
        (ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand" "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  "(!pic30_isa32_target())"
  "
  {
    rtx op1, op2;

    op1 = force_reg(GET_MODE(operands[0]),operands[1]);
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0:
          emit_insn(
            gen_mov<mode>_16(operands[0], op1)
          );
          break;
        case 1:
          emit_insn(
            gen_ashl<mode>3_imm1_16(operands[0], op1, operands[2])
          );
          break;
        case 8:
          emit_insn(
            gen_ashl<mode>3_imm8_16(operands[0], op1, operands[2])
          );
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
          emit_insn(
            gen_ashl<mode>3_imm2to15_16(operands[0], op1, operands[2])
          );
          break;
        case 16:
          emit_insn(
            gen_ashl<mode>3_imm16plus_16(operands[0], op1, operands[2])
          );
          break;
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
          emit_insn(
            gen_ashl<mode>3_imm16plus_16(operands[0], op1, operands[2])
          );
          break;
        default:
          emit_insn(
            gen_mov<mode>_16(operands[0], const0_rtx)
          ); 
          break;
      }
    } else {
      op2 = force_reg(HImode,operands[2]);
      emit_insn(
        gen_ashl<mode>3_reg_16(operands[0],op1,op2)
      );
    }
    DONE;
}")

(define_expand "ssashl<mode>3_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "")
        (ss_ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand" "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  "(!pic30_isa32_target())"
  "
  {
    rtx op1, op2;

    op1 = force_reg(GET_MODE(operands[0]),operands[1]);
    if (!pic30_fp_inline_p()) FAIL;
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0:
          emit_insn(
            gen_mov<mode>_16(operands[0], op1)
          );
          break;
        case 1:
          emit_insn(
            gen_ssashl<mode>3_imm1_16(operands[0], op1, operands[2])
          );
          break;
        case 8:
          emit_insn(
            gen_ssashl<mode>3_imm8_16(operands[0], op1, operands[2])
          );
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
          emit_insn(
            gen_ssashl<mode>3_imm2to15_16(operands[0], op1, operands[2])
          );
          break;
        case 16:
          emit_insn(
            gen_ssashl<mode>3_imm16plus_16(operands[0], op1, operands[2])
          );
          break;
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
          emit_insn(
            gen_ssashl<mode>3_imm16plus_16(operands[0], op1, operands[2])
          );
          break;
        default:
          emit_insn(
            gen_mov<mode>_16(operands[0], const0_rtx)
          ); 
          break;
      }
    } else {
      op2 = force_reg(HImode,operands[2]);
      emit_insn(
        gen_ssashl<mode>3_reg_16(operands[0],op1,op2)
      );
    }
    DONE;
}")

(define_expand "usashl<mode>3_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "")
        (us_ashift:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand" "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  "(!pic30_isa32_target())"
  "
  {
    rtx op1, op2;

    op1 = force_reg(GET_MODE(operands[0]),operands[1]);
    if (!pic30_fp_inline_p()) FAIL;
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0:
          emit_insn(
            gen_mov<mode>_16(operands[0], op1)
          );
          break;
        case 1:
          emit_insn(
            gen_usashl<mode>3_imm1_16(operands[0], op1, operands[2])
          );
          break;
        case 8:
          emit_insn(
            gen_usashl<mode>3_imm8_16(operands[0], op1, operands[2])
          );
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
          emit_insn(
            gen_usashl<mode>3_imm2to15_16(operands[0], op1, operands[2])
          );
          break;
        case 16:
          emit_insn(
            gen_usashl<mode>3_imm16plus_16(operands[0], op1, operands[2])
          );
          break;
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
          emit_insn(
            gen_usashl<mode>3_imm16plus_16(operands[0], op1, operands[2])
          );
          break;
        default:
          emit_insn(
            gen_mov<mode>(operands[0], const0_rtx)
          ); 
          break;
      }
    } else {
      op2 = force_reg(HImode,operands[2]);
      emit_insn(
        gen_usashl<mode>3_reg_16(operands[0],op1,op2)
      );
    }
    DONE;
}")

(define_insn "ashr<mode>3_helper_16"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"  "=&r,&r,&r")
        (ashiftrt:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand"   "r,r,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "Kh,i,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      switch (which_alternative) {
        case 0: 
          return \"asr %1,#%2,%0\";
        case 1:
          if (INTVAL(operands[2]) < 0)
            return \"sl %1,#%J2%%16,%0\";
          else
            return \"asr %1,#%2%%16,%0\";
        case 2: 
            return \"asr %1,%2,%0\";
        default: gcc_assert(0);
      }
    } else if (pic30_fp_round_p() == pic30_conventional) 
    switch (which_alternative) {
      case 0:  
        if (INTVAL(operands[2]) == 1) {
          return 
                 \"asr %1,%0\;\"
                 \"addc %0,#0,%0\";
        } else {
          return \"asr %1,#%L2,%0\;\"      /* shift one less than we need */
                 \"asr %0,%0\;\"           /*   so that we can shift once */
                 \"addc %0,#0,%0\";        /*   to capture and add carry */
        }
      case 1:
        if (INTVAL(operands[2]) < 0)
          return \"cannot generate instruction\"; 
        else
          return \"asr %1,#(%2%%16)-1,%0\;\" /* shift one less than we need */
                 \"asr %0,%0\;\"             /*   so that we can shift once */
                 \"addc %0,#0,%0\";          /*   to capture and add carry */
      case 2: 
	  return \"cp0 %2\;\"
                 \"mov %1,%0\;\"
                 \"bra z,.LE%=\;\"
                 \"dec %2,%0\;\"             /* shift one less than we need */
                 \"asr %1,%0,%0\;\"
                 \"asr %0,%0\;\"             /*   so that we can shift once */
                 \"addc %0,#0,%0\n\"         /*   to capture and add carry */
                 \".LE%=:\";
      default: gcc_assert(0);
    }
    else 
      error(\"Invalid fixed-point rounding mode specified\");
    return \"cannot generate instruction\";
  }"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "ashr<mode>3_convergent_16"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"  "=r,r,r")
        (ashiftrt:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand"   "r,r,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "Kh,i,r")))
   (clobber (match_scratch:HI  3                          "=&r,&r,&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent)
    switch (which_alternative) {
      case 0:  
        if (INTVAL(operands[2]) == 1) {
          return 
                 \"asr %1,%0\;\"
                 \"btsc %0,#0\;\"          /* do not add carry if low bit == 0*/
                 \"addc %0,#0,%0\";
        } else {
          return 
                 \"sl %1,%K2,%3\;\"        /* shift up bits that drop off */
                 \"asr %1,#%2,%0\;\"       /* shift down the bits we need */
                 \"sl %3,%3\;\"            /* shift top overfaow into carry */
                 \"bra nc,.L1_%=\;\"       /* if no carry, finish */
                 \"addc %0,#0,%0\;\"       /* add overflow from carry */
                 \"cp0 %3\;\"              /* test rest of the overflow */
                 \"mov #0xFFFE,%3\;\"      /* create mask off low bit */
                 \"btsc _SR,#1\;\"         /* if the rest of overflow is 0 */
                 \"and %0,%3,%0\n\"        /*   mask off low bit */
                 \".L1_%=:\";
        }
      case 1:
        if (INTVAL(operands[2]) < 0)
          return \"cannot generate instruction\"; 
        else
          return \"sl %1,#16-(%2%%16),%3\;\" /* shift up bits that drop off */
                 \"asr %1,#(%2%%16),%0\;\"   /* shift down bits we need */
                 \"sl %3,%3\;\"              /* shift top overflow into carry */
                 \"bra nc,.L1_%=\;\"         /* if no carry, finish */
                 \"addc %0,#0,%0\;\"         /* add carry */
                 \"cp0 %3\;\"                /* test rest of the overflow */
                 \"mov #0xFFFE,%3\;\"        /* create mask clear low bit */
                 \"btsc _SR,#1\;\"           /* if the rest of overflow is 0 */
                 \"and %0,%3,%0\n\"          /*   mask off low bit */
                 \".L1_%=:\";
      case 2: 
          return \"subr %2,#16,%3\;\"
                 \"sl %1,%3,%3\;\"           /* shift up bits that drop off */
                 \"asr %1,%2,%0\;\"          /* shift down bits we need */
                 \"sl %3,%3\;\"              /* shift top overflow into carry */
                 \"bra nc,.L1_%=\;\"         /* if no carry, finish */
                 \"addc %0,#0,%0\;\"         /* add carry */
                 \"cp0 %3\;\"                /* test rest of the overflow */
                 \"mov #0xFFFE,%3\;\"        /* create mask clear low bit */
                 \"btsc _SR,#1\;\"           /* if the rest of overflow is 0 */
                 \"and %0,%3,%0\n\"          /*   mask off low bit */
                 \".L1_%=:\";
      default:  gcc_assert(0);
    } else
      error(\"Invalid fixed-point round mode specified\n\");
    return \"cannot generate instruction\";

  }"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_expand "ashr<mode>3_16"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"   "")
        (ashiftrt:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand"   "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1,r2;

    r0 = operands[0];
    r1 = operands[1];
    r2 = operands[2];
    if (!pic30_register_operand(r0,<MODE>mode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,<MODE>mode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (!pic30_reg_or_imm_operand(r2,<MODE>mode)) {
      r2 = force_reg(HImode, r2);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_ashr<mode>3_convergent_16(r0,r1,r2)
      );
    } else {
      emit(
        gen_ashr<mode>3_helper_16(r0,r1,r2)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }"
)

(define_expand "ashr<mode>3_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand"   "")
        (ashiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"   "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  "(!pic30_isa32_target())"
  "
  {
    rtx op1, op2;

    op1 = force_reg(GET_MODE(operands[0]),operands[1]);
    if ((pic30_fp_round_p() == pic30_conventional) ||
        (pic30_fp_round_p() == pic30_convergent)) 
      FAIL;
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0:
          emit_insn(
            gen_mov<mode>_16(operands[0], op1)
          );
          break;
        case 1:
          emit_insn(
            gen_ashr<mode>3_imm1_16(operands[0], op1, operands[2])
          );
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
          emit_insn(
            gen_ashr<mode>3_imm2to15_16(operands[0], op1, operands[2])
          );
          break;
        case 16:
          emit_insn(
            gen_ashr<mode>3_imm16plus_16(operands[0], op1, operands[2])
          );
          break;
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
          if (pic30_fp_round_p() == pic30_convergent) {
            emit_insn(
              gen_ashr<mode>3_imm16plus_convergent_16(operands[0], op1, 
                                                   operands[2])
            );
          } else {
            emit_insn(
              gen_ashr<mode>3_imm16plus_16(operands[0], op1, operands[2])
            );
          }
          break;
        default:
          emit_insn(
            gen_mov<mode>_16(operands[0], const0_rtx)
          );
          break;
      }
    } else {
      {
        op2 = force_reg(HImode,operands[2]);
        emit_insn(
          gen_ashr<mode>3_reg_16(operands[0],op1,op2)
        );
      }
    }
    DONE;
  }"
)

(define_insn "ashr<mode>3_imm1_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (ashiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_I_operand"         "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_fp_round_p() == pic30_truncation) ||
       (pic30_fp_round_p() == pic30_fastest)) {
     return \"asr %d1,%d0\;rrc %1,%0\";
   } else if (pic30_fp_round_p() == pic30_conventional) {
     return 
            \"asr %d1,%d0\;\"       /* shift right ... */
            \"rrc %1,%0\;\"
            \"addc %0,#0,%0\;\"     /* add in drop overflow bit */
            \"addc %d0,#0,%d0\;\";
   } else if (pic30_fp_round_p() == pic30_convergent) {
     return 
            \"asr %d1,%d0\;\"       /* shift right ... */
            \"rrc %1,%0\;\"
            \"btsc %0,#0\;\"        /* if bit 0 is 0 */
            \"bclr _SR,#0\;\"       /*   clear overflow bit */
            \"addc %0,#0,%0\;\"     /* add in drop overflow bit */
            \"addc %d0,#0,%d0\;\";
   }
   error(\"Invalid fixed-point round mode specified\n\");
   return \"cannot generate instruction\";
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashr<mode>3_imm2to15_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (ashiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_imm2to15_operand"  "i")))
   (clobber (match_scratch:HI  3                         "=&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      /*
      ** Take care that the source and dest don't overlap
      */
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        return \"sl %d1,#%k2,%3\;\"
               \"lsr %1,#%2,%0\;\"
               \"ior %3,%0,%0\;\"
               \"asr %d1,#%2,%d0\";
      } else {
        return \"asr %d1,#%2,%d0\;\"
               \"sl %d1,#%k2,%3\;\"
               \"lsr %1,#%2,%0\;\"
               \"ior %3,%0,%0\";
      }
    } else if (pic30_fp_round_p() == pic30_conventional) {
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        /* reorder a bit to preserve C for overflow */
        return \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"asr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"lsr %1,#%L2,%0\;\"    /* shift down low bits of low word,
                                          1 less (clearing upper bits) */
               \"lsr %0,%0\;\"         /* final shift, capturing overflow in C*/
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* add in overflow */
               \"addc %d0,#0,%d0\;\";
      } else {
        return \"asr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"lsr %1,#%L2,%0\;\"    /* shift down low bits of low word,
                                          1 less (clearing upper bits) */
               \"lsr %0,%0\;\"         /* final shift, capturing overflow in C*/
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* add in overflow */
               \"addc %d0,#0,%d0\;\";
      }
    } else if (pic30_fp_round_p() == pic30_convergent) {
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        /* reorder a bit to preserve C for overflow */
        return \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"asr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"sl  %1,#%K2,%0\;\"    /* shift up low bits (that drop) */
               \"sl  %0,%0\;\"         /* shift topmost into carry */
               \"btsc _SR,#1\;\"       /* if zero clear carry */
               \"bclr _SR,#0\;\"
               \"lsr %1,#%2,%0\;\"     /* shift down low bits of low word */
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* maybe add in overflow */
               \"addc %d0,#0,%d0\;\";
      } else {
        return \"asr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"sl  %0,%0\;\"         /* shift topmost into carry */
               \"btsc _SR,#1\;\"       /* if zero clear carry */
               \"bclr _SR,#0\;\"
               \"lsr %1,#%2,%0\;\"     /* shift down low bits of low word */
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* add in overflow */
               \"addc %d0,#0,%d0\;\";
      }
    } else
      error(\"Invalid fixed-point round mode specified\n\");
    return \"cannot generate instruction\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashr<mode>3_imm16plus_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (ashiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_imm16plus_operand" "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       return \"asr %d1,#%K2,%0\;asr %0,#15,%d0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       if (INTVAL(operands[2]) == 16) {
         return 
                \"mov %d1,%0\;\"         /* copy high word to low result */
                \"asr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"btst.c %1,#15\;\"      /* copy overflow bit to carry */
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       } else {
         return 
                \"asr %d1,#%K2,%0\;\"    /* copy high word to low result */
                \"asr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"btst.c %d1,#(%K2)-1\;\"/* copy overflow bit to carry */
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       }
     } else
       error(\"Invalid fixed-point round mode specified\n\");
     return \"cannot generate instruction\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashr<mode>3_imm16plus_convergent_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (ashiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_imm16plus_operand" "i")))
   (clobber (match_scratch:HI  3                          "=r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     if (pic30_fp_round_p() == pic30_convergent) {
       if (INTVAL(operands[2]) == 16) {
         return 
                \"mov %d1,%0\;\"         /* copy high word to low result */
                \"asr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"sl %1,%3\;\"           /* shift up dropped off bits */
                \"btsc _SR,#1\;\"        /* if zero clear carry */
                \"bclr _SR,#0\;\"
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       } else {
         return 
                \"asr %d1,#%K2,%0\;\"    /* copy high word to low result */
                \"asr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"sl %d1,#%K2,%3\;\"     /* shift up dropped off bits */
                \"btsc _SR,#1\;\"        /* if zero clear carry */
                \"bclr _SR,#0\;\"
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       }
     } else
       error(\"Invalid fixed-point round mode specified\n\");
     return \"cannot generate instruction\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "ashr<mode>3_reg_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (ashiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "0")
          (match_operand:HI    2 "pic30_register_operand"  "r")))
   (clobber (match_scratch:HI  3                          "=2"))
   (clobber (match_scratch:HI  4                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \".set ___BP___,0\n\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra n,.LE%=\;\"
             \"asr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"bra .LB%=\n\"
             \".LE%=:\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \".set ___BP___,0\n\"
             \"cp0 %2\;\"
             \"bra z,.LE%=\;\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra z,.LF%=\;\"
             \"asr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"bra .LB%=\n\"
             \".LF%=:\;\"
             \"asr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"addc %0,#0,%0\;\"    
             \"addc %d0,#0,%d0\n\"
             \".LE%=:\;\";
    } else if (pic30_fp_round_p() == pic30_convergent) {
      /* I would have liked to have this as a separate pattern; but
         it conflicts with ashr<mode>3_reg even though this would have had
         one more clobber - now they have the same */
      return 
             \"clr %4\;\"              /* clear overflow holder */
             \".set ___BP___,0\n\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra n,.LE%=\;\"
             \"asr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"rrc %4,%4\;\"           /* store overflow bits */
             \"bra .LB%=\n\"
             \".LE%=:\;\"
             \"sl %4,%4\"              /* check overflow */
             \"btsc _SR,#1\;\"         /* if zero clear carry */
             \"bclr _SR,#0\;\"
             \"addc %0,#0,%0\;\"
             \"addc %d0,#0,%d0\";
      
    } else
      error(\"Invalid fixed-point round mode specified\n\");
    return \"cannot generate instruction\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

; logical shift right

(define_insn "lshr<mode>3_helper_16"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"  "=r,r,&r")
        (lshiftrt:QUQ15 
          (match_operand:QUQ15 1 "pic30_register_operand"   "r,r, r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "Kh,i, r")))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      switch (which_alternative) {
        case 0: 
          return \"lsr %1,#%2,%0\";
        case 1:
          if (INTVAL(operands[2]) < 0)
            return \"sl %1,#%J2%%16,%0\";
          else
            return \"lsr %1,#%2%%16,%0\";
        case 2: 
            return \"lsr %1,%2,%0\";
        default: gcc_assert(0);
      }
    } else if (pic30_fp_round_p() == pic30_conventional) 
    switch (which_alternative) {
      case 0:  
        if (INTVAL(operands[2]) == 1) {
          return 
                 \"lsr %1,%0\;\"
                 \"addc %0,#0,%0\";
        } else {
          return \"lsr %1,#%L2,%0\;\"      /* shift one less than we need */
                 \"lsr %1,%0\;\"           /*   so that we can shift once */
                 \"addc %0,#0,%0\";        /*   to capture and add carry */
        }
      case 1:
        if (INTVAL(operands[2]) < 0)
          return \"cannot generate instruction\"; 
        else
          return \"lsr %1,#(%2%%16)-1,%0\;\" /* shift one less than we need */
                 \"lsr %1,%0\;\"             /*   so that we can shift once */
                 \"addc %0,#0,%0\";          /*   to capture and add carry */
      case 2: 
	  return \"cp0 %2\;\"
                 \"mov %1,%0\;\"
                 \"bra z,.LE%=\;\"
                 \"dec %2,%0\;\"             /* shift one less than we need */
                 \"lsr %1,%0,%0\;\"
                 \"lsr %0,%0\;\"             /*   so that we can shift once */
                 \"addc %0,#0,%0\n\"         /*   to capture and add carry */
                 \".LE%=:\";
      default: gcc_assert(0);
    }
    else 
      error(\"Invalid fixed-point rounding mode specified\");
    return \"cannot generate instruction\";
  }"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_insn "lshr<mode>3_convergent_16"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"  "=r,r,r")
        (lshiftrt:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand"   "r,r,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "Kh,i,r")))
   (clobber (match_scratch:HI  3                          "=&r,&r,&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if (pic30_fp_round_p() == pic30_convergent)
    switch (which_alternative) {
      case 0:  
        if (INTVAL(operands[2]) == 1) {
          return 
                 \"lsr %1,%0\;\"
                 \"btsc %0,#0\;\"          /* do not add carry if low bit == 0*/
                 \"addc %0,#0,%0\";
        } else {
          return 
                 \"sl %1,%K2,%3\;\"        /* shift up bits that drop off */
                 \"lsr %1,#%2,%0\;\"       /* shift down the bits we need */
                 \"sl %3,%3\;\"            /* shift top overflow into carry */
                 \"addc %0,#0,%0\;\"       /* add overflow from carry */
                 \"cp0 %3\;\"              /* test rest of the overflow */
                 \"mov #0xFFFE,%3\;\"      /* create mask off low bit */
                 \"btsc _SR,#1\;\"         /* if the rest of overflow is 0 */
                 \"and %0,%3,%0\n\"        /*   mask off low bit */
                 \".L1_%=:\";

        }
      case 1:
        if (INTVAL(operands[2]) < 0)
          return \"cannot generate instruction\"; 
        else
          return \"sl %1,#16-(%2%%16),%3\;\" /* shift up bits that drop off */
                 \"lsr %1,#(%2%%16),%0\;\"   /* shift down bits we need */
                 \"sl %3,%3\;\"              /* shift top overflow into carry */
                 \"bra nc,.L1_%=\;\"         /* if no carry, finish */
                 \"addc %0,#0,%0\;\"         /* add carry */
                 \"cp0 %3\;\"                /* test rest of the overflow */
                 \"mov #0xFFFE,%3\;\"        /* create mask clear low bit */
                 \"btsc _SR,#1\;\"           /* if the rest of overflow is 0 */
                 \"and %0,%3,%0\n\"          /*   mask off low bit */
                 \".L1_%=:\";

      case 2: 
          return \"subr %2,#16,%3\;\"
                 \"sl %1,%3,%3\;\"           /* shift up bits that drop off */
                 \"lsr %1,%2,%0\;\"          /* shift down bits we need */
                 \"sl %3,%3\;\"              /* shift top overflow into carry */
                 \"bra nc,.L1_%=\;\"         /* if no carry, finish */
                 \"addc %0,#0,%0\;\"         /* add carry */
                 \"cp0 %3\;\"                /* test rest of the overflow */
                 \"mov #0xFFFE,%3\;\"        /* create mask clear low bit */
                 \"btsc _SR,#1\;\"           /* if the rest of overflow is 0 */
                 \"and %0,%3,%0\n\"          /*   mask off low bit */
                 \".L1_%=:\";
       default: gcc_assert(0);
    } else
      error(\"Invalid fixed-point round mode specified\n\");
    return \"cannot generate instruction\";

  }"
  [
   (set_attr "cc" "math")
   (set_attr "type" "def")
  ]
)

(define_expand "lshr<mode>3_16"
  [(set (match_operand:QUQ15   0 "pic30_register_operand"   "")
        (lshiftrt:QUQ15
          (match_operand:QUQ15 1 "pic30_register_operand"   "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  "(!pic30_isa32_target())"
  "
  { rtx r0,r1,r2;

    r0 = operands[0];
    r1 = operands[1];
    r2 = operands[2];
    if (!pic30_register_operand(r0,<MODE>mode)) {
      r0 = gen_reg_rtx(<MODE>mode);
    }
    if (!pic30_register_operand(r1,<MODE>mode)) {
      r1 = force_reg(<MODE>mode, r1);
    }
    if (!pic30_reg_or_imm_operand(r2,<MODE>mode)) {
      r2 = force_reg(HImode, r2);
    }
    if (pic30_fp_round_p() == pic30_convergent) {
      emit(
        gen_lshr<mode>3_convergent_16(r0,r1,r2)
      );
    } else {
      emit(
        gen_lshr<mode>3_helper_16(r0,r1,r2)
      );
    }
    if (r0 != operands[0]) {
      emit_move_insn(operands[0],r0);
    }
    DONE;
  }"
)

(define_expand "lshr<mode>3_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand"   "")
        (lshiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"   "")
          (match_operand:HI    2 "pic30_reg_or_imm_operand" "")))]
  "(!pic30_isa32_target())"
  "
  {
    rtx op1, op2;

    op1 = force_reg(GET_MODE(operands[0]),operands[1]);
    if ((pic30_fp_round_p() == pic30_conventional) ||
        (pic30_fp_round_p() == pic30_convergent)) 
      FAIL;
    if (GET_CODE(operands[2]) == CONST_INT) {
      switch (INTVAL(operands[2])) {
        case 0:
          emit_insn(
            gen_mov<mode>_16(operands[0], op1)
          );
          break;
        case 1:
          emit_insn(
            gen_lshr<mode>3_imm1_16(operands[0], op1, operands[2])
          );
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
          emit_insn(
            gen_lshr<mode>3_imm2to15_16(operands[0], op1, operands[2])
          );
          break;
        case 16:
          emit_insn(
            gen_lshr<mode>3_imm16plus_16(operands[0], op1, operands[2])
          );
          break;
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
          if (pic30_fp_round_p() == pic30_convergent) {
            emit_insn(
              gen_lshr<mode>3_imm16plus_convergent_16(operands[0], op1, 
                                                   operands[2])
            );
          } else {
            emit_insn(
              gen_lshr<mode>3_imm16plus_16(operands[0], op1, operands[2])
            );
          }
          break;
        default:
          emit_insn(
            gen_mov<mode>_16(operands[0], const0_rtx)
          );
          break;
      }
    } else {
      {
        op2 = force_reg(HImode,operands[2]);
        emit_insn(
          gen_lshr<mode>3_reg_16(operands[0],op1,op2)
        );
      }
    }
    DONE;
  }"
)

(define_insn "lshr<mode>3_imm1_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (lshiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_I_operand"         "I")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   if ((pic30_fp_round_p() == pic30_truncation) ||
       (pic30_fp_round_p() == pic30_fastest)) {
     return \"asr %d1,%d0\;rrc %1,%0\";
   } else if (pic30_fp_round_p() == pic30_conventional) {
     return 
            \"lsr %d1,%d0\;\"       /* shift right ... */
            \"rrc %1,%0\;\"
            \"addc %0,#0,%0\;\"     /* add in drop overflow bit */
            \"addc %d0,#0,%d0\;\";
   } else if (pic30_fp_round_p() == pic30_convergent) {
     return 
            \"lsr %d1,%d0\;\"       /* shift right ... */
            \"rrc %1,%0\;\"
            \"btsc %0,#0\;\"        /* if bit 0 is 0 */
            \"bclr _SR,#0\;\"       /*   clear overflow bit */
            \"addc %0,#0,%0\;\"     /* add in drop overflow bit */
            \"addc %d0,#0,%d0\;\";
   }
   error(\"Invalid fixed-point rounding mode specified\");
   return \"nop\";
  "
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshr<mode>3_imm2to15_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (lshiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_imm2to15_operand"  "i")))
   (clobber (match_scratch:HI  3                         "=&r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      /*
      ** Take care that the source and dest don't overlap
      */
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        return \"sl %d1,#%k2,%3\;\"
               \"lsr %1,#%2,%0\;\"
               \"ior %3,%0,%0\;\"
               \"lsr %d1,#%2,%d0\";
      } else {
        return \"lsr %d1,#%2,%d0\;\"
               \"sl %d1,#%k2,%3\;\"
               \"lsr %1,#%2,%0\;\"
               \"ior %3,%0,%0\";
      }
    } else if (pic30_fp_round_p() == pic30_conventional) {
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        /* reorder a bit to preserve C for overflow */
        return \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"lsr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"lsr %1,#%L2,%0\;\"    /* shift down low bits of low word,
                                          1 less (clearing upper bits) */
               \"lsr %0,%0\;\"         /* final shift, capturing overflow in C*/
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* add in overflow */
               \"addc %d0,#0,%d0\;\";
      } else {
        return \"lsr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"lsr %1,#%L2,%0\;\"    /* shift down low bits of low word,
                                          1 less (clearing upper bits) */
               \"lsr %0,%0\;\"         /* final shift, capturing overflow in C*/
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* add in overflow */
               \"addc %d0,#0,%d0\;\";
      }
    } else if (pic30_fp_round_p() == pic30_convergent) {
      if (REGNO(operands[0]) <= REGNO(operands[1])) {
        /* reorder a bit to preserve C for overflow */
        return \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"lsr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"sl  %1,#%K2,%0\;\"    /* shift up low bits (that drop) */
               \"sl  %0,%0\;\"         /* shift topmost into carry */
               \"btsc _SR,#1\;\"       /* if zero clear carry */
               \"bclr _SR,#0\;\"
               \"lsr %1,#%2,%0\;\"     /* shift down low bits of low word */
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* maybe add in overflow */
               \"addc %d0,#0,%d0\;\";
      } else {
        return \"lsr %d1,#%2,%d0\;\"   /* shift down high bits of high word
                                          making the high part of result */
               \"sl %d1,#%k2,%3\;\"    /* shift up low bits of high word to t */
               \"sl  %0,%0\;\"         /* shift topmost into carry */
               \"btsc _SR,#1\;\"       /* if zero clear carry */
               \"bclr _SR,#0\;\"
               \"lsr %1,#%2,%0\;\"     /* shift down low bits of low word */
               \"ior %3,%0,%0\;\"      /* or in high bits of low word from t */
               \"addc %0,#0,%0\;\"     /* add in overflow */
               \"addc %d0,#0,%d0\;\";
      }
    } else
      error(\"Invalid fixed-point round mode specified\n\");
    return \"cannot generate instruction\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshr<mode>3_imm16plus_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (lshiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_imm16plus_operand" "i")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     if ((pic30_fp_round_p() == pic30_truncation) ||
         (pic30_fp_round_p() == pic30_fastest)) {
       return \"asr %d1,#%K2,%0\;asr %0,#15,%d0\";
     } else if (pic30_fp_round_p() == pic30_conventional) {
       if (INTVAL(operands[2]) == 16) {
         return 
                \"mov %d1,%0\;\"         /* copy high word to low result */
                \"lsr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"btst.c %1,#15\;\"      /* copy overflow bit to carry */
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       } else {
         return 
                \"asr %d1,#%K2,%0\;\"    /* copy high word to low result */
                \"lsr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"btst.c %d1,#(%K2)-1\;\"/* copy overflow bit to carry */
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       }
     } else
       error(\"Invalid fixed-point round mode specified\n\");
     return \"cannot generate instruction\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshr<mode>3_imm16plus_convergent_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=&r")
        (lshiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "r")
          (match_operand:HI    2 "pic30_imm16plus_operand" "i")))
   (clobber (match_scratch:HI  3                          "=r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   {
     if (pic30_fp_round_p() == pic30_convergent) {
       if (INTVAL(operands[2]) == 16) {
         return 
                \"mov %d1,%0\;\"         /* copy high word to low result */
                \"lsr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"sl %1,%3\;\"           /* shift up dropped off bits */
                \"btsc _SR,#1\;\"        /* if zero clear carry */
                \"bclr _SR,#0\;\"
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       } else {
         return 
                \"asr %d1,#%K2,%0\;\"    /* copy high word to low result */
                \"lsr %0,#15,%d0\;\"     /* shift down sign to high result */
                \"sl %d1,#%K2,%3\;\"     /* shift up dropped off bits */
                \"btsc _SR,#1\;\"        /* if zero clear carry */
                \"bclr _SR,#0\;\"
                \"addc %0,#0,%0\;\"      /* add in overflow bit */
                \"addc %d0,#0,%d0\";
       }
     } else
       error(\"Invalid fixed-point round mode specified\n\");
     return \"cannot generate instruction\";
   }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

(define_insn "lshr<mode>3_reg_16"
  [(set (match_operand:QUQ31   0 "pic30_register_operand" "=r")
        (lshiftrt:QUQ31 
          (match_operand:QUQ31 1 "pic30_register_operand"  "0")
          (match_operand:HI    2 "pic30_register_operand"  "r")))
   (clobber (match_scratch:HI  3                          "=2"))
   (clobber (match_scratch:HI  4                          "=&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    if ((pic30_fp_round_p() == pic30_truncation) ||
        (pic30_fp_round_p() == pic30_fastest)) {
      return \".set ___BP___,0\n\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra n,.LE%=\;\"
             \"lsr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"bra .LB%=\n\"
             \".LE%=:\";
    } else if (pic30_fp_round_p() == pic30_conventional) {
      return \".set ___BP___,0\n\"
             \"cp0 %2\;\"
             \"bra z,.LE%=\;\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra z,.LF%=\;\"
             \"lsr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"bra .LB%=\n\"
             \".LF%=:\;\"
             \"asr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"addc %0,#0,%0\;\"    
             \"addc %d0,#0,%d0\n\"
             \".LE%=:\;\";
    } else if (pic30_fp_round_p() == pic30_convergent) {
      /* I would have liked to have this as a separate pattern; but
         it conflicts with lshr<mode>3_reg even though this would have had
         one more clobber - now they have the same */
      return 
             \"clr %4\;\"              /* clear overflow holder */
             \".set ___BP___,0\n\"
             \".LB%=:\;\"
             \"dec %2,%2\;\"
             \"bra n,.LE%=\;\"
             \"lsr %d1,%d0\;\"
             \"rrc %1,%0\;\"
             \"rrc %4,%4\;\"           /* store overflow bits */
             \"bra .LB%=\n\"
             \".LE%=:\;\"
             \"sl %4,%4\"              /* check overflow */
             \"btsc _SR,#1\;\"         /* if zero clear carry */
             \"bclr _SR,#0\;\"
             \"addc %0,#0,%0\;\"
             \"addc %d0,#0,%d0\";
      
    } else
      error(\"Invalid fixed-point round mode specified\n\");
    return \"cannot generate instruction\";
  }"
  [
   (set_attr "cc" "clobber")
   (set_attr "type" "def")
  ]
)

; compare

(define_insn "cmp<mode>_imm_16"
  [(set (reg:CC CC_REG)
        (compare
          (match_operand:QUQ15 0 "pic30_register_operand" "r")  
          (match_operand:QUQ15 1 "pic30_M_operand"        "M"))) 
   (clobber (match_dup 0))]
  "(!pic30_isa32_target())"
  "add #%J1,%0"
  [(set_attr "cc" "set")])
   
(define_insn "cmp<mode>_sfr0_16"
  [(set (reg:CC CC_REG)
        (compare 
          (match_operand:QUQ15 0 "pic30_reg_or_near_operand" "U,r")
          (match_operand:QUQ15 1 "pic30_register_operand"    "a,r")))]
  "(!pic30_isa32_target())"
  "@
   cp %0
   sub %0,%1,[w15]"
  [(set_attr "cc" "set")])
  
(define_insn "cmp<mode>_16"
  [(set (reg:CC CC_REG)
        (compare 
          (match_operand:QUQ15 0 "pic30_mode2_operand"   "r,r,  R<>,r,r")
          (match_operand:QUQ15 1 "pic30_mode1PN_operand" "r,R<>,r,  P,N")))]
  "(!pic30_isa32_target())"
  "@
   sub %0,%1,[w15]
   sub %0,%1,[w15]
   subr %1,%0,[w15]
   sub %0,#%1,[w15]
   add %0,#%J1,[w15]"
  [ 
   (set_attr "cc" "set")
   (set_attr "type" "etc,use,use,etc,etc")
  ]
) 

(define_insn "cmp<mode>_helper_16"
  [(set (reg:CC CC_REG)
        (compare 
          (match_operand:QUQ31 0 "pic30_mode2mres_operand" "r,r,R,r,>")
          (match_operand:QUQ31 1 "pic30_mode2mres_operand" "r,R,r,>,r")))]
  "(!pic30_isa32_target())"
  "*
{
  static const char *patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;subb %d0,%D1,[w15]\",
     \"subr %1,%I0,[w15]\;subbr %d1,%D0,[w15]\",
     \"sub %0,%1,[w15]\;subb %d0,%1,[w15]\",
     \"subr %1,%0,[w15]\;subbr %d1,%0,[w15]\",
  0 };

  static const char *psrd_psrd_patterns[] = {
     \"sub %0,%1,[w15]\;subb %d0,%d1,[w15]\",
     \"sub %0,%I1,[w15]\;nop\;subb %d0,%D1,[w15]\",
     \"subr %1,%I0,[w15]\;nop\;subbr %d1,%D0,[w15]\",
     \"sub %0,%1,[w15]\;nop\;subb %d0,%1,[w15]\",
     \"subr %1,%0,[w15]\;nop\;subbr %d1,%0,[w15]\",
  0 };

  if (pic30_psrd_psrd_errata(operands[0],operands[1])) {
    pic30_rtx_nops++;
    return psrd_psrd_patterns[which_alternative];
  } else {
  return patterns[which_alternative];
  }
}"
  [(set_attr "cc" "set")])

(define_insn "cmp<mode>_zero_16"
  [(set (reg:CC CC_REG)
        (compare 
          (match_operand:QUQ31 0 "pic30_register_operand" "r")
          (match_operand:QUQ31 1 "pic30_O_operand"        "fO")))]
  "(!pic30_isa32_target())"
  "sub %0,#0,[w15]\;subb %d0,#0,[w15]"
  [(set_attr "cc" "set")])

(define_insn "cmp<mode>_immNP_16"
  [(set (reg:CC CC_REG)
        (compare 
          (match_operand:QUQ31 0 "pic30_register_operand"  "r,r,r")
          (match_operand:QUQ31 1 "immediate_operand"       "P,N,i")))]
  "(((-31 <= INTVAL(operands[1])) && (INTVAL(operands[1]) <= 31)) ||
    ((0xFFE1 <= INTVAL(operands[1])) && (INTVAL(operands[1]) <= 0xFFFF))) &&
   (INTVAL(operands[1]) != 0)"
  "@
   sub %0,#%1,[w15]\;subb %d0,#0,[w15]
   add %0,#%J1,[w15]\;addc %d0,#0,[w15]
   add %0,#%j1,[w15]\;subb %d0,#0,[w15]"
  [(set_attr "cc" "set")])

(define_insn "cmp<mode>_imm_16"
  [(set (reg:CC CC_REG)
        (compare 
          (match_operand:QUQ31 0 "pic30_register_operand"  "r")
          (match_operand:QUQ31 1 "immediate_operand"       "i")))
   (clobber (match_scratch:HI  2                         "=&r"))]
  "((1<INTVAL(operands[1])) && (INTVAL(operands[1])<65536))"
  "mov #%1,%2\;sub %0,%2,[w15]\;subb %d0,#0,[w15]"
  [(set_attr "cc" "set")])

(define_expand "cmp<mode>_16"
  [(set (reg:CC CC_REG)
        (compare 
          (match_operand:QUQ31 0 "pic30_mode2mres_operand" "")
          (match_operand:QUQ31 1 "pic30_mode2mres_operand" "")))]
  "(!pic30_isa32_target())"
  "
{
  if (pic30_mode2mres_operand(operands[1], <MODE>mode)) {
    emit(
      gen_cmp<mode>_helper_16(operands[0],operands[1])
    );
  } else if (immediate_operand(operands[1],VOIDmode)) {
    rtx reg_0 = force_reg(<MODE>mode,operands[0]);
    if (INTVAL(operands[1]) == 0) {
      emit(
        gen_cmp<mode>_zero_16(reg_0, operands[1])
      );
    } else {
      rtx reg = force_reg(<MODE>mode,operands[1]);
      emit( 
        gen_cmp<mode>_helper_16(reg_0, reg)
      );
    }
  }
  DONE;
}")

; Fixed Point Accum

;; *** load/store

(define_insn "mov<mode>_rimm_16"
   [(set (match_operand:AUACC  0 "pic30_accum_or_reg_operand" "=w,?????w,???r")
         (match_operand:AUACC  1 "immediate_operand"           "fO,    i,   i"))
    (clobber (match_scratch:HI 2                              "=X,     &r,  X"))
   ]
   "(!pic30_isa32_target())"
   "*
    {
      int zero = 0;

      zero = (CONST_FIXED_VALUE_LOW(operands[1]) == 0) &&
             (CONST_FIXED_VALUE_HIGH(operands[1]) == 0);
      if (REGNO(operands[0]) == A_REGNO) {
        if (zero) {
          return \"clr A\";
        } else {
          return 
               \"mov #%z1,%2\;\"
               \"mov %2,ACCAL\;\"
               \"mov #%y1,%2\;\"
               \"mov %2,ACCAH\;\"
               \"mov #%x1,%2\;\"
               \"mov %2,ACCAU\";
        }
      } else if (REGNO(operands[0]) == B_REGNO) {
        if (zero) {
          return \"clr B\";
        } else {
          return 
               \"mov #%z1,%2\;\"
               \"mov %2,ACCBL\;\"
               \"mov #%y1,%2\;\"
               \"mov %2,ACCBH\;\"
               \"mov #%x1,%2\;\"
               \"mov %2,ACCBU\";
        }
      } else {
        if (zero) {
          return 
               \"mul.uu %0,#0,%0\;\"
               \"mov.b #%x1,%t0\";
        } else {
          return 
               \"mov #%z1,%0\;\"
               \"mov #%y1,%d0\;\"
               \"mov #%x1,%t0\";
        }
      }
    }"
)

(define_insn "reload<mode>_imm_16"
   [(set (match_operand:AUACC  0 "pic30_accumulator_operand" "= w")
         (match_operand:AUACC  1 "immediate_operand"         "  i"))
    (clobber (match_operand:HI 2 "pic30_register_operand"    "=&r"))
   ]
   "(!pic30_isa32_target())"
   "*
    {
      int zero = 0;

      zero = (CONST_FIXED_VALUE_LOW(operands[1]) == 0) &&
             (CONST_FIXED_VALUE_HIGH(operands[1]) == 0);
      if (REGNO(operands[0]) == A_REGNO) {
        if (zero) {
          return \"clr A\";
        } else {
          return
               \"mov #%z1,%2\;\"
               \"mov %2,ACCAL\;\"
               \"mov #%y1,%2\;\"
               \"mov %2,ACCAH\;\"
               \"mov #%x1,%2\;\"
               \"mov %2,ACCAU\";
        }
      } else if (REGNO(operands[0]) == B_REGNO) {
        if (zero) {
          return \"clr B\";
        } else {
          return
               \"mov #%z1,%2\;\"
               \"mov %2,ACCBL\;\"
               \"mov #%y1,%2\;\"
               \"mov %2,ACCBH\;\"
               \"mov #%x1,%2\;\"
               \"mov %2,ACCBU\";
        }
      } else {
        gcc_assert(0);
      }
    }"
)

(define_insn "reloadsi_imm_16"
   [(set (match_operand:SI     0 "pic30_accumulator_operand" "= w")
         (match_operand:SI     1 "immediate_operand"         "  i"))
    (clobber (match_operand:HI 2 "pic30_register_operand"    "=&r"))
   ]
   "(!pic30_isa32_target())"
   "*
    {
      int zero = 0;

      zero = (CONST_FIXED_VALUE_LOW(operands[1]) == 0) &&
             (CONST_FIXED_VALUE_HIGH(operands[1]) == 0);
      if (REGNO(operands[0]) == A_REGNO) {
        if (zero) {
          return \"clr A\";
        } else {
          return
               \"mov #%z1,%2\;\"
               \"mov %2,ACCAL\;\"
               \"mov #%y1,%2\;\"
               \"mov %2,ACCAH\;\";
        }
      } else if (REGNO(operands[0]) == B_REGNO) {
        if (zero) {
          return \"clr B\";
        } else {
          return
               \"mov #%z1,%2\;\"
               \"mov %2,ACCBL\;\"
               \"mov #%y1,%2\;\"
               \"mov %2,ACCBH\;\";
        }
      } else {
        gcc_assert(0);
      }
    }"
)

; NB: like movsi_gen this does not cover all possible versions of move_operand
;     ugh

(define_insn "mov<mode>_gen_16"
   [(set
      (match_operand:AUACC 0 
         "pic30_move_operand" "=wr,????wr,????wr,????R, >, >, wr,  <, r, Q")
      (match_operand:AUACC 1 
         "pic30_move_operand"  "wr,     R,     >,   wr,wr, >,  <, wr, Q, r"))
   
   (clobber (reg:CC_NZC CC_REG))
  ]
   "(!pic30_isa32_target())"
   "*
    switch (which_alternative) {
      default: gcc_assert(0);

      case 0:  /* wr,wr */
               if (pic30_accumulator_operand(operands[0],
                                             <MODE>mode) &&
                   pic30_accumulator_operand(operands[1],
                                             <MODE>mode)) {
                 /* saturation mode doesn't matter... we won't overflow */
                 if (REGNO(operands[0]) == A_REGNO) {
                   return \"clr A\;\"
                          \"add A\";
                 } else if (REGNO(operands[0]) == B_REGNO) {
                   return \"clr B\;\"
                          \"add B\";
                 } else gcc_assert(0);
               } else if (pic30_accumulator_operand(operands[0],
                                                    <MODE>mode)) {
                 if (REGNO(operands[0]) == A_REGNO) {
                   return \"mov %1,ACCAL\;\"
                          \"mov %d1,ACCAH\;\"
                          \"mov %t1,ACCAU\";
                 } else if (REGNO(operands[0]) == B_REGNO) {
                   return \"mov %1,ACCBL\;\"
                          \"mov %d1,ACCBH\;\"
                          \"mov %t1,ACCBU\";
                 } else gcc_assert(0);
               } else if (pic30_accumulator_operand(operands[1],
                                                    <MODE>mode)) {
                 if (REGNO(operands[1]) == A_REGNO) {
                   return \"mov ACCAL,%0\;\"
                          \"mov ACCAH,%d0\;\"
                          \"mov ACCAU,%t0\";
                 } else if (REGNO(operands[1]) == B_REGNO) {
                   return \"mov ACCBL,%0\;\"
                          \"mov ACCBH,%d0\;\"
                          \"mov ACCBU,%t0\";
                 } else gcc_assert(0);
               } else {
                 /* Try and prevent clobbering, apparently using an &
                    early clobber confuses reload */
                 /* op0 and op1 regnos will only be even ... */
                 if (REGNO(operands[0]) == REGNO(operands[1])) {
                   return \"; nop\";
                 } else if (REGNO(operands[0]) == REGNO(operands[1])+2) {
                   return \"mov.b %t1,%t0\;\"
                          \"mov.d %1,%0\";
                 } /* else the other overlap doesn't matter */ 
                 return \"mov.d %1,%0\;\"
                        \"mov.b %t1,%t0\";
               }
               break;
      case 1:  /* wr,R */
               if (pic30_accumulator_operand(operands[0],
                                             <MODE>mode)) {
                 if (REGNO(operands[0]) == A_REGNO) {
                   return \"mov %I1,[w15++]\;\"
                          \"pop ACCAL\;\"
                          \"mov %I1,[W15++]\;\"
                          \"pop ACCAH\;\"
                          \"mov %D1,[W15++]\;\"
                          \"pop ACCAU\;\"
                          \"dec2 %r1,%r1\";
                 } else if (REGNO(operands[0]) == B_REGNO) {
                   return \"mov %I1,[w15++]\;\"
                          \"pop ACCBL\;\"
                          \"mov %I1,[W15++]\;\"
                          \"pop ACCBH\;\"
                          \"mov %D1,[W15++]\;\"
                          \"pop ACCBU\;\"
                          \"dec2 %r1,%r1\";
                 } else gcc_assert(0);
               } else {
                 /* Try and prevent clobbering, apparently using an
                    & earlyclobber confuses reload */
                 unsigned int index;
                 index = REGNO(XEXP(operands[1],0));
                 if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                   pic30_rtx_nops+=2;
                 if (index == REGNO(operands[0])) {
                   /* write to the index register last */
                   return \"mov %Q1,%d0\;\"
                            \"nop\;\"
                          \"mov.b %R1,%t0\;\"
                            \"nop\;\"
                          \"mov %1,%0\";
                 } else if (index == REGNO(operands[0])+1) {
                   /* write to the index+1 register last */
                   return \"mov.b %R1,%t0\;\"
                            \"nop\;\"
                          \"mov %1,%0\;\"
                            \"nop\;\"
                          \"mov %Q1,%d0\";
                 } else {
                   /* maybe write to the index+2 register last */
                   return \"mov %1,%0\;\"
                            \"nop\;\"
                          \"mov %Q1,%d0\;\"
                            \"nop\;\"
                          \"mov.b %R1,%t0\";
                 }
                 } else {
                   if (index == REGNO(operands[0])) {
                     /* write to the index register last */
                     return \"mov %Q1,%d0\;\"
                            \"mov.b %R1,%t0\;\"
                            \"mov %1,%0\";
                   } else if (index == REGNO(operands[0])+1) {
                     /* write to the index+1 register last */
                     return \"mov.b %R1,%t0\;\"
                            \"mov %1,%0\;\"
                            \"mov %Q1,%d0\";
                   } else {
                     /* maybe write to the index+2 register last */
                     return \"mov %1,%0\;\"
                            \"mov %Q1,%d0\;\"
                            \"mov.b %R1,%t0\";
               }
                 }
               }
               break;
      case 2:  /* wr,> */
               if (pic30_accumulator_operand(operands[0],
                                             <MODE>mode)) {
                 if (REGNO(operands[0]) == A_REGNO) {
                   return \"mov %1,[w15++]\;\"
                          \"pop ACCAL\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop ACCAH\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop ACCAU\";
                 } else if (REGNO(operands[0]) == B_REGNO) {
                   return \"mov %1,[w15++]\;\"
                          \"pop ACCBL\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop ACCBU\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop ACCBH\;\";
                 } else gcc_assert(0);
               } else {
                 /* Try and prevent clobbering, apparently using an
                    & earlyclobber confuses reload */
                 unsigned int index;
                 index = REGNO(XEXP(operands[1],0));
                 if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                   pic30_rtx_nops+=2;
                 if (index == REGNO(operands[0])) {
                   /* write to the index register last */
                   return \"mov %Q1,%d0\;\"
                          \"nop\;\"
                          \"mov.b %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"add %1,#6,%1\";
                 } else if (index == REGNO(operands[0])+1) {
                   /* write to the index+1 register last */
                   return \"mov.b %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %Q1,%d0\;\"
                          \"add %1,#6,%1\";
                 } else {
                   /* maybe write to the index+2 register last */
                   return \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%d0\;\"
                          \"nop\;\"
                          \"mov.b %1,%t0\";
                 }
                 } else {
                   if (index == REGNO(operands[0])) {
                     /* write to the index register last */
                     return \"mov %Q1,%d0\;\"
                            \"mov.b %R1,%t0\;\"
                            \"mov %1,%0\;\"
                            \"add %1,#6,%1\";
                   } else if (index == REGNO(operands[0])+1) {
                     /* write to the index+1 register last */
                     return \"mov.b %R1,%t0\;\"
                            \"mov %1,%0\;\"
                            \"mov %Q1,%d0\;\"
                            \"add %1,#6,%1\";
                   } else {
                     /* maybe write to the index+2 register last */
                     return \"mov %1,%0\;\"
                            \"mov %1,%d0\;\"
                            \"mov.b %1,%t0\";
               }
                 }
               }
               break;
      case 3:  /* R,wr */
               if (pic30_accumulator_operand(operands[1],
                                             <MODE>mode)) {
                 return \"push %m1U\;\"
                        \"push %m1H\;\"
                        \"push %m1L\;\"
                        \"mov [--w15],%I0\;\"
                        \"mov [--W15],%I0\;\"
                        \"mov [--W15],%D0\;\"
                        \"dec2 %r0,%r0\";
               } else {
                 return \"mov %1,%I0\;\"
                        \"mov %d1,%I0\;\"
                        \"mov.b %t1,%0\;\"
                        \"sub %r0,#4,%r0\";
               }
               break;
      case 4:  /* >,wr */
               if (pic30_accumulator_operand(operands[1],
                                             <MODE>mode)) {
                 rtx reg;
                 rtx post_inc = XEXP(operands[0],0);

                 reg = XEXP(post_inc,0);
                 if (REGNO(reg) == WR15_REGNO) {
                   /* push onto the stack */
                   return \"push %m1L\;\"
                          \"push %m1H\;\"
                          \"push %m1U\";
                 } else {
                   /* push the value backward, so we can pop it the right way
                      round */
                   return \"push %m1U\;\"
                          \"push %m1H\;\"
                          \"push %m1L\;\"
                          \"mov [--w15],%0\;\"
                          \"mov [--W15],%0\;\"
                          \"mov [--W15],%0\";
                 }
               } else {
                 return \"mov %1,%0\;\"
                        \"mov %d1,%0\;\"
                        \"mov %t1,%0\";
               }
               break;
      case 5:  /* >,> */
               if (pic30_psrd_psrd_errata(operands[1],NULL)) {
               return \"mov %1,%0\;\"
                      \"nop\;\"
                      \"mov %1,%0\;\" 
                      \"nop\;\"
                      \"mov %1,%0\;\";
               } else {
                 return \"mov %1,%0\;\"
                        \"mov %1,%0\;\" 
                        \"mov %1,%0\;\";
               }
               break;
      case 6:  /* wr,< */
               if (pic30_accumulator_operand(operands[0],
                                             <MODE>mode)) {
                 rtx reg;
                 rtx pre_dec = XEXP(operands[1],0);

                 reg = XEXP(pre_dec,0);
                 if (REGNO(reg) == WR15_REGNO) {
                   return \"pop %m0U\;\"
                          \"pop %m0H\;\"
                          \"pop %m0L\";
                 } else {
                   return \"mov %1,[w15++]\;\"
                          \"pop %m0U\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop %m0H\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop %m0L\";
                 }
               } else {
                 if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                   pic30_rtx_nops+=2;
                 return \"mov %1,%t0\;\"
                        \"nop\;\"
                        \"mov %1,%d0\;\"
                        \"nop\;\"
                        \"mov %1,%0\";
                 } else {
                   return \"mov %1,%t0\;\"
                          \"mov %1,%d0\;\"
                          \"mov %1,%0\";
               }
               }
               break;
      case 7:  /* <,wr */
               if (pic30_accumulator_operand(operands[1],
                                             <MODE>mode)) {
                 return \"push %m1L\;\"
                        \"push %m1H\;\"
                        \"push %m1U\;\"
                        \"mov [--w15],%0\;\"
                        \"mov [--W15],%0\;\"
                        \"mov [--W15],%0\";
               } else {
                 return \"mov %t1,%0\;\"
                        \"mov %d1,%0\;\"
                        \"mov %1,%0\";
               }
               break;
      case 8:  /* r,Q */
               if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                 pic30_rtx_nops+=2;
               return \"mov %1,%0\;\"
                      \"nop\;\"
                      \"mov %Q1,%d0\;\"
                      \"nop\;\"
                      \"mov %R1,%t0\;\";
               } else {
                 return \"mov %1,%0\;\"
                        \"mov %Q1,%d0\;\"
                        \"mov %R1,%t0\;\";
               }
      case 9:  /* Q,r */
               return \"mov %1,%0\;\"
                      \"mov %d1,%Q0\;\"
                      \"mov %t1,%R0;\";
    }"
)

(define_insn "mov<mode>_gen_APSV_16"
   [(set
      (match_operand:AUACC 0 
         "pic30_move_operand" "=wr,????wr,????wr,????R, >, >, wr,  <, r, Q")
      (match_operand:AUACC 1 
         "pic30_move_operand"  "wr,     R,     >,   wr,wr, >,  <, wr, Q, r"))
     (use (reg:HI PSVPAG))
   
   (clobber (reg:CC_NZC CC_REG))
  ]
   "(!pic30_isa32_target())"
   "*
    switch (which_alternative) {
      default: gcc_assert(0);

      case 0:  /* wr,wr */
               if (pic30_accumulator_operand(operands[0],
                                             <MODE>mode) &&
                   pic30_accumulator_operand(operands[1],
                                             <MODE>mode)) {
                 /* saturation mode doesn't matter... we won't overflow */
                 if (REGNO(operands[0]) == A_REGNO) {
                   return \"clr A\;\"
                          \"add A\";
                 } else if (REGNO(operands[0]) == B_REGNO) {
                   return \"clr B\;\"
                          \"add B\";
                 } else gcc_assert(0);
               } else if (pic30_accumulator_operand(operands[0],
                                                    <MODE>mode)) {
                 if (REGNO(operands[0]) == A_REGNO) {
                   return \"mov %1,ACCAL\;\"
                          \"mov %d1,ACCAH\;\"
                          \"mov %t1,ACCAU\";
                 } else if (REGNO(operands[0]) == B_REGNO) {
                   return \"mov %1,ACCBL\;\"
                          \"mov %d1,ACCBH\;\"
                          \"mov %t1,ACCBU\";
                 } else gcc_assert(0);
               } else if (pic30_accumulator_operand(operands[1],
                                                    <MODE>mode)) {
                 if (REGNO(operands[1]) == A_REGNO) {
                   return \"mov ACCAL,%0\;\"
                          \"mov ACCAH,%d0\;\"
                          \"mov ACCAU,%t0\";
                 } else if (REGNO(operands[1]) == B_REGNO) {
                   return \"mov ACCBL,%0\;\"
                          \"mov ACCBH,%d0\;\"
                          \"mov ACCBU,%t0\";
                 } else gcc_assert(0);
               } else {
                 /* Try and prevent clobbering, apparently using an &
                    early clobber confuses reload */
                 /* op0 and op1 regnos will only be even ... */
                 if (REGNO(operands[0]) == REGNO(operands[1])) {
                   return \"; nop\";
                 } else if (REGNO(operands[0]) == REGNO(operands[1])+2) {
                   return \"mov.b %t1,%t0\;\"
                          \"mov.d %1,%0\";
                 } /* else the other overlap doesn't matter */ 
                 return \"mov.d %1,%0\;\"
                        \"mov.b %t1,%t0\";
               }
               break;
      case 1:  /* wr,R */
               if (pic30_accumulator_operand(operands[0],
                                             <MODE>mode)) {
                 if (REGNO(operands[0]) == A_REGNO) {
                   return \"mov %I1,[w15++]\;\"
                          \"pop ACCAL\;\"
                          \"mov %I1,[W15++]\;\"
                          \"pop ACCAH\;\"
                          \"mov %D1,[W15++]\;\"
                          \"pop ACCAU\;\"
                          \"dec2 %r1,%r1\";
                 } else if (REGNO(operands[0]) == B_REGNO) {
                   return \"mov %I1,[w15++]\;\"
                          \"pop ACCBL\;\"
                          \"mov %I1,[W15++]\;\"
                          \"pop ACCBH\;\"
                          \"mov %D1,[W15++]\;\"
                          \"pop ACCBU\;\"
                          \"dec2 %r1,%r1\";
                 } else gcc_assert(0);
               } else {
                 /* Try and prevent clobbering, apparently using an
                    & earlyclobber confuses reload */
                 unsigned int index;
                 index = REGNO(XEXP(operands[1],0));
                 if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                   pic30_rtx_nops+=2;
                 if (index == REGNO(operands[0])) {
                   /* write to the index register last */
                   return \"mov %Q1,%d0\;\"
                          \"nop\;\"
                          \"mov.b %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %1,%0\";
                 } else if (index == REGNO(operands[0])+1) {
                   /* write to the index+1 register last */
                   return \"mov.b %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %Q1,%d0\";
                 } else {
                   /* maybe write to the index+2 register last */
                   return \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %Q1,%d0\;\"
                          \"nop\;\"
                          \"mov.b %R1,%t0\";
                 }
                 } else {
                   if (index == REGNO(operands[0])) {
                     /* write to the index register last */
                     return \"mov %Q1,%d0\;\"
                            \"mov.b %R1,%t0\;\"
                            \"mov %1,%0\";
                   } else if (index == REGNO(operands[0])+1) {
                     /* write to the index+1 register last */
                     return \"mov.b %R1,%t0\;\"
                            \"mov %1,%0\;\"
                            \"mov %Q1,%d0\";
                   } else {
                     /* maybe write to the index+2 register last */
                     return \"mov %1,%0\;\"
                            \"mov %Q1,%d0\;\"
                            \"mov.b %R1,%t0\";
               }
                 }
               }
               break;
      case 2:  /* wr,> */
               if (pic30_accumulator_operand(operands[0],
                                             <MODE>mode)) {
                 if (REGNO(operands[0]) == A_REGNO) {
                   return \"mov %1,[w15++]\;\"
                          \"pop ACCAL\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop ACCAH\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop ACCAU\";
                 } else if (REGNO(operands[0]) == B_REGNO) {
                   return \"mov %1,[w15++]\;\"
                          \"pop ACCBL\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop ACCBU\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop ACCBH\;\";
                 } else gcc_assert(0);
               } else {
                 /* Try and prevent clobbering, apparently using an
                    & earlyclobber confuses reload */
                 unsigned int index;
                 index = REGNO(XEXP(operands[1],0));
                 if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                   pic30_rtx_nops+=2;
                 if (index == REGNO(operands[0])) {
                   /* write to the index register last */
                   return \"mov %Q1,%d0\;\"
                          \"nop\;\"
                          \"mov.b %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"add %1,#6,%1\";
                 } else if (index == REGNO(operands[0])+1) {
                   /* write to the index+1 register last */
                   return \"mov.b %R1,%t0\;\"
                          \"nop\;\"
                          \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %Q1,%d0\;\"
                          \"add %1,#6,%1\";
                 } else {
                   /* maybe write to the index+2 register last */
                   return \"mov %1,%0\;\"
                          \"nop\;\"
                          \"mov %1,%d0\;\"
                          \"nop\;\"
                          \"mov.b %1,%t0\";
                 }
                 } else {
                   if (index == REGNO(operands[0])) {
                     /* write to the index register last */
                     return \"mov %Q1,%d0\;\"
                            \"mov.b %R1,%t0\;\"
                            \"mov %1,%0\;\"
                            \"add %1,#6,%1\";
                   } else if (index == REGNO(operands[0])+1) {
                     /* write to the index+1 register last */
                     return \"mov.b %R1,%t0\;\"
                            \"mov %1,%0\;\"
                            \"mov %Q1,%d0\;\"
                            \"add %1,#6,%1\";
                   } else {
                     /* maybe write to the index+2 register last */
                     return \"mov %1,%0\;\"
                            \"mov %1,%d0\;\"
                            \"mov.b %1,%t0\";
               }
                 }
               }
               break;
      case 3:  /* R,wr */
               if (pic30_accumulator_operand(operands[1],
                                             <MODE>mode)) {
                 return \"push %m1U\;\"
                        \"push %m1H\;\"
                        \"push %m1L\;\"
                        \"mov [--w15],%I0\;\"
                        \"mov [--W15],%I0\;\"
                        \"mov [--W15],%D0\;\"
                        \"dec2 %r0,%r0\";
               } else {
                 return \"mov %1,%I0\;\"
                        \"mov %d1,%I0\;\"
                        \"mov.b %t1,%0\;\"
                        \"sub %r0,#4,%r0\";
               }
               break;
      case 4:  /* >,wr */
               if (pic30_accumulator_operand(operands[1],
                                             <MODE>mode)) {
                 rtx reg;
                 rtx post_inc = XEXP(operands[0],0);

                 reg = XEXP(post_inc,0);
                 if (REGNO(reg) == WR15_REGNO) {
                   /* push onto the stack */
                   return \"push %m1L\;\"
                          \"push %m1H\;\"
                          \"push %m1U\";
                 } else {
                   /* push the value backward, so we can pop it the right way
                      round */
                   return \"push %m1U\;\"
                          \"push %m1H\;\"
                          \"push %m1L\;\"
                          \"mov [--w15],%0\;\"
                          \"mov [--W15],%0\;\"
                          \"mov [--W15],%0\";
                 }
               } else {
                 return \"mov %1,%0\;\"
                        \"mov %d1,%0\;\"
                        \"mov %t1,%0\";
               }
               break;
      case 5:  /* >,> */
               if (pic30_psrd_psrd_errata(operands[1],NULL)) {
               return \"mov %1,%0\;\"
                        \"nop\;\"
                      \"mov %1,%0\;\" 
                        \"nop\;\"
                      \"mov %1,%0\;\";
               } else {
                 return \"mov %1,%0\;\"
                        \"mov %1,%0\;\" 
                        \"mov %1,%0\;\";
               }
               break;
      case 6:  /* wr,< */
               if (pic30_accumulator_operand(operands[0],
                                             <MODE>mode)) {
                 rtx reg;
                 rtx pre_dec = XEXP(operands[1],0);

                 reg = XEXP(pre_dec,0);
                 if (REGNO(reg) == WR15_REGNO) {
                   return \"pop %m0U\;\"
                          \"pop %m0H\;\"
                          \"pop %m0L\";
                 } else {
                   return \"mov %1,[w15++]\;\"
                          \"pop %m0U\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop %m0H\;\"
                          \"mov %1,[W15++]\;\"
                          \"pop %m0L\";
                 }
               } else {
                 if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                   pic30_rtx_nops+=2;
                 return \"mov %1,%t0\;\"
                          \"nop\;\"
                        \"mov %1,%d0\;\"
                          \"nop\;\"
                        \"mov %1,%0\";
                 } else {
                   return \"mov %1,%t0\;\"
                          \"mov %1,%d0\;\"
                          \"mov %1,%0\";
               }
               }
               break;
      case 7:  /* <,wr */
               if (pic30_accumulator_operand(operands[1],
                                             <MODE>mode)) {
                 return \"push %m1L\;\"
                        \"push %m1H\;\"
                        \"push %m1U\;\"
                        \"mov [--w15],%0\;\"
                        \"mov [--W15],%0\;\"
                        \"mov [--W15],%0\";
               } else {
                 return \"mov %t1,%0\;\"
                        \"mov %d1,%0\;\"
                        \"mov %1,%0\";
               }
               break;
      case 8:  /* r,Q */
               if (pic30_psrd_psrd_errata(operands[1],NULL)) {
                 pic30_rtx_nops+=2;
               return \"mov %1,%0\;\"
                        \"nop\;\"
                      \"mov %Q1,%d0\;\"
                        \"nop\;\"
                      \"mov %R1,%t0\;\";
               } else {
                 return \"mov %1,%0\;\"
                        \"mov %Q1,%d0\;\"
                        \"mov %R1,%t0\;\";
               }
      case 9:  /* Q,r */
               return \"mov %1,%0\;\"
                      \"mov %d1,%Q0\;\"
                      \"mov %t1,%R0;\";
    }"
)

(define_expand "mov<mode>_16"
  [(set (match_operand:AUACC 0 "pic30_mode2k_operand" "")
        (match_operand:AUACC 1 "pic30_mode2k_operand" ""))]
  "(!pic30_isa32_target())"
  "
{ int result;

  result = pic30_emit_move_sequence(operands, <MODE>mode);

  if (result > 0) DONE;
  if (immediate_operand(operands[1],VOIDmode)) {
    rtx reg = operands[0];

    if (!pic30_accum_or_reg_operand(operands[0],<MODE>mode)) {
      if (pic30_reload_in_progress()) FAIL;
      reg = gen_reg_rtx(<MODE>mode);
    }

    if (pic30_reload_in_progress() && 
        pic30_accumulator_operand(operands[0],<MODE>mode)) {
      FAIL; 
    }
    emit(
      gen_mov<mode>_rimm_16(reg,operands[1])
    );
    if (reg != operands[0])
      emit_move_insn(operands[0], reg);
    DONE;
  }
  emit(
    gen_mov<mode>_gen_16(operands[0], operands[1])
  );
  DONE;
}")

;; *** add/sub

(define_insn "add<mode>3_16"
  [(set (match_operand:AUACC    0 "pic30_accum_or_reg_operand" "=&r,w")
        (plus:AUACC
           (match_operand:AUACC 1 "pic30_accum_or_reg_operand"  "%r,0")
           (match_operand:AUACC 2 "pic30_accum_or_reg_operand"  " r,w")))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add %1,%2,%0\;addc %d1,%d2,%d0\;addc.b %t1,%t2,%t0
   add %0"
)

(define_insn "ssadd<mode>3_16"
  [(set (match_operand:AUACC    0 "pic30_accum_or_reg_operand" "=&r,w")
        (ss_plus:AUACC
           (match_operand:AUACC 1 "pic30_accum_or_reg_operand"  "%r,0")
           (match_operand:AUACC 2 "pic30_accum_or_reg_operand"  " r,0")))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add %1,%2,%0\;addc %d1,%d2,%d0\;addc.b %t1,%t2,%t0\;bra nov,.L1_%=\;setm %0\;setm %d0\;mov.b #0x7F,%t0\;btst.c %t2,#7\;bra nc,.L1_%=\;com.b %t0,%t0\;com %d0,%d0\;com %0,%0\;.L1_%=:
   add %0"
)

(define_insn "usadd<mode>3_16"
  [(set (match_operand:AUACC    0 "pic30_accum_or_reg_operand" "=&r,w")
        (us_plus:AUACC
           (match_operand:AUACC 1 "pic30_accum_or_reg_operand"  "%r,0")
           (match_operand:AUACC 2 "pic30_accum_or_reg_operand"   "r,w")))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   add %1,%2,%0\;addc %d1,%d2,%d0\;addc.b %t1,%t2,%t0\;bra nov,.L1_%=\;setm %0\;setm %d0\;mov.b #0x7F,%t0\;.L1_%=:
   add %0"
)

(define_insn "sub<mode>3_16"
  [(set (match_operand:AUACC    0 "pic30_accum_or_mode1_operand" "=&r,>,r,>,r,R,R,w")
        (minus:AUACC
           (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    " r,r,r,r,r,r,r,0")
           (match_operand:AUACC 2 "pic30_accum_or_mode1_operand"  " r,r,>,>,R,r,R,w")))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
{
   const char *patterns[] = {
     \"sub %1,%2,%0\;subb %d1,%d2,%d0\;subb.b %t1,%t2,%t0\",
     \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;subb %t1,%t2,%I0\",
     \"sub %1,%I2,%0\;subb %d1,%I2,%d0\;subb.b %t1,%I2,%t0\",
     \"sub %1,%I2,%I0\;subb %d1,%I2,%I0\;subb %t1,%I2,%I0\",
     \"sub %1,%I2,%0\;subb %d1,%I2,%d0\;subb %t1,%D2,%t0\;dec2 %r2,%r2\",
     \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;subb %t1,%t2,%D0\;dec2 %r0,%r0\",
     \"sub %1,%I2,%I0\;subb %d1,%I2,%I0\;subb %t1,%D2,%D0\;dec2 %r0,%r0\;dec2 %r2,%r2\",
     \"sub %0\"
   };

   const char *psrd_psrd_patterns[] = {
     \"sub %1,%2,%0\;subb %d1,%d2,%d0\;subb.b %t1,%t2,%t0\",
     \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;subb %t1,%t2,%I0\",
     \"sub %1,%I2,%0\;nop\;subb %d1,%I2,%d0\;nop\;subb.b %t1,%I2,%t0\",
     \"sub %1,%I2,%I0\;nop\;subb %d1,%I2,%I0\;nop\;subb %t1,%I2,%I0\",
     \"sub %1,%I2,%0\;nop\;subb %d1,%I2,%d0\;nop\;subb %t1,%D2,%t0\;dec2 %r2,%r2\",
     \"sub %1,%2,%I0\;subb %d1,%d2,%I0\;subb %t1,%t2,%D0\;dec2 %r0,%r0\",
     \"sub %1,%I2,%I0\;nop\;subb %d1,%I2,%I0\;nop\;subb %t1,%D2,%D0\;dec2 %r0,%r0\;dec2 %r2,%r2\",
     \"sub %0\"
   };
   
   if (pic30_psrd_psrd_errata(operands[2],NULL)) {
     pic30_rtx_nops+=2;
     return psrd_psrd_patterns[which_alternative];
   } else {
     return patterns[which_alternative];
   }
}"
)

(define_insn "sssub<mode>3_16"
  [(set (match_operand:AUACC    0 "pic30_accum_or_reg_operand" "=&r,w")
        (ss_minus:AUACC
           (match_operand:AUACC 1 "pic30_accum_or_reg_operand"  " r,0")
           (match_operand:AUACC 2 "pic30_accum_or_reg_operand"  " r,w")))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sub %1,%2,%0\;subb %d1,%d2,%d0\;subb.b %t1,%t2,%t0\;bra nov,.L1_%=\;setm %0\;setm %d0\;mov.b #0x7F,%t0\;btst.c %t2,#7\;bra c,.L1_%=\;com.b %t0,%t0\;com %d0,%d0\;com %0,%0\;.L1_%=:
   sub %0"
)

(define_insn "ussub<mode>3_16"
  [(set (match_operand:AUACC    0 "pic30_accum_or_reg_operand" "=&r,w")
        (us_minus:AUACC
           (match_operand:AUACC 1 "pic30_accum_or_reg_operand"  " r,0")
           (match_operand:AUACC 2 "pic30_accum_or_reg_operand"  " r,w")))
   (use (reg:HI CORCON))
 
   (clobber (reg:CC_NZC CC_REG))
   ]
  "(!pic30_isa32_target())"
  "@
   sub %1,%2,%0\;subb %d1,%d2,%d0\;subb.b %t1,%t2,%t0\;bra nn,.L1_%=\;mul.uu %0,#0,%0\;clr.b %t0\;.L1_%=:
   sub %0"
)

;; multiply of accumulators, ie 8.31*8.31 will be handled by a function

; widening multiply/ multiply accumulate

(define_insn "muluqq<mode>3_16"
  [(set (match_operand:AUACC   0 "pic30_accumulator2_operand" "=w")
        (mult:AUACC
          (fract_convert:AUACC
            (match_operand:UQQ 1 "pic30_mac_input_operand"     "za"))
          (fract_convert:AUACC
            (match_operand:UQQ 2 "pic30_mac_input_operand"     "za"))))
   (use (reg:HI CORCON))
  ]
  "(!pic30_isa32_target())"
  "mpy %1,%2,%0"
)

(define_insn "mulqq<mode>3_16"
  [(set (match_operand:AUACC   0 "pic30_accumulator2_operand" "=w")
        (mult:AUACC
          (fract_convert:AUACC
            (match_operand:QQ  1 "pic30_mac_input_operand"     "za"))
          (fract_convert:AUACC
            (match_operand:QQ  2 "pic30_mac_input_operand"     "za"))))
   (use (reg:HI CORCON))
  ]
  "(!pic30_isa32_target())"
  "mpy %1*%2,%0"
)

(define_insn "umadduqq<mode>4_16"
  [(set (match_operand:AUACC       0 "pic30_accumulator2_operand" "=w")
        (plus:AUACC 
           (match_operand:AUACC    3 "pic30_accumulator2_operand" " 0")
           (mult:AUACC 
              (fract_convert:AUACC
                (match_operand:UQQ 1 "pic30_mac_input_operand"     "za"))
              (fract_convert:AUACC
                (match_operand:UQQ 2 "pic30_mac_input_operand"     "za")))))

   (use (reg:HI CORCON))
  ]
  "(!pic30_isa32_target())"
  "mac %1*%2,%0"
)

(define_insn "maddqq<mode>4_16"
  [(set (match_operand:AUACC      0 "pic30_accumulator2_operand" "=w")
        (plus:AUACC 
           (match_operand:AUACC   3 "pic30_accumulator2_operand" " 0")
           (mult:AUACC 
              (fract_convert:AUACC
                (match_operand:QQ 1 "pic30_mac_input_operand"     "za"))
              (fract_convert:AUACC
                (match_operand:QQ 2 "pic30_mac_input_operand"     "za")))))
   (use (reg:HI CORCON))
  ]
  "(!pic30_isa32_target())"
  "mac %1*%2,%0"
)

(define_insn "umaddhisi4_16"
  [(set (match_operand:SI          0 "pic30_accumulator2_operand" "=w")
        (plus:SI
           (match_operand:SI       3 "pic30_accumulator2_operand" " 0")
           (mult:SI
              (zero_extend:SI
                (match_operand:HI  1 "pic30_mac_input_operand"     "za"))
              (zero_extend:SI
                (match_operand:HI  2 "pic30_mac_input_operand"     "za")))))

   (use (reg:HI CORCON))
  ]
  "(!pic30_isa32_target()) && pic30_integer_mac_support"
  "mac %1*%2,%0"
)

(define_insn "maddhisi4_16"
  [(set (match_operand:SI         0 "pic30_accumulator2_operand" "=w")
        (plus:SI
           (match_operand:SI      3 "pic30_accumulator2_operand" " 0")
           (mult:SI
              (sign_extend:SI
                (match_operand:HI 1 "pic30_mac_input_operand"     "za"))
              (sign_extend:SI
                (match_operand:HI 2 "pic30_mac_input_operand"     "za")))))
   (use (reg:HI CORCON))
  ]
  "(!pic30_isa32_target()) && pic30_integer_mac_support"
  "mac %1*%2,%0"
)

(define_insn "umsubuqq<mode>4_16"
  [(set (match_operand:AUACC       0 "pic30_accumulator2_operand" "=w")
        (minus:AUACC 
           (match_operand:AUACC    3 "pic30_accumulator2_operand" " 0")
           (mult:AUACC 
              (fract_convert:AUACC
                (match_operand:UQQ 1 "pic30_mac_input_operand"     "za"))
              (fract_convert:AUACC
                (match_operand:UQQ 2 "pic30_mac_input_operand"     "za")))))

   (use (reg:HI CORCON))
  ]
  "(!pic30_isa32_target())"
  "msc %1*%2,%0"
)

(define_insn "msubqq<mode>4_16"
  [(set (match_operand:AUACC      0 "pic30_accumulator2_operand" "=w")
        (minus:AUACC 
           (match_operand:AUACC   3 "pic30_accumulator2_operand" " 0")
           (mult:AUACC 
              (fract_convert:AUACC
                (match_operand:QQ 1 "pic30_mac_input_operand"     "za"))
              (fract_convert:AUACC
                (match_operand:QQ 2 "pic30_mac_input_operand"     "za")))))
   (use (reg:HI CORCON))
  ]
  "(!pic30_isa32_target())"
  "msc %1*%2,%0"
)

;; negate

(define_insn "neg<mode>2_16"
  [(set (match_operand:ACC   0 "pic30_accum_or_reg_operand" "=w,&r")
        (neg:ACC
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" " 0,r")))
   (use (reg:HI CORCON))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   neg %0
   subr %1,#0,%0\;subbr %d1,#0,%d0\;subbr.b %t1,#0,%t0"
  [
    (set_attr "cc" "math")
  ]
)

(define_insn "ssneg<mode>2_16"
  [(set (match_operand:ACC   0 "pic30_accum_or_reg_operand" "=w,&r")
        (ss_neg:ACC
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" " 0,r")))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   neg %0
   subr %1,#0,%0\;subbr %d1,#0,%d0\;subbr.b %t1,#0,%t0\;bra nov,.L1_%=\;setm %0\;setm %d0\;mov.b #0x7F,%t0\;btst.c %t1,#7\;bra c,.L1_%=\;com %0,%0\;com %d0,%d0\;com.b %t0,%t0\n.L1_%=:"
  [
    (set_attr "cc" "math")
  ]
)
(define_insn "usneg<mode>2_16"
  [(set (match_operand:ACC   0 "pic30_accum_or_reg_operand" "=w,&r")
        (us_neg:ACC
          (match_operand:ACC 1 "pic30_accum_or_reg_operand" " 0,r")))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   neg %0
   subr %1,#0,%0\;subbr %d1,#0,%d0\;subbr.b %t1,#0,%t0\;bra nov,.L1_%=\;setm %0\;setm %d0\;mov.b #0x7F,%t0\n.L1_%=:"
  [
    (set_attr "cc" "math")
  ]
)

;; shift

; sftac can only shift +-16 for some unfathomable reason
; this might be better handled in a library fn

(define_insn "ashl<mode>3_imm15_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 0) && (INTVAL(operands[2]) < 16))"
  "@
   sftac %0,#%J2
   sl %t1,#%2,%t0\;lsr %d1,#%k2,%3\;ior.b %3,%t0,%t0\;sl %d1,#%2,%d0\;lsr %1,#%k2,%3\;ior %3,%d0,%d0\;sl %1,#%2,%0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ashl<mode>3_imm16to31_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 15) && (INTVAL(operands[2]) < 31))"
  "@
   sftac %0,#-16\;sftac %0,#-(%2-16)
   sl %d1,#(%2-16),%t0\;lsr %0,#(32-%2),%3\;ior.b %3,%t0,%t0\;sl %0,#(%2-16),%d0\;clr %0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ashl<mode>3_imm32to39_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 31) && (INTVAL(operands[2]) < 40))"
  "@
   sftac %0,#-16\;sftac %0,#-16\;sftac %0,-#(%2-32)
   sl %1,#(%2-32),%t0\;mul.uu %0,#0,%0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ashl<mode>3_gen_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,&r")
        (ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,0")
          (match_operand:HI    2 "pic30_register_operand"        "r,r")))
   (clobber (match_scratch:HI  3                                "=2,2"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch (which_alternative) {
      default: gcc_assert(0);
      case 0:
        sprintf(c,\".LB%%=:\;\"
                 \"dec %%2,%%2\;\"
                 \"bra n,.LE%%=\;\"
                 \"%s\"
                 \"repeat %%2\;\"
                 \"sftac %%1,#-1\;\"
                 \"%s\n.LE%%=:\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;  
      case 1:
        return \".LB%=:\;\"
               \"dec %2,%2\;\"
               \"bra n,.LE%=\;\"
               \"add %1,%1,%0\;\"
               \"addc %d1,%d1,%d0\;\"
               \"addc.b %t1,%t1,%t0\;\"
               \"bra .LB%=\n.LE%=:\";
    }
  }
  "
  [
   (set_attr "cc" "clobber")
  ]
)

(define_expand "ashl<mode>3_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,r")
        (ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "w,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand"      "ri,ri")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    if (immediate_operand(operands[2],VOIDmode)) {
      HOST_WIDE_INT shiftval = INTVAL(operands[2]); 
      if (shiftval < 16) {
        emit(
          gen_ashl<mode>3_imm15_16(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 32) {
        emit(
          gen_ashl<mode>3_imm16to31_16(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 39) {
        emit(
          gen_ashl<mode>3_imm32to39_16(operands[0], operands[1], operands[2])
        );
      } else {
        emit(
          gen_mov<mode>(operands[0], GEN_INT(0))
        );
      }
      DONE;
    } else {
      emit(
        gen_ashl<mode>3_gen_16(operands[0], operands[1], operands[2])
      );
      DONE;
    }
  }
  "
)

; ss arithmetic shift left

(define_insn "ssashl<mode>3_imm15_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ss_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 0) && (INTVAL(operands[2]) < 16))"
  "@
   sftac %0,#%J2
   sl %t1,#%2,%t0\;lsr %d1,#%k2,%3\;ior.b %3,%t0,%t0\;sl %d1,#%2,%d0\;lsr %1,#%k2,%3\;ior %3,%d0,%d0\;sl %1,#%2,%0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;btsc %t1,#7\;bset %t0,#7\;.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ssashl<mode>3_imm16to31_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ss_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 15) && (INTVAL(operands[2]) < 31))"
  "@
   sftac %0,#-16\;sftac %0,#-(%2-16)
   sl %d1,#(%2-16),%t0\;lsr %0,#(32-%2),%3\;ior.b %3,%t0,%t0\;sl %0,#(%2-16),%d0\;clr %0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;btsc %t1,#7\;bset %t0,#7\;.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ssashl<mode>3_imm32to39_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ss_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 31) && (INTVAL(operands[2]) < 40))"
  "@
   sftac %0,#-16\;sftac %0,#-16\;sftac %0,-#(%2-32)
   sl %1,#(%2-32),%t0\;mul.uu %0,#0,%0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;btsc %t1,#7\;bset %t0,#7\;.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "ssashl<mode>3_imm40_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (ss_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "(INTVAL(operands[2]) == 40)"
  "@
   sftac %0,#-16\;sftac %0,#-16\;sftac %0,-#(%2-32)
   mov.b #0x7f,%t0\;setm %d0\;setm %0\;btsc %t1,#7\;bset %t0,#7"
  [
   (set_attr "cc" "clobber")
  ]
)


(define_insn "ssashl<mode>3_gen_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,&r")
        (ss_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "pic30_register_operand"        "r,r")))
   (clobber (match_scratch:HI  3                                "=2,2"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch(which_alternative) {
      default: gcc_assert(0);
        break;
      case 0:
        sprintf(c,\".LB%%=:\;\"
                \"dec %%2,%%2\;\"
                \"bra n,.LE%%=\;\"
                \"%s\"
                \"repeat %%2\;\"
                \"sftac %%1,#-1\;\"
                \"%s\n.LE%%=:\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:
        return \"mov.d %1,%0\;\"
               \"mov.b %t1,%t0\;\"
               \".LB%=:\;\"
               \"dec %2,%2\;\"
               \"bra n,.LE%=\;\"
               \"add %0,%0,%0\;\"
               \"addc %d0,%d0,%d0\;\"
               \"addc.b %t0,%t0,%t0\;\"
               \"bra nov,.LB%=\;\"
               \"mov.b #0x7F,%t0\;\"
               \"btsc %t1,#7\;\"
               \"com.b %t0,%t0\;\"
               \"sl %t0,#9,%d0\;\"
               \"asr %d0,#15,%d0\;\"
               \"asr %d0,#15,%0\n.LE%=:\";
    }
  }
  "
  [
   (set_attr "cc" "clobber")
  ]
)

(define_expand "ssashl<mode>3_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,r")
        (ss_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "w,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand"      "ri,ri")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    if (immediate_operand(operands[2],VOIDmode)) {
      HOST_WIDE_INT shiftval = INTVAL(operands[2]); 
      if (shiftval < 16) {
        emit(
          gen_ssashl<mode>3_imm15_16(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 32) {
        emit(
          gen_ssashl<mode>3_imm16to31_16(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 39) {
        emit(
          gen_ssashl<mode>3_imm32to39_16(operands[0], operands[1], operands[2])
        );
      } else {
        emit(
          gen_ssashl<mode>3_imm40_16(operands[0], operands[1], GEN_INT(40))
        );
      }
      DONE;
    } else {
      emit(
        gen_ssashl<mode>3_gen_16(operands[0], operands[1], operands[2])
      );
      DONE;
    }
  }
  "
)

; us arithmetic shift left

(define_insn "usashl<mode>3_imm_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 0) && (INTVAL(operands[2]) <= 16))"
  "@
   sftac %0,#%J2
   sl %t1,#%2,%t0\;lsr %d1,#%k2,%3\;ior.b %3,%t0,%t0\;sl %d1,#%2,%d0\;lsr %1,#%k2,%3\;ior %3,%d0,%d0\;sl %1,#%2,%0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;.LE%=:"

  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "usashl<mode>3_imm15_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 0) && (INTVAL(operands[2]) < 16))"
  "@
   sftac %0,#%J2
   sl %t1,#%2,%t0\;lsr %d1,#%k2,%3\;ior.b %3,%t0,%t0\;sl %d1,#%2,%d0\;lsr %1,#%k2,%3\;ior %3,%d0,%d0\;sl %1,#%2,%0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "usashl<mode>3_imm16to31_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 15) && (INTVAL(operands[2]) < 31))"
  "@
   sftac %0,#-16\;sftac %0,#-(%2-16)
   sl %d1,#(%2-16),%t0\;lsr %0,#(32-%2),%3\;ior.b %3,%t0,%t0\;sl %0,#(%2-16),%d0\;clr %0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "usashl<mode>3_imm32to39_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 31) && (INTVAL(operands[2]) < 40))"
  "@
   sftac %0,#-16\;sftac %0,#-16\;sftac %0,-#(%2-32)
   sl %1,#(%2-32),%t0\;mul.uu %0,#0,%0\;xor %t0,%t1,%3\;btss %3,#7\;bra .LE%=\;mov.b #0x7f,%t0\;setm %d0\;setm %0\;.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "usashl<mode>3_imm40_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  ]
  "(INTVAL(operands[2]) == 40)"
  "@
   sftac %0,#-16\;sftac %0,#-16\;sftac %0,-#(%2-32)
   mov.b #0x7f,%t0\;setm %d0\;setm %0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "usashl<mode>3_gen_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,&r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "pic30_register_operand"        "r,r")))
   (clobber (match_scratch:HI  3                                "=2,2"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch(which_alternative) {
      default: gcc_assert(0);
        break;
      case 0:
        sprintf(c,\"dec %%2,%%2\;\"
                \"bra n,.LE%%=\;\"
                \"%s\"
                \"repeat %%2\;\"
                \"sftac %%1,#-1\;\"
                \"%s\n.LE%%=:\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:
        return \"mov.d %1,%0\;\"
               \"mov.b %t1,%t0\;\"
               \".LB%=:\;\"
               \"dec %2,%2\;\"
               \"bra n,.LE%=\;\"
               \"add %0,%0,%0\;\"
               \"addc %d0,%d0,%d0\;\"
               \"addc.b %t0,%t0,%t0\;\"
               \"bra nov,.LB%=\;\"
               \"mov.b #0x7F,%t0\;\"
               \"setm %d0\;\"
               \"setm %0\n.LE%=:\";
    }
  }
  "
  [
   (set_attr "cc" "clobber")
  ]
)

(define_expand "usashl<mode>3_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,r")
        (us_ashift:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "w,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand"      "ri,ri")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    if (immediate_operand(operands[2],VOIDmode)) {
      HOST_WIDE_INT shiftval = INTVAL(operands[2]); 
      if (shiftval < 16) {
        emit(
          gen_usashl<mode>3_imm15_16(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 32) {
        emit(
          gen_usashl<mode>3_imm16to31_16(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 39) {
        emit(
          gen_usashl<mode>3_imm32to39_16(operands[0], operands[1], operands[2])
        );
      } else {
        emit(
          gen_usashl<mode>3_imm40_16(operands[0], operands[1], GEN_INT(40))
        );
      }
      DONE;
    } else {
      emit(
        gen_usashl<mode>3_gen_16(operands[0], operands[1], operands[2])
      );
      DONE;
    }
  }
  "
)

; logical shift right 

(define_insn "lshr<mode>3_imm_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (lshiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 0) && (INTVAL(operands[2]) <= 16))"
  "@
   sftac %0,#%2
   lsr %1,#%2,%0\;sl %d1,#%k2,%3\;ior %3,%0,%0\;lsr %d1,#%2,%d0\;sl %t1,#%k2,%3\;ior %3,%d0,%d0\;mov %t1,%t0\;and #0xFF,%t0\;lsr %t0,#%2,%t0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "lshr<mode>3_imm15_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (lshiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 0) && (INTVAL(operands[2]) <= 15))"
  "@
   sftac %0,#%2
   lsr %1,#%2,%0\;sl %d1,#%k2,%3\;ior %3,%0,%0\;lsr %d1,#%2,%d0\;sl %t1,#%k2,%3\;ior %3,%d0,%d0\;mov %t1,%t0\;and #0xFF,%t0\;lsr %t0,#%2,%t0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "lshr<mode>3_imm16to31_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (lshiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 15) && (INTVAL(operands[2]) <= 31))"
  "@
   sftac %0,#16\;sftac %0,#(%2-16)
   lsr %d1,#(%2-16),%0\;sl %t1,#(32-%2),%3\;ior %3,%0,%0\;lsr %t1,#(%2-16),%d0\;\;and #0x7F,%d0\;clr.b %t0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "lshr<mode>3_imm32to39_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"  "=w,&r")
        (lshiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,r")
          (match_operand:HI    2 "immediate_operand"             "i,i")))
   (clobber (match_scratch:HI  3                               "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "((INTVAL(operands[2]) > 31) && (INTVAL(operands[2]) <= 39))"
  "@
   sftac %0,#16\;sftac %0,#16\;sftac %0,#(%2-32)
   lsr %t1,#(%2-32),%0\;and #0x7f,%0\;clr %d0\;clr.b %t0"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_insn "lshr<mode>3_gen_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,&r")
        (lshiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,0")
          (match_operand:HI    2 "pic30_register_operand"        "r,r")))
   (clobber (match_scratch:HI  3                                "=2,2"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   .LB%=:\;dec %2,%2\;bra n,.LE%=\;sftac %1,#1\;bra .LB%=\n.LE%=:
   .LB%=:\;dec %2,%2\;bra n,.LE%=\;lsr.b %t1,%t0\;rrc %d1,%d0\;rrc %1,%0\;bra .LB%=\n.LE%=:"
  [
   (set_attr "cc" "clobber")
  ]
)

(define_expand "lshr<mode>3_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,r")
        (lshiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "w,r")
          (match_operand:HI    2 "pic30_reg_or_imm_operand"      "ri,ri")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    if (pic30_fp_round_p() == pic30_conventional) FAIL;
    if (pic30_fp_round_p() == pic30_convergent) FAIL;
    /* truncation or fastest */
    if (immediate_operand(operands[2],VOIDmode)) {
      HOST_WIDE_INT shiftval = INTVAL(operands[2]); 
      if (shiftval < 16) {
        emit(
          gen_lshr<mode>3_imm15_16(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 32) {
        emit(
          gen_lshr<mode>3_imm16to31_16(operands[0], operands[1], operands[2])
        );
      } else if (shiftval < 39) {
        emit(
          gen_lshr<mode>3_imm32to39_16(operands[0], operands[1], operands[2])
        );
      } else {
        emit(
          gen_mov<mode>(operands[0], GEN_INT(0))
        );
      }
      DONE;
    } else {
      emit(
        gen_lshr<mode>3_gen_16(operands[0], operands[1], operands[2])
      );
      DONE;
    }
  }
  "
)

; arithemetic shift right

(define_insn "ashr<mode>3_gen_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,&r")
        (ashiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "0,0")
          (match_operand:HI    2 "pic30_register_operand"        "r,r")))
   (clobber (match_scratch:HI  3                                "=2,2"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
  {
    static char buffer[512];
    char *c = buffer;
    const char *repeat_errata_push = pic30_repeat_errata_push_init();
    const char *repeat_errata_pop = pic30_repeat_errata_pop_init();
    switch(which_alternative) {
      default: gcc_assert(0);
        break;
      case 0:
        sprintf(c,\"dec %%2,%%2\;\"
                \"%s\"
                \"repeat %%2\;\"
                \"sftac %%1,#1\;\"
                \"%s\",
                repeat_errata_push,repeat_errata_pop);
        return buffer;
      case 1:
        return \".LB%=:\;\"
               \"dec %2,%2\;\"
               \"bra n,.LE%=\;\"
               \"asr.b %t1,%t0\;\"
               \"rrc %d1,%d0\;\"
               \"rrc %1,%0\;\"
               \"bra .LB%=\n.LE%=:\";
        break;
    }
  }
  "
  [
   (set_attr "cc" "clobber")
  ]
)

(define_expand "ashr<mode>3_16"
  [(set (match_operand:AUACC   0 "pic30_accum_or_reg_operand"   "=w,r")
        (ashiftrt:AUACC
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand"    "w,r")
          (match_operand:HI    2 "pic30_register_operand"        "r,r")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    if (pic30_fp_round_p() == pic30_conventional) {
      FAIL;
    } else if (pic30_fp_round_p() == pic30_convergent) {
      FAIL;
    } else {
      emit(
        gen_ashr<mode>3_gen_16(operands[0], operands[1], operands[2])
      );
      DONE;
    } 
    FAIL;
  }
  "
)

;; compare

(define_insn "cmp<mode>_helper_16"
  [(set (reg:CC CC_REG)
        (compare 
          (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "w,r")
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
   (clobber (match_scratch:HI  2                             "=&a,X"))
  ]
  "(!pic30_isa32_target())" 
  "@
   mov %m1L,w0\;cp %m0L\;mov %m1H,w0\;cpb %m0H\;mov %m1U,w0\;cpb.b %m0U
   cp %0,%1\;cpb %d0,%d1\;cpb.b %t0,%t1"
  [
    (set_attr "cc" "set,set")
  ]
)

(define_expand "cmp<mode>_16"
  [(set (reg:CC CC_REG)
        (compare 
          (match_operand:AUACC 0 "" "w,r")
          (match_operand:AUACC 1 "" "w,r")))
   (clobber (match_scratch:HI  2  "=&a,X"))
  ]
  "(!pic30_isa32_target())" 
  "
  {
    rtx op0, op1;
    op0 = operands[0];
    op1 = operands[1];

    if (!pic30_accum_or_reg_operand(op0, <MODE>mode)) {
      op0 = force_reg(<MODE>mode,op0);
    }
    if (!pic30_accum_or_reg_operand(op1, <MODE>mode)) {
      op1 = force_reg(<MODE>mode,op1);
    }
    emit(
      gen_cmp<mode>_helper_16(op0,op1)
    );
    DONE;
  }"
)

;; Accum / fract conversions
;  to Q15

(define_insn "fract<mode>qq2_trunc_16"
  [(set (match_operand:QQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:QQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  "(!pic30_isa32_target())"
  "@
   sac %1,%0
   mov %d1,%0"
)
  
(define_insn "fract<mode>uqq2_trunc_16"
  [(set (match_operand:UQQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:UQQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  "(!pic30_isa32_target())"
  "@
   sac %1,%0
   mov %d1,%0"
)
  
(define_insn "fract<mode>hq2_trunc_16"
  [(set (match_operand:HQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:HQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  "(!pic30_isa32_target())"
  "@
   sac %1,%0
   mov %d1,%0"
)
  
(define_insn "fract<mode>uhq2_trunc_16"
  [(set (match_operand:UHQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:UHQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  "(!pic30_isa32_target())"
  "@
   sac %1,%0
   mov %d1,%0"
)

(define_insn "fract<mode>qq2_conv_16"
  [(set (match_operand:QQ      0 "pic30_register_operand"    "=r, &r")
        (fract_convert:QQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w, r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;btsc %1,#15\;inc %0,%0\";
       default: gcc_assert(0);
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;sl %1,%2\;bra nz,.LINC%=\;btsc %0,#0\n.LINC%=:addc %0,#0,%0\";
       default: gcc_assert(0);
     }
   }
   error(\"Cannot generate instruction\");
   return \"cannot generate instruction\";
  "
)

(define_insn "fract<mode>uqq2_conv_16"
  [(set (match_operand:UQQ     0 "pic30_register_operand"     "=r,&r")
        (fract_convert:UQQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w, r")))
   (clobber (match_scratch:HI  2                              "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;btsc %1,#15\;inc %0,%0\";
       default: gcc_assert(0);
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;sl %1,%2\;bra nz,.LINC%=\;btsc %0,#0\n.LINC%=:addc %0,#0,%0\";
       default: gcc_assert(0);
     }
   }
   error(\"Cannot generate instruction\");
   return \"cannot generate instruction\";
  "
)

(define_insn "fract<mode>hq2_conv_16"
  [(set (match_operand:HQ      0 "pic30_register_operand"     "=r,&r")
        (fract_convert:HQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w, r")))
   (clobber (match_scratch:HI  2                              "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;btsc %1,#15\;inc %0,%0\";
       default: gcc_assert(0);
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;sl %1,%2\;bra nz,.LINC%=\;btsc %0,#0\n.LINC%=:addc %0,#0,%0\";
       default: gcc_assert(0);
     }
   }
   error(\"Cannot generate instruction\");
   return \"cannot generate instruction\";
  "
)

(define_insn "fract<mode>uhq2_conv_16"
  [(set (match_operand:UHQ     0 "pic30_register_operand"    "=r,&r")
        (fract_convert:UHQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w, r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0;btsc %1,#15\;inc %0,%0\";
       default: gcc_assert(0);
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;sl %1,%2\;bra nz,.LINC%=\;btsc %0,#0\n.LINC%=:addc %0,#0,%0\";
       default: gcc_assert(0);
     }
   }
   error(\"Cannot generate instruction\");
   return \"cannot generate instruction\";
  "
)

(define_expand "fract<mode>qq2_16"
  [(set (match_operand:QQ    0 "pic30_register_operand"    "=r,r")
      (fract_convert:QQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_fract<mode>qq2_trunc_16(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_fract<mode>qq2_conv_16(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

(define_expand "fract<mode>uqq2_16"
  [(set (match_operand:UQQ   0 "pic30_register_operand"    "=r,r")
      (fract_convert:UQQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_fract<mode>uqq2_trunc_16(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_fract<mode>uqq2_conv_16(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

(define_expand "fract<mode>hq2_16"
  [(set (match_operand:HQ    0 "pic30_register_operand"    "=r,r")
      (fract_convert:QQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_fract<mode>hq2_trunc_16(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_fract<mode>hq2_conv_16(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

(define_expand "fract<mode>uhq2_16"
  [(set (match_operand:UHQ   0 "pic30_register_operand"    "=r,r")
      (fract_convert:UHQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_fract<mode>uhq2_trunc_16(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_fract<mode>uhq2_conv_16(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

; to Q31

(define_insn "fract<mode>sq2_16"
  [(set (match_operand:SQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:SQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  "(!pic30_isa32_target())"
  "@
   mov %m1L,%0\;mov %m1H,%d0
   mov.d %1,%0"
)
 
(define_insn "fract<mode>usq2_16"
  [(set (match_operand:USQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:USQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  "(!pic30_isa32_target())"
  "@
   mov %m1L,%0\;mov %m1H,%d0
   mov.d %1,%0"
)

(define_insn "fract<mode>dq2_16"
  [(set (match_operand:DQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:DQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  "(!pic30_isa32_target())"
  "@
   mov %m1L,%0\;mov %m1H,%d0
   mov.d %1,%0"
)
 
(define_insn "fract<mode>udq2_16"
  [(set (match_operand:UDQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:UDQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  "(!pic30_isa32_target())"
  "@
   mov %m1L,%0\;mov %m1H,%d0
   mov.d %1,%0"
)

(define_insn "fract<mode>tq2_16"
  [(set (match_operand:TQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:TQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  "(!pic30_isa32_target())"
  "@
   mov %m1L,%0\;mov %m1H,%d0
   mov.d %1,%0"
)
 
(define_insn "fract<mode>utq2_16"
  [(set (match_operand:UTQ      0 "pic30_register_operand"     "=r,r")
        (fract_convert:UTQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))]
  "(!pic30_isa32_target())"
  "@
   mov %m1L,%0\;mov %m1H,%d0
   mov.d %1,%0"
)

;  saturating to Q15

(define_insn "satfract<mode>qq2_trunc_16"
  [(set (match_operand:QQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:QQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sac %1,%0
   mov %d1,%0\;se %t1,%2\;rlc %d1,[w15]\;rlc %2,%2\;bra z,.LOK%=\;inc %2,%2\;bra z,.LOK%=\;mov #0x7FFF,%0\;btsc %t1,#7\;com %0,%0\;.LOK%=:\n"
)
  
(define_insn "satfract<mode>uqq2_trunc_16"
  [(set (match_operand:UQQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:UQQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sac %1,%0
   mov %d1,%0\;se %t1,%2\;rlc %d1,[w15]\;rlc %2,%2\;bra z,.LOK%=\;inc %2,%2\;bra z,.LOK%=\;mov #0x7FFF,%0\;btsc %t1,#7\;clr %0\;.LOK%=:\n"
)
  
(define_insn "satfract<mode>hq2_trunc_16"
  [(set (match_operand:HQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:HQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sac %1,%0
   mov %d1,%0\;se %t1,%2\;rlc %d1,[w15]\;rlc %2,%2\;bra z,.LOK%=\;inc %2,%2\;bra z,.LOK%=\;mov #0x7FFF,%0\;btsc %t1,#7\;com %0,%0\;.LOK%=:\n"
)
  
(define_insn "satfract<mode>uhq2_trunc_16"
  [(set (match_operand:UHQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:UHQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   sac %1,%0
   mov %d1,%0\;se %t1,%2\;rlc %d1,[w15]\;rlc %2,%2\;bra z,.LOK%=\;inc %2,%2\;bra z,.LOK%=\;mov #0x7FFF,%0\;btsc %t1,#7\;clr %0\;.LOK%=:\n"
)

(define_insn "satfract<mode>qq2_conv_16"
  [(set (match_operand:QQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:QQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
                      /* Like truncating, but ... */
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"com %0,%0\n\"
                      \".LOK%=:\n\";
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"bra nz,.LINC%=\;\"
                      \"btsc %0,#0\n\"
                      \".LINC%=:\"
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"com %0,%0\n\"
                      \".LOK%=:\n\";
     }
   }
   error(\"Invalid fixed-point round mode specified\n\");
   return \"cannot generate instruction\";
   "
)
 
(define_insn "satfract<mode>uqq2_conv_16"
  [(set (match_operand:UQQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:UQQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
                      /* Like truncating, but ... */
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"clr %0\n\"
                      \".LOK%=:\n\";
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"bra nz,.LINC%=\;\"
                      \"btsc %0,#0\n\"
                      \".LINC%=:\"
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"clr %0\n\"
                      \".LOK%=:\n\";
     }
   }
   error(\"Invalid fixed-point round mode specified\n\");
   return \"cannot generate instruction\";
   "
)
 
(define_insn "satfract<mode>hq2_conv_16"
  [(set (match_operand:HQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:HQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
   (use (reg:HI CORCON))
 
   (clobber (reg:CC_NZC CC_REG))
   ]
  "(!pic30_isa32_target())"
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
                      /* Like truncating, but ... */
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"com %0,%0\n\"
                      \".LOK%=:\n\";
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"bra nz,.LINC%=\;\"
                      \"btsc %0,#0\n\"
                      \".LINC%=:\"
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"com %0,%0\n\"
                      \".LOK%=:\n\";
     }
   }
   error(\"Invalid fixed-point round mode specified\n\");
   return \"cannot generate instruction\";
  "
)
 
(define_insn "satfract<mode>uhq2_conv_16"
  [(set (match_operand:UHQ      0 "pic30_register_operand"     "=r,&r")
        (sat_fract:UHQ
          (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w,r")))
   (clobber (match_scratch:HI  2                             "=X,&r"))
   (use (reg:HI CORCON))
  
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "*
   if (pic30_fp_round_p() == pic30_conventional) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
                      /* Like truncating, but ... */
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"clr %0\n\"
                      \".LOK%=:\n\";
     }
   } else if (pic30_fp_round_p() == pic30_convergent) {
     switch (which_alternative) {
       default: gcc_assert(0);
       case 0: return \"sac.r %1,%0\";
       case 1: return \"mov %d1,%0\;\"            /* copy result */
                      \"sl %1,[w15]\;\"           /* check for round */
                      \"bra nz,.LINC%=\;\"
                      \"btsc %0,#0\n\"
                      \".LINC%=:\"
                      \"addc %0,#0,%0\;\"
                      \"bra ov,.LOV%=\;\"         /* if 0x7FFF -> 0x8000, OV */
                      \"se %t1,%2\;\"             /* otherwise check for */
                      \"rlc %d1,[w15]\;\"         /*   out of bounds input */
                      \"rlc %2,%2\;\"
                      \"bra z,.LOK%=\;\"
                      \"inc %2,%2\;\"
                      \"bra z,.LOK%=\n\"
                      \".LOV%=:\"
                      \"mov #0x7FFF,%0\;\"
                      \"btsc %t1,#7\;\"
                      \"clr %0\n\"
                      \".LOK%=:\n\";
     }
   }
   error(\"Invalid fixed-point round mode specified\n\");
   return \"cannot generate instruction\";
  "
)


(define_expand "satfract<mode>qq2_16"
  [(set (match_operand:QQ    0 "pic30_register_operand"    "=r,r")
      (sat_fract:QQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_satfract<mode>qq2_trunc_16(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_satfract<mode>qq2_conv_16(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

(define_expand "satfract<mode>uqq2_16"
  [(set (match_operand:UQQ   0 "pic30_register_operand"    "=r,r")
      (sat_fract:UQQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_satfract<mode>uqq2_trunc_16(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_satfract<mode>uqq2_conv_16(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

(define_expand "satfract<mode>hq2_16"
  [(set (match_operand:HQ    0 "pic30_register_operand"    "=r,r")
      (sat_fract:QQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_satfract<mode>hq2_trunc_16(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_satfract<mode>hq2_conv_16(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   

(define_expand "satfract<mode>uhq2_16"
  [(set (match_operand:UHQ   0 "pic30_register_operand"    "=r,r")
      (sat_fract:UHQ
        (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "w,r")))
  ]
  "(!pic30_isa32_target())"
  "
  {
    switch (pic30_fp_round_p()) {
      default: gcc_assert(0);

      case pic30_truncation:
      case pic30_fastest:
        emit(
          gen_satfract<mode>uhq2_trunc_16(operands[0],operands[1])
        );
        DONE;
        break;
      case pic30_convergent:
      case pic30_conventional:
        emit(
          gen_satfract<mode>uhq2_conv_16(operands[0],operands[1])
        );
        DONE;
        break;
    }
    FAIL;
  }
  "
)   


; to Q31 - done by routine, these patterns are too long (and complex)

;  from Q15


(define_insn "fractqq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:QQ  1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)
  
(define_insn "fractuqq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:UQQ 1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)
  
(define_insn "fracthq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:HQ  1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)
  
(define_insn "fractuhq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:UHQ 1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)

; from Q31

(define_insn "fractsq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:SQ  1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)
 
(define_insn "fractusq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:USQ 1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)

(define_insn "fractdq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:DQ  1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)
 
(define_insn "fractudq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:UDQ 1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)

(define_insn "fracttq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:TQ  1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)
 
(define_insn "fractutq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (fract_convert:AUACC
          (match_operand:UTQ 1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)

;  saturating from Q15
;   these never saturate because AUACC is always bigger than a Qn

(define_insn "satfractqq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:QQ  1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"

)
  
(define_insn "satfractuqq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:UQQ 1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)
  
(define_insn "satfracthq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:HQ  1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)
  
(define_insn "satfractuhq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:UHQ 1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %1,%0
   mov %1,%d0\;clr %0\;asr %d0,#15,%t0"
)

; from Q31

(define_insn "satfractsq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:SQ  1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)
 
(define_insn "satfractusq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:USQ 1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)

(define_insn "satfractdq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:DQ  1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)
 
(define_insn "satfractudq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:UDQ 1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)

(define_insn "satfracttq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:TQ  1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)
 
(define_insn "satfractutq<mode>2_16"
  [(set (match_operand:AUACC 0 "pic30_accum_or_reg_operand" "=w,r")
        (sat_fract:AUACC
          (match_operand:UTQ 1 "pic30_register_operand"     " r,r")))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "(!pic30_isa32_target())"
  "@
   lac %d1,%0\;mov %1,%m0L
   mov.d %1,%0\;asr %d0,#15,%t0"
)

; Accum <-> float conversions appear as functions only


;;  Secondary reload functions

(define_insn "Ureload_inQI_16"
  [(set
     (match_operand:QI 0 "pic30_register_operand" "=r")
     (match_operand:QI 1 "pic30_near_operand"     " U"))
   (clobber 
     (match_operand:HI 2 "pic30_register_operand" "=&r"))
  ]
  "(!pic30_isa32_target())"
  "*
   if (REGNO(operands[0]) == WR0_REGNO)
     return \"mov.b %1,WREG\";
   return \"mov #%1,%2\;mov.b [%2],%0\";
  "
)

(define_insn "Ureload_outQI_16"
  [(set
     (match_operand:QI 0 "pic30_near_operand"     "=U")
     (match_operand:QI 1 "pic30_register_operand" " r"))
   (clobber 
     (match_operand:HI 2 "pic30_register_operand" "=&r"))
  ]
  "(!pic30_isa32_target())"
  "*
   if (REGNO(operands[1]) == WR0_REGNO) 
     return \"mov.b WREG,%0\";
   else return \"mov #%0,%2\;mov.b %1,[%2]\";
  "
)

(define_insn "Qreload_in<mode>_16"
  [(set
     (match_operand:QUQ31 0 "pic30_accum_or_reg_operand"  "=w,  r")
     (match_operand:QUQ31 1 "pic30_RQ_operand"           "  RQ, RQ"))
   (clobber (match_operand:HI 2 "pic30_register_operand" "=&r,  X"))
  ]
  "(!pic30_isa32_target())"
  "*
   if (which_alternative == 0) 
     return \"mov %1,%2\;mov %2,%m0L\;mov %Q1,%2\;mov %2,%m0H\;clr %m0U\";
   else {
     rtx Wn = 0;
   
     if (GET_CODE(operands[1]) == MEM) {
       if (GET_CODE(XEXP(operands[1],0)) == REG) {
         Wn = XEXP(operands[1],0);
       } else if (GET_CODE(XEXP(operands[1],0)) == PLUS) {
         Wn = XEXP(XEXP(operands[1],0),0);
       }
     }
     if (Wn) {
       unsigned int regno;

       regno = REGNO(Wn);
       if (regno == REGNO(operands[0]))
         return \"mov %Q1,%d0\;mov %1,%0\";
       else 
         return \"mov %1,%0\;mov %Q1,%d0\";
     }
   }
   gcc_assert(0);
   return \"nop\";
  "
)

(define_insn "Qreload_out<mode>_16"
  [(set
     (match_operand:QUQ31 0 "pic30_RQ_operand"            "=RQ, RQ")
     (match_operand:QUQ31 1 "pic30_accum_or_reg_operand"  "  w,  r"))
   (clobber (match_operand:HI 2 "pic30_register_operand"  "=&r,  X"))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %m1L,%2\;mov %2,%0\;mov %m1H,%2\;mov %2,%Q0
   mov %1,%0\;mov %d1,%Q0"
)

(define_insn "Qreload_in<mode>_16"
  [(set
     (match_operand:AUACC 0 "pic30_accum_or_reg_operand"  "=w,  r")
     (match_operand:AUACC 1 "pic30_RQ_operand"           "  RQ, RQ"))
   (clobber (match_operand:HI 2 "pic30_register_operand"  "=&r, X"))
  ]
  "(!pic30_isa32_target())"
  "*
   if (which_alternative == 0)
     return \"mov %1,%2\;mov %2,%m0L\;mov %Q1,%2\;mov %2,%m0H\;mov %R1,%2\;mov %2,%m0U\";
   else {
     rtx Wn = 0;
   
     if (GET_CODE(operands[1]) == MEM) {
       if (GET_CODE(XEXP(operands[1],0)) == REG) {
         Wn = XEXP(operands[1],0);
       } else if (GET_CODE(XEXP(operands[1],0)) == PLUS) {
         Wn = XEXP(XEXP(operands[1],0),0);
       } 
     }
     if (Wn) {
       unsigned int regno;

       regno = REGNO(Wn);
       if (pic30_psrd_psrd_errata(operands[1],NULL)) {
         pic30_rtx_nops+=2;
       if (regno == REGNO(operands[0]))
           return \"mov %Q1,%d0\;nop\;mov.b %R1,%t0\;nop\;mov %1,%0\";
         else if (regno == REGNO(operands[0])+1)
           return \"mov %1,%0\;nop\;mov.b %R1,%t0\;nop\;mov %Q1,%d0\";
         else
           return \"mov %1,%0\;nop\;mov %Q1,%d0\;nop\;mov.b %R1,%t0\";
       } else {
         if (regno == REGNO(operands[0]))
         return \"mov %Q1,%d0\;mov.b %R1,%t0\;mov %1,%0\";
       else if (regno == REGNO(operands[0])+1)
         return \"mov %1,%0\;mov.b %R1,%t0\;mov %Q1,%d0\";
       else
         return \"mov %1,%0\;mov %Q1,%d0\;mov.b %R1,%t0\";
     }
   }
   }
   gcc_assert(0);
   return \"nop\";
  "
)

(define_insn "Qreload_out<mode>_16"
  [(set
     (match_operand:AUACC 0 "pic30_RQ_operand"           "=RQ, RQ")
     (match_operand:AUACC 1 "pic30_accum_or_reg_operand" "  w,  r"))
   (clobber (match_operand:HI 2 "pic30_register_operand" "=&r,  X"))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %m1L,%2\;mov %2,%0\;mov %m1H,%2\;mov %2,%Q0\;mov %m1U,%2\;mov %2,%R0
   mov %1,%0\;mov %d1,%Q0\;mov.b %t1,%R0"
)

(define_insn "TUreload_in<mode>_16"
  [(set
     (match_operand:AUACC 0 "pic30_accum_or_reg_operand"  "=w, &r")
     (match_operand:AUACC 1 "pic30_data_operand"          " TU,TU"))
   (clobber (match_operand:HI 2 "pic30_register_operand"  "=&r, X"))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %1,%2\;mov %2,%m0L\;mov %1+2,%2\;mov %2,%m0H\;mov %1+4,%2\;mov %2,%m0U
   mov %1,%0\;mov %1+2,%d0\;mov %1+4,%t0"
)

(define_insn "TUreload_insi_16"
  [(set
     (match_operand:SI 0 "pic30_accum_or_reg_operand"     "=w, &r")
     (match_operand:SI 1 "pic30_data_operand"             " TU,TU"))
   (clobber (match_operand:HI 2 "pic30_register_operand"  "=&r, X"))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %1,%2\;mov %2,%m0L\;mov %1+2,%2\;mov %2,%m0H
   mov %1,%0\;mov %1+2,%d0"
)
      

(define_insn "TUreload_out<mode>_16"
  [(set
     (match_operand:AUACC 0 "pic30_data_operand"         "=TU,TU")
     (match_operand:AUACC 1 "pic30_accum_or_reg_operand" " w, r"))
   (clobber (match_operand:HI 2 "pic30_register_operand" "=&r,X"))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %m1L,%2\;mov %2,%0\;mov %m1H,%2\;mov %2,%0+2\;mov %m1U,%2\;mov %2,%0+4
   mov %1,%0\;mov %d1,%0+2\;mov %t1,%0+4"
)

(define_insn "TUreload_outhi_16"
  [(set
     (match_operand:HI   0 "pic30_data_operand"         "=TU,TU")
     (match_operand:HI   1 "pic30_accum_or_reg_operand" " w, r"))
   (clobber (match_operand:HI 2 "pic30_register_operand" "=&r,X"))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %m1L,%2\;mov %2,%0
   mov %1,%0"
)

(define_insn "TUreload_outsi_16"
  [(set
     (match_operand:SI   0 "pic30_data_operand"         "=TU,TU")
     (match_operand:SI   1 "pic30_accum_or_reg_operand" " w, r"))
   (clobber (match_operand:HI 2 "pic30_register_operand" "=&r,X"))
  ]
  "(!pic30_isa32_target())"
  "@
   mov %m1L,%2\;mov %2,%0\;mov %m1H,%2\;mov %2,%0+2
   mov %1,%0\;mov %d1,%0+2"
)

; reloads because the displacement is too large

(define_insn "Qreloaddisp_out<mode>_16"
  [(set
      (match_operand:QRELOADS  0 "pic30_any_QR_operand"    "= Q, R")
      (match_operand:QRELOADS  1 "pic30_register_operand"  "  r, r"))
   (clobber (match_operand:HI  2 "pic30_register_operand"  "=&r, X"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "TARGET_CLASSIC"
  "*
  { 
    if (which_alternative == 0) {
      rtx inner;
      rtx lhs,rhs;
      int offset;
      static char result[256];

      gcc_assert(MEM_P(operands[0]));
      inner = XEXP(operands[0],0);
      gcc_assert((GET_CODE(inner) == PLUS) || (GET_CODE(inner) == MINUS));
      lhs = XEXP(inner,0);
      rhs = XEXP(inner,1);
      gcc_assert(REG_P(lhs));
      gcc_assert(GET_CODE(rhs) == CONST_INT);
      offset = INTVAL(rhs);
      if (GET_CODE(inner) == MINUS) offset = -1*offset;
      
      if (GET_MODE_SIZE(<MODE>mode) == 1) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"mov.b %%1,[%s+%%2]\", 
                offset, reg_names[REGNO(lhs)]);
      } else if (GET_MODE_SIZE(<MODE>mode) == 2) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"mov %%1,[%s+%%2]\",
                offset, reg_names[REGNO(lhs)]);
      } else if (GET_MODE_SIZE(<MODE>mode) == 4) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"add %s,%%2,%%2\;\"
                        \"mov %%1,[%%2++]\;mov %%d1,[%%2]\",
                offset, reg_names[REGNO(lhs)]);
      } else if (GET_MODE_SIZE(<MODE>mode) == 6) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"add %s,%%2,%%2\;\"
                        \"mov %%1,[%%2++]\;mov %%d1,[%%2++]\;mov %%t1,[%%2]\",
               offset, reg_names[REGNO(lhs)]);
      } else if (GET_MODE_SIZE(<MODE>mode) == 8) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"add %s,%%2,%%2\;\"
                        \"mov %%1,[%%2++]\;mov %%d1,[%%2++]\;\"
                        \"mov %%t1,[%%2++]\;mov %%q1,[%%2]\", 
              offset, reg_names[REGNO(lhs)]);
      } else gcc_assert(0);
      return result;
    } else {
      if (GET_MODE_SIZE(<MODE>mode) == 1) {
        return \"mov.b %1,%0\";
      } else if (GET_MODE_SIZE(<MODE>mode) == 2) {
        return \"mov %1,%0\";
      } else if (GET_MODE_SIZE(<MODE>mode) == 4) {
        return \"mov %1,%I0\;mov %d1,%D0\";
      } else if (GET_MODE_SIZE(<MODE>mode) == 6) {
        return \"mov %r0,%2\;\"
               \"mov %1,[%2++]\;mov %d1,[%2++]\;mov %t1,[%2]\";
      } else if (GET_MODE_SIZE(<MODE>mode) == 8) {
        return \"mov %r0,%2\;\"
               \"mov %1,[%2++]\;mov %d1,[%2++]\;mov %t1,[%2++]\;mov %q1,[%2]\";
      } else gcc_assert(0);
      return \"nop\";
    }
  }
  "
)

(define_insn "Qreloaddisp_in<mode>_16"
  [(set
     (match_operand:QRELOADS  0 "pic30_register_operand" "= r, r")
     (match_operand:QRELOADS  1 "pic30_any_QR_operand"   "  Q, R"))
   (clobber (match_operand:HI 2 "pic30_register_operand" "=&r, X"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "TARGET_CLASSIC"
  "*
  {
    static char result[256];
    const char *dtq[] = {\"d\", \"t\", \"q\" };
    char *p = result;
    if (which_alternative == 0) {
      rtx inner;
      rtx lhs,rhs;
      int offset;

      gcc_assert(MEM_P(operands[1]));
      inner = XEXP(operands[1],0);
      gcc_assert((GET_CODE(inner) == PLUS) || (GET_CODE(inner) == MINUS));
      lhs = XEXP(inner,0);
      rhs = XEXP(inner,1);
      gcc_assert(REG_P(lhs));
      gcc_assert(GET_CODE(rhs) == CONST_INT);
      offset = INTVAL(rhs);
      if (GET_CODE(inner) == MINUS) offset = -1*offset;
      
      if (GET_MODE_SIZE(<MODE>mode) == 1) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"mov.b [%s+%%2],%%0\",
                offset, reg_names[REGNO(lhs)]);
      } else if (GET_MODE_SIZE(<MODE>mode) == 2) {
        sprintf(result, \"mov #%d,%%2\;\"
                        \"mov [%s+%%2],%%0\",
                offset, reg_names[REGNO(lhs)]);
      } else if (GET_MODE_SIZE(<MODE>mode) == 4) {
        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
          pic30_rtx_nops+=1;
        sprintf(result, \"mov #%d,%%2\;\"
                        \"add %s,%%2,%%2\;\"
                          \"mov [%%2++],%%0\;\"
                          \"\nop\;\"
                          \"mov [%%2],%%d0\",
                offset, reg_names[REGNO(lhs)]);
        } else {
          sprintf(result, \"mov #%d,%%2\;\"
                          \"add %s,%%2,%%2\;\"
                          \"mov [%%2++],%%0\;\"
                          \"mov [%%2],%%d0\",
                 offset, reg_names[REGNO(lhs)]);
        }
      } else if (GET_MODE_SIZE(<MODE>mode) == 6) {
        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
          pic30_rtx_nops+=2;
        sprintf(result, \"mov #%d,%%2\;\"
                        \"add %s,%%2,%%2\;\"
                          \"mov [%%2++],%%0\;\"
                          \"nop\;\"
                          \"mov [%%2++],%%d0\;\"
                          \"nop\;\"
                          \"mov [%%2],%%t0\",
               offset, reg_names[REGNO(lhs)]);
        } else {
          sprintf(result, \"mov #%d,%%2\;\"
                          \"add %s,%%2,%%2\;\"
                          \"mov [%%2++],%%0\;\"
                          \"mov [%%2++],%%d0\;\"
                          \"mov [%%2],%%t0\",
                 offset, reg_names[REGNO(lhs)]);
        }
      } else if (GET_MODE_SIZE(<MODE>mode) == 8) {
        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
          pic30_rtx_nops+=3;
        sprintf(result, \"mov #%d,%%2\;\"
                        \"add %s,%%2,%%2\;\"
                          \"mov [%%2++],%%0\;\"
                          \"nop\;\"
                          \"mov [%%2++],%%d0\;\"
                          \"nop\;\"
                          \"mov [%%2++],%%t0\;\"
                          \"nop\;\"
                          \"mov [%%2],%%q0\",
               offset, reg_names[REGNO(lhs)]);
        } else {
          sprintf(result, \"mov #%d,%%2\;\"
                          \"add %s,%%2,%%2\;\"
                          \"mov [%%2++],%%0\;\"
                          \"mov [%%2++],%%d0\;\"
                          \"mov [%%2++],%%t0\;\"
                          \"mov [%%2],%%q0\",
                 offset, reg_names[REGNO(lhs)]);
        }
      } else gcc_assert(0);
      return result;
    } else {
      int my_rhs_regno = REGNO(XEXP(operands[1],0));
      int lhs_regno = REGNO(operands[0]);
      int overlap = -1;
      int overlap_offset = 0;

      if (GET_MODE_SIZE(<MODE>mode) == 1) {
        return \"mov.b %1,%0\";
      } else if (GET_MODE_SIZE(<MODE>mode) == 2) {
        return \"mov %1,%0\";
      } else if (GET_MODE_SIZE(<MODE>mode) == 4) {
        if (my_rhs_regno != lhs_regno) {
          // can write in any order
          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops+=1;
            return \"mov %1,%0\;\"
                   \"nop\;\"
                   \"mov [%r1+2],%d0\";
          } else {
            return \"mov %1,%0\;\"
                   \"mov [%r1+2],%d0\";
          }
        } else {
          // overlap, must write rhs last
          if (pic30_psrd_psrd_errata(operands[1],NULL)) {
            pic30_rtx_nops+=1;
            return \"mov [%r1+2],%d0\;\"
                   \"nop\;\"
                   \"mov %1,%0\";
          } else {
            return \"mov [%r1+2],%d0\;\"
                   \"mov %1,%0\";
          }
        }
      } else if (GET_MODE_SIZE(<MODE>mode) == 6) {
        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
          pic30_rtx_nops+=2;
          if (my_rhs_regno == lhs_regno) {
            overlap = my_rhs_regno;
            overlap_offset = 0;
          } else {
            p += sprintf(p,\"mov %%1,%%0\;nop\;\");
          }
          if (my_rhs_regno == lhs_regno+1) {
            overlap = my_rhs_regno;
            overlap_offset = 1;
          } else {
            p += sprintf(p,\"mov [%%r1+2],%%d0\;nop\;\");
          }
          if (my_rhs_regno == lhs_regno+2) {
            overlap = my_rhs_regno;
            overlap_offset = 2;
          } else {
            p += sprintf(p,\"mov [%%r1+4],%%t0\");
          }
          if (overlap >= 0) {
            // something overlapped, safe to write now
            if (overlap_offset) {
              p += sprintf(p,\"\;nop\;mov [%%r1+%d],%%%s0\",
                          overlap_offset * 2,
                          dtq[overlap_offset-1]);
            } else {
              p += sprintf(p,\"\;nop\;mov %%1,%%0\");
            }
          }
        } else {
          if (my_rhs_regno == lhs_regno) {
            overlap = my_rhs_regno;
            overlap_offset = 0;
          } else {
            p += sprintf(p,\"mov %%1,%%0\;\");
          }
          if (my_rhs_regno == lhs_regno+1) {
            overlap = my_rhs_regno;
            overlap_offset = 1;
          } else {
            p += sprintf(p,\"mov [%%r1+2],%%d0\;\");
          }
          if (my_rhs_regno == lhs_regno+2) {
            overlap = my_rhs_regno;
            overlap_offset = 2;
          } else {
            p += sprintf(p,\"mov [%%r1+4],%%t0\");
          }
          if (overlap >= 0) {
            // something overlapped, safe to write now
            if (overlap_offset) {
              p += sprintf(p,\"\;mov [%%r1+%d],%%%s0\",
                          overlap_offset * 2,
                          dtq[overlap_offset-1]);
            
            } else {
              p += sprintf(p,\"\;mov %%1,%%0\");
            }
          }
        }
        return result;
      } else if (GET_MODE_SIZE(<MODE>mode) == 8) {
        if (pic30_psrd_psrd_errata(operands[1],NULL)) {
          pic30_rtx_nops+=3;
          if (my_rhs_regno == lhs_regno) {
            overlap = my_rhs_regno;
            overlap_offset = 0;
          } else {
            p += sprintf(p,\"mov %%1,%%0\;nop\;\");
          }
          if (my_rhs_regno == lhs_regno+1) {
            overlap = my_rhs_regno;
            overlap_offset = 1;
          } else {
            p += sprintf(p,\"mov [%%r1+2],%%d0\;nop\;\");
          }
          if (my_rhs_regno == lhs_regno+2) {
            overlap = my_rhs_regno;
            overlap_offset = 2;
          } else {
            p += sprintf(p,\"mov [%%r1+4],%%t0\;nop\;\");
          }
          if (my_rhs_regno == lhs_regno+3) {
            overlap = my_rhs_regno;
            overlap_offset = 3;
          } else {
            p += sprintf(p,\"mov [%%r1+6],%%q0\");
          }
          if (overlap >= 0) {
            // something overlapped, safe to write now
            if (overlap_offset) {
              p += sprintf(p,\"\;nop\;mov [%%r1+%d],%%%s0\",
                          overlap_offset * 2,
                          dtq[overlap_offset-1]);
            } else {
              p += sprintf(p,\"\;nop\;mov %%1,%%0\");
            }
          } 
        } else {
          if (my_rhs_regno == lhs_regno) { 
            overlap = my_rhs_regno;
            overlap_offset = 0;
          } else {
            p += sprintf(p,\"mov %%1,%%0\;\");
          }
          if (my_rhs_regno == lhs_regno+1) {
            overlap = my_rhs_regno;
            overlap_offset = 1; 
          } else { 
            p += sprintf(p,\"mov [%%r1+2],%%d0\;\");
          }               
          if (my_rhs_regno == lhs_regno+2) {
            overlap = my_rhs_regno;
            overlap_offset = 2;
          } else {
            p += sprintf(p,\"mov [%%r1+4],%%t0\;\");
          }
          if (my_rhs_regno == lhs_regno+3) {
            overlap = my_rhs_regno;
            overlap_offset = 3;
          } else {
            p += sprintf(p,\"mov [%%r1+6],%%q0\");
          }
          if (overlap >= 0) {
            // something overlapped, safe to write now
            if (overlap_offset) {
              p += sprintf(p,\"\;mov [%%r1+%d],%%%s0\",
                          overlap_offset * 2,
                          dtq[overlap_offset-1]);
             
            } else {
              p += sprintf(p,\"\;mov %%1,%%0\");
            }
          }
        }
        return result;
      } else gcc_assert(0);
    }
  }
  "
)

(define_insn "popcounthi2_16"
  [(set (match_operand:HI   0 "pic30_reg_or_R_operand"  "=&rR")
        (popcount:HI
          (match_operand:HI 1 "pic30_reg_or_R_operand" "  rR")))
   (clobber 
          (match_scratch:HI 2                           "= &r"))
   (clobber 
          (match_scratch:HI 3                           "= &r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "TARGET_CLASSIC"
  "clr %0\;mov %1,%3\;.LL1%=:\;ff1r %3,%2\;bra c,.LL2%=\;inc %0,%0\;lsr %3,%2,%3\;bra .LL1%=\;.LL2%=:"
 [
   (set_attr "cc" "clobber")
 ]
)

(define_insn "popcountsi2_16"
  [(set (match_operand:HI   0 "pic30_reg_or_R_operand"  "=&r,R")
        (popcount:HI
          (match_operand:SI 1 "pic30_reg_or_R_operand" "  r,R")))
   (clobber 
          (match_scratch:HI 2                           "=&r,r"))
   (clobber 
          (match_scratch:HI 3                           "=&r,r"))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "TARGET_CLASSIC"
  "@
   clr %0\;mov %1,%3\;.LL1%=:\;ff1r %3,%2\;bra c,.LL2%=\;inc %0,%0\;lsr %3,%2,%3\;bra .LL1%=\;.LL2%=:\;mov %d1,%3\;.LL3%=:\;ff1r %3,%2\;bra c,.LL4%=\;inc %0,%0\;lsr %3,%2,%3\;bra .LL3%=\;.LL4%=:
   clr %0\;mov %I1,%3\;.LL1%=:\;ff1r %3,%2\;bra c,.LL2%=\;inc %0,%0\;lsr %3,%2,%3\;bra .LL1%=\;.LL2%=:\;mov %d1,%3\;.LL3%=:\;ff1r %3,%2\;bra c,.LL4%=\;inc %0,%0\;lsr %3,%2,%3\;bra .LL3%=\;.LL4%=:"
 [
   (set_attr "cc" "clobber")
 ]
)

(define_insn "swapqi_16"
    [(set (match_operand:QI     0 "pic30_register_operand" "=r,r")
          (ior:QI
            (ashift:QI 
              (match_operand:QI 1 "pic30_register_operand" " 0,r")
              (const_int 4))
            (lshiftrt:QI 
              (match_dup 1)
              (const_int 4))))]

   "TARGET_CLASSIC"
   "@
    swap.b %0
    mov.b %1,%0\;swap.b %0"
)
  
(define_insn "swaphi_16"
    [(set (match_operand:HI     0 "pic30_register_operand" "=r,r")
          (ior:HI
            (ashift:HI 
              (match_operand:HI 1 "pic30_register_operand" " 0,r")
              (const_int 8))
            (lshiftrt:HI 
              (match_dup 1)
              (const_int 8))))]

   "TARGET_CLASSIC"
   "@
    swap %0
    mov %1,%0\;swap %0"
)

(define_insn "flim_packhi_16"
  [(set (match_operand:SI       0 "pic30_register_operand" "=r")
        (ior:SI
          (zero_extend:SI
            (match_operand:HI   1 "pic30_register_operand"  "r"))
          (ashift:SI 
            (zero_extend:SI
              (match_operand:HI 2 "pic30_register_operand"  "r"))
            (const_int 16))))
  ]
  "TARGET_CLASSIC"
  "*
   if (REGNO(operands[1]) == REGNO(operands[0])) 
      return \"; nop\";
   if (REGNO(operands[2]) == REGNO(operands[0]))
      return \"mov %2,%d0\;mov %1,%0\";
   else return \"mov %1,%0\;mov %2,%d0\";
  "
)

(define_insn "flimhi_16"
  [(set (match_operand:HI   0 "pic30_register_operand" "+r")
        (if_then_else
          (gt (match_operand:HI 1 "pic30_register_operand" "0")
              (subreg:HI (match_operand:SI 2 "pic30_register_operand" "r") 0))
          (subreg:HI (match_dup 2) 0)
          (if_then_else
            (lt (match_dup 1)
                (subreg:HI (match_dup 2) 2))
             (subreg:HI (match_dup 2) 2)
             (match_dup 1))))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(TARGET_CLASSIC) && (pic30_isav4_target())" 
  "flim %2,%0"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "flim_excesshi_16"
  [(parallel 
    [(set (match_operand:HI 0 "pic30_register_operand" "+r")
         (if_then_else
            (gt (match_operand:HI 1 "pic30_register_operand" " 0")
                (subreg:HI (match_operand:SI 2 "pic30_register_operand" "r") 0))
            (subreg:HI (match_dup 2) 0)
            (if_then_else
              (lt (match_dup 1)
                  (subreg:HI (match_dup 2) 2))
               (subreg:HI (match_dup 2) 2)
               (match_dup 1))))
    (set (match_operand:HI   3 "pic30_register_operand" "=r")
         (if_then_else
            (gt (match_dup 1)
                (subreg:HI (match_dup 2) 0))
            (const_int 1)
          (if_then_else
              (lt (match_dup 1)
                  (subreg:HI (match_dup 2) 2))
               (const_int -1)
               (const_int 0))))
     (clobber (reg:CC_NZ CC_REG))
    ])
  ]
  "(TARGET_CLASSIC) && (pic30_isav4_target())"
  "flim %2,%1,%3"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "flimv_excesshi_16"
  [(parallel 
    [(set (match_operand:HI 0 "pic30_register_operand" "+r")
         (if_then_else
            (gt (match_operand:HI 1 "pic30_register_operand" " 0")
                (subreg:HI (match_operand:SI 2 "pic30_register_operand" "r") 0))
            (subreg:HI (match_dup 2) 0)
            (if_then_else
              (lt (match_dup 1)
                  (subreg:HI (match_dup 2) 2))
               (subreg:HI (match_dup 2) 2)
               (match_dup 1))))
    (set (match_operand:HI   3 "pic30_register_operand" "=r")
         (if_then_else
            (gt (match_dup 1)
                (subreg:HI (match_dup 2) 0))
            (minus:HI 
              (match_dup 1) 
              (subreg:HI (match_dup 2) 0))
            (if_then_else
              (lt (match_dup 1)
                  (subreg:HI (match_dup 2) 2))
               (minus:HI 
                 (match_dup 1) 
                 (subreg:HI (match_dup 2) 2))
               (const_int 0))))
     (clobber (reg:CC_NZ CC_REG))
    ])
  ]
  "(TARGET_CLASSIC) && (pic30_isav4_target())"
  "flim.v %2,%1,%3"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "min_16"
  [
  (set (match_operand:HI   0 "pic30_accumulator_operand" "=w")
       (unspec:HI [
          (match_operand:HI 1 "pic30_accumulator_operand" " 0")
          (match_operand:HI 2 "pic30_accumulator_operand" " w")
        ] UNSPEC_MIN))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(TARGET_CLASSIC) && (pic30_isav4_target())"
  "min %0"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "min_excess_16"
  [(parallel [
    (set (match_operand:HI   0 "pic30_accumulator_operand" "=w")
         (unspec:HI [
            (match_operand:HI 1 "pic30_accumulator_operand" " 0")
            (match_operand:HI 2 "pic30_accumulator_operand" " w")
          ] UNSPEC_MIN))
    (set (match_operand:HI   3 "pic30_reg_or_R_operand" "=rR")
         (unspec:HI [
            (match_dup 1)
            (match_dup 2)
         ] UNSPEC_MINV))
    (clobber (reg:CC_NZ CC_REG))
    ])
  ]
  "(TARGET_CLASSIC) && (pic30_isav4_target())"
  "min %0, %3"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "minv_excess_16"
  [(parallel [
    (set (match_operand:HI   0 "pic30_accumulator_operand" "=w")
         (unspec:HI [
            (match_operand:HI 1 "pic30_accumulator_operand" " 0")
            (match_operand:HI 2 "pic30_accumulator_operand" " w")
          ] UNSPEC_MIN))
    (set (match_operand:HI   3 "pic30_reg_or_R_operand" "=rR")
         (unspec:HI [
            (match_dup 1)
            (match_dup 2)
         ] UNSPEC_MINV2))
    (clobber (reg:CC_NZ CC_REG))
    ])
  ]
  "(TARGET_CLASSIC) && (pic30_isav4_target())"
  "min.v %0, %3"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "max_16"
  [(set (match_operand:HI   0 "pic30_accumulator_operand" "=w")
        (unspec:HI [
          (match_operand:HI 1 "pic30_accumulator_operand" " 0")
          (match_operand:HI 2 "pic30_accumulator_operand" " w")
        ] UNSPEC_MAX))
   (clobber (reg:CC_NZ CC_REG))
  ]
  "(TARGET_CLASSIC) && (pic30_isav4_target())"
  "max %0"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "max_excess_16"
  [(parallel [
    (set (match_operand:HI   0 "pic30_accumulator_operand" "=w")
         (unspec:HI [
            (match_operand:HI 1 "pic30_accumulator_operand" " 0")
            (match_operand:HI 2 "pic30_accumulator_operand" " w")
          ] UNSPEC_MAX))
    (set (match_operand:HI   3 "pic30_reg_or_R_operand" "=rR")
         (unspec:HI [
            (match_dup 1)
            (match_dup 2)
         ] UNSPEC_MAXV))
    (clobber (reg:CC_NZ CC_REG))
    ])
  ]
  "(TARGET_CLASSIC) && (pic30_isav4_target())"
  "max %0, %3"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "maxv_excess_16"
  [(parallel [
    (set (match_operand:HI   0 "pic30_accumulator_operand" "=w")
         (unspec:HI [
            (match_operand:HI 1 "pic30_accumulator_operand" " 0")
            (match_operand:HI 2 "pic30_accumulator_operand" " w")
          ] UNSPEC_MAX))
    (set (match_operand:HI   3 "pic30_reg_or_R_operand" "=rR")
         (unspec:HI [
            (match_dup 1)
            (match_dup 2)
         ] UNSPEC_MAXV2))
    (clobber (reg:CC_NZ CC_REG))
    ])
  ]
  "(TARGET_CLASSIC) && (pic30_isav4_target())"
  "max.v %0, %3"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_mode_iterator CCMODES [QI HI])

(define_insn "skipclrop2<mode>_16"
  [(set (match_operand:CCMODES    0 "pic30_register_operand" "+r")
        (if_then_else:CCMODES
          (compare
            (zero_extract
                 (match_operand   1 "pic30_reg_or_near_operand" "rU")
                 (const_int 1)
                 (match_operand   2 "immediate_operand"         "i"))
            (const_int 0))
          (match_operator:CCMODES 3 "pic30_skip2_operator" 
            [
              (match_operand:CCMODES 4 "pic30_reg_or_near_operand" "rU")
              (match_operand:CCMODES 5 "pic30_reg_or_imm_operand"  "ri")
            ])
          (match_dup 0)
        ))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "TARGET_CLASSIC"
  "*return pic30_skip(insn,operands,0,2);"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "skipclrop1<mode>_16"
  [(set (match_operand:CCMODES    0 "pic30_register_operand" "+r")
        (if_then_else:CCMODES
          (compare
            (zero_extract
                 (match_operand   1 "pic30_reg_or_near_operand" "rU")
                 (const_int 1)
                 (match_operand   2 "immediate_operand"         "i"))
            (const_int 0))
          (match_operator:CCMODES 3 "pic30_skip1_operator"
            [
              (match_operand:CCMODES 4 "general_operand"        "")
            ])
          (match_dup 0)
        ))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "TARGET_CLASSIC"
  "*return pic30_skip(insn,operands,0,1);"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "skipclrop0<mode>_16"
  [(set (match_operand:CCMODES    0 "pic30_register_operand" "+r")
        (if_then_else:CCMODES
          (compare
            (zero_extract
                 (match_operand   1 "pic30_reg_or_near_operand" "rU")
                 (const_int 1)
                 (match_operand   2 "immediate_operand"         "i"))
            (const_int 0))
            (match_operand:CCMODES 3 "pic30_reg_or_mem_operand" "g")
          (match_dup 0)
        ))
  ]
  "TARGET_CLASSIC"
  "*return pic30_skip(insn,operands,0,0);"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "skipsetop2<mode>_16"
  [(set (match_operand:CCMODES    0 "pic30_register_operand" "+r")
        (if_then_else:CCMODES
          (compare
            (zero_extract
                 (match_operand   1 "pic30_reg_or_near_operand" "rU")
                 (const_int 1)
                 (match_operand   2 "immediate_operand"         "i"))
            (const_int 1))
          (match_operator         3 "pic30_skip2_operator" 
            [
              (match_operand:CCMODES 4 "pic30_reg_or_near_operand" "rU")
              (match_operand:CCMODES 5 "pic30_reg_or_imm_operand"  "ri")
            ])
          (match_dup 0)
        ))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "TARGET_CLASSIC"
  "*return pic30_skip(insn, operands,1, 2);"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "skipsetop1<mode>_16"
  [(set (match_operand:CCMODES    0 "pic30_register_operand" "+r")
        (if_then_else:CCMODES
          (compare
            (zero_extract
                 (match_operand   1 "pic30_reg_or_near_operand" "rU")
                 (const_int 1)
                 (match_operand   2 "immediate_operand"         "i"))
            (const_int 1))
          (match_operator         3 "pic30_skip1_operator" 
            [
              (match_operand:CCMODES 4 "general_operand"        "")
            ])
          (match_dup 0)
        ))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "TARGET_CLASSIC"
  "*return pic30_skip(insn, operands,1, 1);"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "skipsetop0<mode>_16"
  [(set (match_operand:CCMODES    0 "pic30_register_operand" "+r")
        (if_then_else:CCMODES
          (compare
            (zero_extract
                 (match_operand   1 "pic30_reg_or_near_operand" "rU")
                 (const_int 1)
                 (match_operand   2 "immediate_operand"         "i"))
            (const_int 1))
            (match_operand:CCMODES 3 "pic30_reg_or_mem_operand" "g")
          (match_dup 0)
        ))
   (clobber (reg:CC_NZC CC_REG))
  ]
  "TARGET_CLASSIC"
  "*return pic30_skip(insn, operands, 1, 0);"
  [
    (set_attr "cc" "clobber")
  ]
)

(define_insn "bitcopy_hi_16"
 [(set (match_operand:HI 0 "pic30_mode2_operand" "=r, r")
       (unspec_volatile [ (match_dup 0)
                     (match_operand:HI 1 "pic30_register_operand" "r, r")
                     (match_operand:HI 2 "pic30_mode2_operand" "r, r")
                     (match_operand:HI 3 "pic30_reg_or_imm_operand" "Kh,r")
                   ] UNSPECV_BITCOPY))
  (clobber (reg:CC_C CC_REG))
 ]
 "(!pic30_isa32_target())"
 "@
  btst.c [%2],#%3\;bsw.c [%0],%1
  btst.c [%2],%3\;bsw.c [%0],%1"
 [
  (set_attr "type" "etc,defuse")
  (set_attr "op_type" "alu")
 ]
)

(define_insn "bitcopy_umm_16"
 [(set (match_operand:P32UMM 0 "pic30_mode2_operand"                "=r, r")
       (unspec_volatile [(match_dup 0)
                     (match_operand:HI 1 "pic30_register_operand"   " r, r")
                     (match_operand:P32UMM 2 "pic30_mode2_operand"  " r, r")
                     (match_operand:HI 3 "pic30_reg_or_imm_operand" "Kh, r")
                     ] UNSPECV_BITCOPY))
  (set (reg:HI PSVPAG)
         (unspec_volatile:HI [
            (match_dup 2)
          ] UNSPEC_UMMPAGE))
  (set (reg:HI DSWPAG)
         (unspec_volatile:HI [
            (match_dup 0)
          ] UNSPEC_UMMPAGE))
  (clobber (match_scratch:HI   4                                    "=r, &r"))
  (clobber (match_scratch:HI   5                                    "=r, &r"))
  (clobber (reg:CC_C CC_REG))
 ]
  "(!pic30_isa32_target() && TARGET_EDS)"
  "*
  if (pic30_ecore_target()||pic30_isav4_target()) {
    switch(which_alternative) {
      default: gcc_assert(0);
      case 0:
        return \"mov %d0,DSWPAG\;\"
               \"mov %d2,%u5\;\"
               \"rrnc %2,%5\;\"
               \"rrnc %0,%4\;\"
               \"btst.c [%5],#%3\;\"
               \"bsw.c [%4],%1\";
      case 1:
        return \"mov %d0,DSWPAG\;\"
               \"mov %d2,%u5\;\"
               \"rrnc %2,%5\;\"
               \"rrnc %0,%4\;\"
               \"btst.c [%5],%3\;\"
               \"bsw.c [%4],%1\";
    }
  } else {
    switch(which_alternative) {
      default: gcc_assert(0);
      case 0:
        return \"mov %d2,%u5\;\"
               \"rrnc %2,%5\;\"
               \"rrnc %0,%4\;\"
               \"btst.c [%5],#%3\;\"
               \"bsw.c [%4],%1\";
      case 1:
        return \"mov %d2,%u5\;\"
               \"rrnc %2,%5\;\"
               \"rrnc %0,%4\;\"
               \"btst.c [%5],%3\;\"
               \"bsw.c [%4],%1\";
    }
  }"
)
